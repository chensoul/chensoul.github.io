<!doctype html><html class=no-js lang=zh-cn><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>[译]为 Spring Boot 应用程序创建优化的 Docker 映像 - Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="[译]为 Spring Boot 应用程序创建优化的 Docker 映像"><meta property="og:description" content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/08/16/spring-boot-docker/"><meta property="og:site_name" content="ChenSoul Blog"><meta property="og:image" content><meta itemprop=name content="[译]为 Spring Boot 应用程序创建优化的 Docker 映像"><meta itemprop=description content="容器已成为打包具有所有软件和操作系统依赖项的应用程序，然后将其传送到不同环境的首选方式。
本文着眼于容器化 Spring Boot 应用程序的不同方法："><meta itemprop=datePublished content="2023-08-16T00:00:00+00:00"><meta itemprop=dateModified content="2023-08-16T00:00:00+00:00"><meta itemprop=wordCount content="825"><meta itemprop=keywords content="Spring-Boot,Docker"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="[译]为 Spring Boot 应用程序创建优化的 Docker 映像"><meta name=twitter:description content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps"><meta name=twitter:image content><link rel=preconnect href=//fonts.loli.net crossorigin><link rel=dns-prefetch href=//fonts.loli.net><link rel=stylesheet href="https://fonts.loli.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class="logo logo--mixed"><a class=logo__link href=/ title="ChenSoul Blog" rel=home><div class="logo__item logo__imagebox"><img class=logo__img src=/logo.svg loading=lazy alt="Site logo" width=60 height=60></div><div class="logo__item logo__text"><div class=logo__title>ChenSoul Blog</div><div class=logo__tagline>Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>菜单</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>首页</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>分类</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>关于</span></a></li><li class=menu__item><a class=menu__link href=/index.xml><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>[译]为 Spring Boot 应用程序创建优化的 Docker 映像</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 110 28 1 1 0 010-28m0 3a3 3 0 100 22 3 3 0 000-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class=meta__text datetime=2023-08-16>2023-08-16</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/spring-boot/ rel=category>Spring-Boot</a></span></div><div class="meta__item-tags meta__item"><svg class="meta__icon icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 000-6 3 3 0 000 6"/></svg><span class=meta__text><a class=meta__link href=/tags/spring-boot/ rel=tag>Spring-Boot</a>, <a class=meta__link href=/tags/docker/ rel=tag>Docker</a></span></div></div></header><div class="content post__content clearfix"><p>容器已成为打包具有所有软件和操作系统依赖项的应用程序，然后将其传送到不同环境的首选方式。</p><p>本文着眼于容器化 Spring Boot 应用程序的不同方法：</p><ul><li>使用 Docker 文件构建 Docker 镜像，</li><li>使用 Cloud-Native Buildpack 从源代码构建 OCI 映像，</li><li>通过使用分层工具将 JAR 的各个部分拆分为不同的层，在运行时优化映像。</li></ul><h2 id=示例代码>示例代码</h2><p>本文附有 <a href=https://github.com/thombergs/code-examples/tree/master/spring-boot/spring-boot-docker target=_blank>GitHub</a> 上的工作代码示例。</p><h2 id=容器术语>容器术语</h2><p>我们将从整篇文章中使用的容器术语开始：</p><ul><li><strong>Container image</strong>: 具有特定格式的文件。我们通过运行构建工具将应用程序转换为容器映像。</li><li><strong>Container</strong>: 容器镜像的运行时实例。</li><li><strong>Container engine</strong>: t 负责运行 Container 的守护进程。</li><li><strong>Container host</strong>: 容器引擎运行的主机。</li><li><strong>Container registry</strong>: 用于发布和分发容器映像的共享位置。</li><li><strong>OCI Standard</strong>: 开放容器倡议 (OCI) 是在 Linux 基金会下形成的一个轻量级、开放的治理结构。 OCI 镜像规范定义了容器镜像格式和运行时的行业标准，以确保所有容器引擎都可以运行任何构建工具生成的容器镜像。</li></ul><p>为了容器化应用程序，我们将应用程序封装在容器映像中，并将该映像发布到共享注册表。容器运行时从注册表中提取该映像，解压该映像，然后在其中运行应用程序。</p><p>Spring Boot 2.3 版本提供了用于构建 OCI 映像的插件。</p><p>Docker 恰好是最常用的容器实现，并且我们在示例中使用 Docker，因此本文中所有后续对容器的引用都将指 Docker。</p><h2 id=以传统方式构建容器镜像>以传统方式构建容器镜像</h2><p>通过向 Docker 文件添加一些指令，可以非常轻松地创建 Spring Boot 应用程序的 Docker 镜像。</p><p>我们首先构建一个可执行 JAR，并作为 Docker 文件指令的一部分，在应用必要的自定义后将可执行 JAR 复制到基本 JRE 映像上。</p><p>让我们从 Spring Initializr 创建带有 <code>web</code> 、 <code>lombok</code> 和 <code>actuator</code> 依赖项的 Spring Boot 应用程序。我们还添加了一个休息控制器来使用 <code>GET</code> 方法公开 API。</p><h3 id=创建-docker-文件>创建 Docker 文件</h3><p>接下来，我们通过添加 <code>Dockerfile</code> 来容器化该应用程序：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span> <span style=color:#e6db74>adoptopenjdk:11-jre-hotspot</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ARG</span> JAR_FILE<span style=color:#f92672>=</span>target/*.jar<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> <span style=color:#e6db74>${</span>JAR_FILE<span style=color:#e6db74>}</span> application.jar<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>EXPOSE</span> <span style=color:#e6db74>8080</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;java&#34;</span>,<span style=color:#e6db74>&#34;-jar&#34;</span>,<span style=color:#e6db74>&#34;/application.jar&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>我们的 Docker 文件包含来自 <code>adoptopenjdk</code> 的基本映像，我们在该映像上复制 JAR 文件，然后公开将侦听请求的端口 <code>8080</code> 。</p><h3 id=构建应用程序>构建应用程序</h3><p>我们首先使用 Maven 或 Gradle 构建应用程序。我们在这里使用 Maven：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mvn clean package
</span></span></code></pre></div><p>这将创建应用程序的可执行 JAR。我们需要将这个可执行 JAR 转换为 Docker 映像，以便在 Docker 引擎中运行。</p><h3 id=构建容器镜像>构建容器镜像</h3><p>接下来，我们通过从包含之前创建的 Docker 文件的根项目目录运行 <code>docker build</code> 命令，将此可执行 JAR 放入 Docker 映像中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker build  -t usersignup:v1 .
</span></span></code></pre></div><p>我们可以看到使用以下命令列出的图像：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>docker images
</span></span></code></pre></div><p>上述命令的输出包括我们的映像 <code>usersignup</code> 以及 Docker 文件中指定的基础映像 <code>adoptopenjdk</code> 。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>REPOSITORY          TAG                 SIZE
</span></span><span style=display:flex><span>usersignup          v1                  249MB
</span></span><span style=display:flex><span>adoptopenjdk        11-jre-hotspot      229MB
</span></span></code></pre></div><h3 id=查看容器镜像内的层>查看容器镜像内的层</h3><p>让我们看看图像内的图层堆栈。我们将使用 <a href=https://github.com/wagoodman/dive target=_blank>dive tool</a> 来查看这些图层：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>dive usersignup:v1
</span></span></code></pre></div><p>以下是运行 Dive 命令的部分输出：</p><p><img src=/images/spring-boot-docker-01.webp alt="dive screenshot"></p><p>正如我们所看到的，应用层构成了图像大小的重要组成部分。作为优化的一部分，我们的目标是在以下部分中减小该层的大小。</p><h2 id=使用-buildpack-构建容器镜像>使用 Buildpack 构建容器镜像</h2><p>Buildpacks 是各种平台即服务 (PAAS) 产品使用的通用术语，用于从源代码构建容器映像。它由 Heroku 于 2011 年发起，此后已被 Cloud Foundry、Google App Engine、Gitlab、Knative 等采用。</p><p><img src=/images/spring-boot-docker-02.webp alt="dive screenshot"></p><h3 id=云原生-buildpack-的优势>云原生 Buildpack 的优势</h3><p>使用 Buildpack 构建映像的一个主要优点是，可以在集中位置（构建器）管理对映像配置的更改，并将其传播到使用该构建器的所有应用程序。</p><p>Buildpack 与平台紧密耦合。云原生 Buildpack 通过支持 OCI 映像格式实现跨平台标准化，确保映像可以由 Docker 引擎运行。</p><h3 id=使用-spring-boot-插件>使用 Spring Boot 插件</h3><p>Spring Boot 插件使用 Buildpack 从源代码创建 OCI 映像。映像是使用 <code>bootBuildImage</code> 任务 (Gradle) 或 <code>spring-boot:build-image</code> 目标 (Maven) 和本地 Docker 安装构建的。</p><p>我们可以通过在 <code>image tag</code> 中指定名称来自定义推送到 Docker 注册表所需的镜像名称：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;plugin&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.boot<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;artifactId&gt;</span>spring-boot-maven-plugin<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;configuration&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;image&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;name&gt;</span>docker.io/pratikdas/${project.artifactId}:v1<span style=color:#f92672>&lt;/name&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/image&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/configuration&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/plugin&gt;</span>
</span></span></code></pre></div><p>让我们使用 Maven 运行 <code>build-image</code> 目标来构建应用程序并创建容器映像。我们现在没有使用任何 Docker 文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mvn spring-boot:build-image
</span></span></code></pre></div><p>运行此命令将产生类似于以下内容的输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>INFO<span style=color:#f92672>]</span> --- spring-boot-maven-plugin:2.3.3.RELEASE:build-image <span style=color:#f92672>(</span>default-cli<span style=color:#f92672>)</span> @ usersignup ---
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>INFO<span style=color:#f92672>]</span> Building image <span style=color:#e6db74>&#39;docker.io/pratikdas/usersignup:v1&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>INFO<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>INFO<span style=color:#f92672>]</span>  &gt; Pulling builder image <span style=color:#e6db74>&#39;gcr.io/paketo-buildpacks/builder:base-platform-api-0.3&#39;</span> 0%
</span></span><span style=display:flex><span>.
</span></span><span style=display:flex><span>.
</span></span><span style=display:flex><span>.. <span style=color:#f92672>[</span>creator<span style=color:#f92672>]</span>     Adding label <span style=color:#e6db74>&#39;org.springframework.boot.version&#39;</span>
</span></span><span style=display:flex><span>.. <span style=color:#f92672>[</span>creator<span style=color:#f92672>]</span>     *** Images <span style=color:#f92672>(</span>c311fe74ec73<span style=color:#f92672>)</span>:
</span></span><span style=display:flex><span>.. <span style=color:#f92672>[</span>creator<span style=color:#f92672>]</span>           docker.io/pratikdas/usersignup:v1
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>INFO<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>INFO<span style=color:#f92672>]</span> Successfully built image <span style=color:#e6db74>&#39;docker.io/pratikdas/usersignup:v1&#39;</span>
</span></span></code></pre></div><p>从输出中，我们可以看到 <code>paketo Cloud-Native buildpack</code> 被用来构建可运行的 OCI 映像。正如我们之前所做的那样，我们可以通过运行以下命令来查看列为 Docker 映像的映像：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker images
</span></span></code></pre></div><p>输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>REPOSITORY                             SIZE
</span></span><span style=display:flex><span>paketobuildpacks/run                  84.3MB
</span></span><span style=display:flex><span>gcr.io/paketo-buildpacks/builder      652MB
</span></span><span style=display:flex><span>pratikdas/usersignup                  257MB
</span></span></code></pre></div><h2 id=使用-jib-构建容器镜像>使用 Jib 构建容器镜像</h2><p>Jib 是 Google 的一个镜像构建器插件，提供了一种从源代码构建容器镜像的替代方法。</p><p>我们在 pom.xml 中配置 <code>jib-maven-plugin</code> ：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span>      <span style=color:#f92672>&lt;plugin&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;groupId&gt;</span>com.google.cloud.tools<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;artifactId&gt;</span>jib-maven-plugin<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;version&gt;</span>2.5.2<span style=color:#f92672>&lt;/version&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;/plugin&gt;</span>
</span></span></code></pre></div><p>接下来，我们使用 Maven 命令触发 Jib 插件来构建应用程序并创建容器映像。和以前一样，我们在这里没有使用任何 Docker 文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mvn compile jib:build -Dimage<span style=color:#f92672>=</span>&lt;docker registry name&gt;/usersignup:v1
</span></span></code></pre></div><p>运行上述 Maven 命令后，我们得到以下输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>INFO<span style=color:#f92672>]</span> Containerizing application to pratikdas/usersignup:v1...
</span></span><span style=display:flex><span>.
</span></span><span style=display:flex><span>.
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>INFO<span style=color:#f92672>]</span> Container entrypoint set to <span style=color:#f92672>[</span>java, -cp, /app/resources://app/classes://app/libs/*, io.pratik.users.UsersignupApplication<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>INFO<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>INFO<span style=color:#f92672>]</span> Built and pushed image as pratikdas/usersignup:v1
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>INFO<span style=color:#f92672>]</span> Executing tasks:
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>INFO<span style=color:#f92672>]</span> <span style=color:#f92672>[==============================]</span> 100.0% complete
</span></span></code></pre></div><p>输出显示容器映像已构建并推送到注册表。</p><h2 id=构建优化镜像的动机和技术>构建优化镜像的动机和技术</h2><p>我们优化的主要动机有两个：</p><ul><li>性能：在容器编排系统中，容器镜像从镜像仓库拉取到运行容器引擎的主机上。这个过程称为调度。从注册表中提取大型映像会导致容器编排系统中的调度时间较长以及 CI 管道中的构建时间较长。</li><li>安全性：大尺寸图像也有更大的漏洞表面积。</li></ul><p>Docker 镜像由一堆层组成，每个层代表 Dockerfile 中的一条指令。每一层都是底层变化的增量。当我们从注册中心拉取 Docker 镜像时，它是被分层拉取并缓存在主机中的。</p><p>Spring Boot 使用“fat JAR”作为其默认打包格式。当我们检查 fat JAR 时，我们可以看到该应用程序只占整个 JAR 的很小一部分。这是变化最频繁的部分。其余部分由 Spring 框架依赖项组成。</p><p>优化公式的核心是将应用程序与 Spring 框架依赖项隔离到一个单独的层中。</p><p>构成 fat JAR 大部分的依赖项层仅下载一次并缓存在主机系统中。</p><p>在应用程序更新和容器调度期间，仅拉取应用程序的薄层，如下图所示：</p><p><img src=/images/spring-boot-docker-03.webp alt="dive screenshot"></p><p>让我们在接下来的部分中了解如何为 Spring Boot 应用程序构建这些优化的映像。</p><h2 id=使用-buildpack-为-spring-boot-应用程序构建优化的容器映像>使用 Buildpack 为 Spring Boot 应用程序构建优化的容器映像</h2><p>Spring Boot 2.3 通过将 fat JAR 的各个部分提取到单独的层中来支持分层。分层功能默认关闭，需要使用 Spring Boot Maven 插件显式启用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;plugin&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.boot<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;artifactId&gt;</span>spring-boot-maven-plugin<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;configuration&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;layers&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;enabled&gt;</span>true<span style=color:#f92672>&lt;/enabled&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/layers&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/configuration&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/plugin&gt;</span>
</span></span></code></pre></div><p>我们将使用此配置首先使用 Buildpack 生成容器映像，然后在以下部分中使用 Docker 生成容器映像。</p><p>让我们运行 Maven <code>build-image</code> 目标来创建容器映像：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mvn spring-boot:build-image
</span></span></code></pre></div><p>如果我们运行 Dive 来查看生成图像中的各层，我们可以看到应用程序层（以红色圈出）在千字节范围内比我们使用 fat JAR 格式获得的要小得多：</p><p><img src=/images/spring-boot-docker-04.webp alt="dive screenshot"></p><h2 id=使用-docker-为-spring-boot-应用程序构建优化的容器映像>使用 Docker 为 Spring Boot 应用程序构建优化的容器映像</h2><p>我们还可以使用 Docker 文件创建分层的 JAR Docker 镜像，而不是使用 Maven 或 Gradle 插件。</p><p>当我们使用 Docker 时，我们需要执行两个额外的步骤来提取层并将其复制到最终映像中。</p><p>使用 Maven 构建并启用分层功能后，生成的 JAR 内容将如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>META-INF/
</span></span><span style=display:flex><span>.
</span></span><span style=display:flex><span>BOOT-INF/lib/
</span></span><span style=display:flex><span>.
</span></span><span style=display:flex><span>BOOT-INF/lib/spring-boot-jarmode-layertools-2.3.3.RELEASE.jar
</span></span><span style=display:flex><span>BOOT-INF/classpath.idx
</span></span><span style=display:flex><span>BOOT-INF/layers.idx
</span></span></code></pre></div><p>输出显示一个名为 <code>spring-boot-jarmode-layertools</code> 的附加 JAR 和一个 <code>layersfle.idx</code> 文件。分层功能由这个附加 JAR 提供，如下一节所述。</p><h3 id=取不同层中的依赖关系>取不同层中的依赖关系</h3><p>要查看并从分层 JAR 中提取层，我们使用系统属性 <code>-Djarmode=layertools</code> 来启动 <code>spring-boot-jarmode-layertools</code> JAR 而不是应用程序：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>java -Djarmode<span style=color:#f92672>=</span>layertools -jar target/usersignup-0.0.1-SNAPSHOT.jar
</span></span></code></pre></div><p>运行此命令会生成包含可用命令选项的输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Usage:
</span></span><span style=display:flex><span>  java -Djarmode<span style=color:#f92672>=</span>layertools -jar usersignup-0.0.1-SNAPSHOT.jar
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Available commands:
</span></span><span style=display:flex><span>  list     List layers from the jar that can be extracted
</span></span><span style=display:flex><span>  extract  Extracts layers from the jar <span style=color:#66d9ef>for</span> image creation
</span></span><span style=display:flex><span>  help     Help about any command
</span></span></code></pre></div><p>输出显示命令 <code>list</code> 、 <code>extract</code> 和 <code>help</code> ，其中 <code>help</code> 是默认命令。让我们使用 <code>list</code> 选项运行命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>java -Djarmode<span style=color:#f92672>=</span>layertools -jar target/usersignup-0.0.1-SNAPSHOT.jar list
</span></span><span style=display:flex><span>dependencies
</span></span><span style=display:flex><span>spring-boot-loader
</span></span><span style=display:flex><span>snapshot-dependencies
</span></span><span style=display:flex><span>application
</span></span></code></pre></div><p>我们可以看到可以作为层添加的依赖项列表。</p><p>默认层是：</p><table><thead><tr><th style=text-align:left>图层名称</th><th style=text-align:left>内容</th></tr></thead><tbody><tr><td style=text-align:left><code>dependencies</code></td><td style=text-align:left>版本不包含 SNAPSHOT 的任何依赖项</td></tr><tr><td style=text-align:left><code>spring-boot-loader</code></td><td style=text-align:left>JAR 加载器类</td></tr><tr><td style=text-align:left><code>snapshot-dependencies</code></td><td style=text-align:left>版本包含 SNAPSHOT 的任何依赖项</td></tr><tr><td style=text-align:left><code>application</code></td><td style=text-align:left>应用程序类和资源</td></tr></tbody></table><p>这些层按照应添加到 Docker 映像的顺序在 <code>layers.idx</code> 文件中定义。这些层在第一次拉取后会缓存在主机中，因为它们不会更改。仅将更新的应用程序层下载到主机，由于大小减小，速度更快。</p><h3 id=使用在单独层中提取的依赖项构建图像>使用在单独层中提取的依赖项构建图像</h3><p>我们将使用称为多阶段构建的方法分两个阶段构建最终图像。在第一阶段，我们将提取依赖项，在第二阶段，我们将提取的依赖项复制到最终映像。</p><p>让我们修改 Docker 文件以进行多阶段构建：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#75715e># the first stage of our build will extract the layers</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span> <span style=color:#e6db74>adoptopenjdk:14-jre-hotspot</span> <span style=color:#66d9ef>as</span> <span style=color:#e6db74>builder</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span> <span style=color:#e6db74>application</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ARG</span> JAR_FILE<span style=color:#f92672>=</span>target/*.jar<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> <span style=color:#e6db74>${</span>JAR_FILE<span style=color:#e6db74>}</span> application.jar<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> java -Djarmode<span style=color:#f92672>=</span>layertools -jar application.jar extract<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># the second stage of our build will copy the extracted layers</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span> <span style=color:#e6db74>adoptopenjdk:14-jre-hotspot</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span> <span style=color:#e6db74>application</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>builder application/dependencies/ ./<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>builder application/spring-boot-loader/ ./<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>builder application/snapshot-dependencies/ ./<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>builder application/application/ ./<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;java&#34;</span>, <span style=color:#e6db74>&#34;org.springframework.boot.loader.JarLauncher&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>我们将此配置保存在单独的文件中 - <code>Dockerfile2</code> 。</p><p>我们使用以下命令构建 Docker 镜像：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>docker build -f Dockerfile2 -t usersignup:v1 .
</span></span></code></pre></div><p>运行此命令后，我们得到以下输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Sending build context to Docker daemon  20.41MB
</span></span><span style=display:flex><span>Step 1/12 : FROM adoptopenjdk:14-jre-hotspot as builder
</span></span><span style=display:flex><span>14-jre-hotspot: Pulling from library/adoptopenjdk
</span></span><span style=display:flex><span>.
</span></span><span style=display:flex><span>.
</span></span><span style=display:flex><span>Successfully built a9ebf6970841
</span></span><span style=display:flex><span>Successfully tagged userssignup:v1
</span></span></code></pre></div><p>我们可以看到 Docker 镜像是使用镜像 ID 创建的，然后被标记的。</p><p>最后，我们像以前一样运行 Dive 命令来检查生成的 Docker 镜像内的层。我们可以指定图像 ID 或标签作为 Dive 命令的输入：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>dive userssignup:v1
</span></span></code></pre></div><p>正如我们在输出中看到的，包含应用程序的层现在只有 11 kB，依赖项缓存在单独的层中。</p><p><img src=/images/spring-boot-docker-05.webp alt="dive screenshot"></p><h3 id=提取不同层中的内部依赖关系>提取不同层中的内部依赖关系</h3><p>我们可以通过在单独的层中提取任何自定义依赖项来进一步减小应用程序层的大小，而不是通过在名为 <code>layers.idx</code> 的 <code>yml</code> 类似文件中声明它们来将它们与应用程序一起打包：</p><pre tabindex=0><code class=language-layers.idx data-lang=layers.idx>- &#34;dependencies&#34;:
  - &#34;BOOT-INF/lib/&#34;
- &#34;spring-boot-loader&#34;:
  - &#34;org/&#34;
- &#34;snapshot-dependencies&#34;:
- &#34;custom-dependencies&#34;:
  - &#34;io/myorg/&#34;
- &#34;application&#34;:
  - &#34;BOOT-INF/classes/&#34;
  - &#34;BOOT-INF/classpath.idx&#34;
  - &#34;BOOT-INF/layers.idx&#34;
  - &#34;META-INF/&#34;
</code></pre><p>在此文件中 - <code>layers.idx</code> 我们添加了一个名为 <code>io.myorg</code> 的自定义依赖项，其中包含从共享存储库中提取的组织依赖项。</p><h2 id=结论>结论</h2><p>在本文中，我们研究了使用云原生 Buildpack 直接从源代码创建容器映像。这是使用 Docker 构建容器映像的传统方式的替代方案，首先构建 fat 可执行 JAR，然后通过在 Dockerfile 中指定指令将其打包到容器映像中。</p><p>我们还考虑通过启用分层功能来优化我们的容器，该功能提取缓存在主机中的单独层中的依赖项，并在容器运行时引擎的调度期间下载应用程序的薄层。</p><p>文章中使用的所有源码可以参考<a href=https://github.com/thombergs/code-examples/tree/master/spring-boot/spring-boot-docker target=_blank>Github</a>上的。</p><h2 id=命令参考>命令参考</h2><p>以下是我们在本文中使用的命令摘要，以供快速参考。</p><p>清洁我们的环境：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>docker system prune -a
</span></span></code></pre></div><p>使用 Docker 文件构建容器镜像：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>docker build -f &lt;Docker file name&gt; -t &lt;tag&gt; .
</span></span></code></pre></div><p>从源代码构建容器镜像（没有 Dockerfile）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>mvn spring-boot:build-image
</span></span></code></pre></div><p>查看依赖关系层。在构建应用程序 JAR 之前，确保在 spring-boot-maven-plugin 中启用分层功能：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>java -Djarmode=layertools -jar application.jar list
</span></span></code></pre></div><p>提取依赖层。在构建应用程序 JAR 之前，确保在 spring-boot-maven-plugin 中启用分层功能：</p><pre tabindex=0><code> java -Djarmode=layertools -jar application.jar extract
</code></pre><p>查看容器镜像列表</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>docker images
</span></span></code></pre></div><p>查看容器镜像内的层（确保已安装 dive tool 工具）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>dive &lt;image ID or image tag&gt;
</span></span></code></pre></div><p>原文链接：<a href=https://reflectoring.io/spring-boot-docker/ target=_blank>https://reflectoring.io/spring-boot-docker/</a></p></div></article></main><footer class=post__footer><div class=post-related><h3>相关文章</h3><ul class=post-related-list><li class=post-related-item><a href=/posts/2023/08/16/spring-transaction-management-transactional-in-depth/ target=_blank title=[译]深入了解Spring事务管理：@Transactional>[译]深入了解Spring事务管理：@Transactional</a></li><li class=post-related-item><a href=/posts/2023/07/26/spring-boot-exception-handling/ target=_blank title="[译]Spring Boot异常处理完整指南">[译]Spring Boot异常处理完整指南</a></li><li class=post-related-item><a href=/posts/2023/07/26/spring-boot-null-safety-annotations/ target=_blank title="[译]使用 Spring 的 Null-Safety 注解保护您的代码免受 NullPointerExceptions 的影响">[译]使用 Spring 的 Null-Safety 注解保护您的代码免受 NullPointerExceptions 的影响</a></li><li class=post-related-item><a href=/posts/2023/07/26/spring-boot-info-endpoint/ target=_blank title="[译]使用Spring Boot Actuator公开有用的信息端点">[译]使用Spring Boot Actuator公开有用的信息端点</a></li><li class=post-related-item><a href=/posts/2023/05/22/docker-continuous-integration/ target=_blank title="[译]Build Robust Continuous Integration With Docker and Friends">[译]Build Robust Continuous Integration With Docker and Friends</a></li><li class=post-related-item><a href=/posts/2023/01/25/notes-about-deploy-services-in-vps/ target=_blank title=我的VPS服务部署记录>我的VPS服务部署记录</a></li></ul></div></footer><footer class=post__footer><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 000-6 3 3 0 000 6"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/spring-boot/ rel=tag>spring-boot</a></li><li class=tags__item><a class="tags__link btn" href=/tags/docker/ rel=tag>docker</a></li></ul></div></footer></footer><nav class="pagination flex"><div class="pagination__item pagination__item--prev"><a class=pagination__link href=/posts/2023/08/15/spring-security-oauth2-history/ rel=prev><p class=pagination__title>«&#8201;上一篇: Spring Security和OAuth2发展过程</p></a></div><div class="pagination__item pagination__item--next"><a class=pagination__link href=/posts/2023/08/16/spring-transaction-management-transactional-in-depth/ rel=next><p class=pagination__title>&#8201;» 下一篇: [译]深入了解Spring事务管理：@Transactional</p></a></div></nav><div class="authorbox clearfix"><figure class=authorbox__avatar><img alt="ChenSoul avatar" src=/avatar.jpg class=avatar height=60 width=60 loading=lazy></figure><div class=authorbox__header><span class=authorbox__name>关于 ChenSoul</span></div><div class=authorbox__description>一个来自中国武汉的开发者，主要撰写软件开发和开源方面的文章。浏览我的<a href=%28/posts%29>博客文章</a>，订阅我的 <a href=/index.xml>RSS</a> 源，或了解更多<a href=/about/>关于我</a>的信息。</div></div><p><h3>欢迎留言！</h3></p><div id=remark42></div><script>var remark_config={host:"https://comment.chensoul.cc",site_id:"remark",components:["embed"],url:"https://blog.chensoul.cc/posts/2023/08/16/spring-boot-docker/",locale:"zh"};!function(e,t){for(s=0;s<e.length;s++){var s,n=t.createElement("script"),o=".js",i=t.head||t.body;"noModule"in n?(n.type="module",o=".mjs"):n.async=!0,n.defer=!0,n.src=remark_config.host+"/web/"+e[s]+o,i.appendChild(n)}}(remark_config.components||["embed"],document)</script></div><aside class="sidebar sidebar--right"><div class="post__toc toc"><div class=toc__title>目录</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#示例代码>示例代码</a></li><li><a href=#容器术语>容器术语</a></li><li><a href=#以传统方式构建容器镜像>以传统方式构建容器镜像</a><ul><li><a href=#创建-docker-文件>创建 Docker 文件</a></li><li><a href=#构建应用程序>构建应用程序</a></li><li><a href=#构建容器镜像>构建容器镜像</a></li><li><a href=#查看容器镜像内的层>查看容器镜像内的层</a></li></ul></li><li><a href=#使用-buildpack-构建容器镜像>使用 Buildpack 构建容器镜像</a><ul><li><a href=#云原生-buildpack-的优势>云原生 Buildpack 的优势</a></li><li><a href=#使用-spring-boot-插件>使用 Spring Boot 插件</a></li></ul></li><li><a href=#使用-jib-构建容器镜像>使用 Jib 构建容器镜像</a></li><li><a href=#构建优化镜像的动机和技术>构建优化镜像的动机和技术</a></li><li><a href=#使用-buildpack-为-spring-boot-应用程序构建优化的容器映像>使用 Buildpack 为 Spring Boot 应用程序构建优化的容器映像</a></li><li><a href=#使用-docker-为-spring-boot-应用程序构建优化的容器映像>使用 Docker 为 Spring Boot 应用程序构建优化的容器映像</a><ul><li><a href=#取不同层中的依赖关系>取不同层中的依赖关系</a></li><li><a href=#使用在单独层中提取的依赖项构建图像>使用在单独层中提取的依赖项构建图像</a></li><li><a href=#提取不同层中的内部依赖关系>提取不同层中的内部依赖关系</a></li></ul></li><li><a href=#结论>结论</a></li><li><a href=#命令参考>命令参考</a></li></ul></nav></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__links><a class=footer__link href=/>首页</a> | <a class=footer__link href=/categories/>分类</a> | <a class=footer__link href=/about/>关于</a> | <a class=footer__link href=/index.xml>RSS</a></div><div class=footer__copyright>&copy; 2025 ChenSoul.
<span class=footer__copyright-credits>基于 <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> 引擎和 <a href=https://github.com/chensoul/rose-hugo/ rel="nofollow noopener" target=_blank>Rose Hugo</a> 主题</span></div></div><style>.scroll-up a{display:block;height:3.125rem;width:3.125rem;text-align:center;line-height:2.7;border-radius:50px;font-size:1.125rem;color:#fff;opacity:1;transition:all .3s ease 0s;box-shadow:0 0 10px rgb(0 0 0/.2)}.scroll-up a{background:#ee591f}.scroll-up{position:fixed;display:none;bottom:50px;z-index:999}.scroll-up.right{right:60px}</style><div class="scroll-up custom right" style=display:block><a href=#top id=top-link accesskey=g><i class="fa fa-arrow-up"></i></a></div><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script defer src=https://umami.chensoul.cc/random-string.js data-website-id=1e07d36d-bec3-4ba6-9459-876b1ac3bbe7></script></footer></div><script>"use strict";(function(t){var i=t.querySelector(".menu__btn"),o=t.querySelector(".menu__list");function a(){o.classList.toggle("menu__list--active"),o.classList.toggle("menu__list--transition"),this.classList.toggle("menu__btn--active"),this.setAttribute("aria-expanded",this.getAttribute("aria-expanded")==="true"?"false":"true")}function r(){this.classList.remove("menu__list--transition")}i&&o&&(i.addEventListener("click",a,!1),o.addEventListener("transitionend",r,!1))})(document,window)</script></body></html>