<!doctype html><html lang=en-US prefix="og: http://ogp.me/ns#"><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="您可以使用本指南来简单实用地了解 Spring 使用 @Transactional 注释进行事务管理的工作原理。
唯一的先决条件？您需要对 ACID 有一个粗略的了解，即什么是数据库事务以及为什么使用它们。此外，这里不讨论分布式事务或反应式事务，但就 Spring 而言，一般原则仍然适用。"><title>[译]深入了解Spring事务管理：@Transactional | ChenSoul</title><link rel=canonical href=https://blog.chensoul.cc/posts/2023/08/16/spring-transaction-management-transactional-in-depth/><link rel=preconnect href=https://fonts.font.im><link rel=preconnect href=https://fonts.loli.net crossorigin><link href="https://fonts.loli.net/css2?family=Roboto+Slab:wght@400;500;700&display=swap" rel=stylesheet><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.chensoul.cc/images/favicon.webp"><meta name=twitter:title content="[译]深入了解Spring事务管理：@Transactional"><meta name=twitter:description content="您可以使用本指南来简单实用地了解 Spring 使用 @Transactional 注释进行事务管理的工作原理。
唯一的先决条件？您需要对 ACID 有一个粗略的了解，即什么是数据库事务以及为什么使用它们。此外，这里不讨论分布式事务或反应式事务，但就 Spring 而言，一般原则仍然适用。"><meta name=twitter:creator content="@ichensoul"><meta property="og:locale" content="en_US"><meta property="og:site_name" content="chensoul"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/08/16/spring-transaction-management-transactional-in-depth/"><meta property="og:site_name" content="ChenSoul"><meta property="og:title" content="[译]深入了解Spring事务管理：@Transactional"><meta property="og:description" content="您可以使用本指南来简单实用地了解 Spring 使用 @Transactional 注释进行事务管理的工作原理。
唯一的先决条件？您需要对 ACID 有一个粗略的了解，即什么是数据库事务以及为什么使用它们。此外，这里不讨论分布式事务或反应式事务，但就 Spring 而言，一般原则仍然适用。"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-16T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-16T00:00:00+00:00"><meta property="article:tag" content="Spring-Boot"><meta property="og:image" content="https://blog.chensoul.cc/images/favicon.webp"><meta itemprop=name content="[译]深入了解Spring事务管理：@Transactional"><meta itemprop=description content="您可以使用本指南来简单实用地了解 Spring 使用 @Transactional 注释进行事务管理的工作原理。
唯一的先决条件？您需要对 ACID 有一个粗略的了解，即什么是数据库事务以及为什么使用它们。此外，这里不讨论分布式事务或反应式事务，但就 Spring 而言，一般原则仍然适用。"><meta itemprop=datePublished content="2023-08-16T00:00:00+00:00"><meta itemprop=dateModified content="2023-08-16T00:00:00+00:00"><meta itemprop=wordCount content="1292"><meta itemprop=image content="https://blog.chensoul.cc/images/favicon.webp"><meta itemprop=keywords content="Spring-Boot"><link rel=stylesheet href=https://cdnjs.loli.net/ajax/libs/font-awesome/6.4.0/css/all.min.css media=all><link rel=stylesheet href=/main.min.css type=text/css media=all><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"TechArticle","name":"[译]深入了解Spring事务管理：@Transactional","headline":"[译]深入了解Spring事务管理：@Transactional","inLanguage":"en-US","url":"https://blog.chensoul.cc/posts/2023/08/16/spring-transaction-management-transactional-in-depth/","description":"\u003cp\u003e您可以使用本指南来简单实用地了解 Spring 使用 @Transactional 注释进行事务管理的工作原理。\u003c/p\u003e\n\u003cp\u003e唯一的先决条件？您需要对 ACID 有一个粗略的了解，即什么是数据库事务以及为什么使用它们。此外，这里不讨论分布式事务或反应式事务，但就 Spring 而言，一般原则仍然适用。\u003c/p\u003e","wordCount":"1292","keywords":["spring-boot"],"datePublished":"2023-08-16T00:00:00Z","dateModified":"2023-08-16T00:00:00Z","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/08/16/spring-transaction-management-transactional-in-depth/"},"publisher":{"@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/posts/2023/08/16/spring-transaction-management-transactional-in-depth/"}},{"@context":"https://schema.org","@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/","sameAs":["https://x.com/ichensoul","https://github.com/chensoul","https://www.linkedin.com/in/","https://www.youtube.com/@chensoul","https://t.me/chensouls"]}]}</script><script defer src=https://umami.chensoul.cc/random-string.js data-website-id=4718b57b-c900-4a61-a7af-0fe1fb1d50ce></script></head><body class="home blog post-layout-one-column"><button onclick=topFunction() id=scrollTopBtn title="Go to top">
<i class="fa-solid fa-arrow-up"></i></button><div id=header-top class=header-bar-wrap></div><div id=page class=site><a class="skip-link screen-reader-text" href=#content>Skip to content</a><header id=masthead class="site-header clearfix" role=banner><div class="header-main container clearfix"><div id=logo class="site-branding clearfix"><h1 class=site-title><a href=/ title=ChenSoul rel=home>ChenSoul</a></h1><p class=site-description>Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials</p></div><div class="header-widgets clearfix"><aside id=search-2 class="header-widget widget_search"><form role=search method=get class=search-form onsubmit="return searchSite(event)"><label><span class=screen-reader-text>Search for:</span>
<input type=search class=search-field placeholder="Enter search keyword" name=query id=query title="Enter search keyword">
</label><button type=submit class=search-submit title=Search> <span class=genericon-search></span>
<span class=screen-reader-text>Search</span></button></form></aside></div></div><div id=main-navigation-wrap class=primary-navigation-wrap><nav id=main-navigation class="primary-navigation navigation container clearfix" role=navigation><ul id=menu-home class=main-navigation-menu><li class="menu-item menu-item-type-custom menu-item-object-custom
current-menu-item current_page_item menu-item-home"><a href=/>Home</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/spring-boot/>Spring Boot</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/architecture/>Architecture</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/microservice/>Microservice</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/kubernetes/>Kubernetes</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category
menu-item-has-children"><a href=/tutorials/>Tutorials</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/spring-boot-tutorials/>Spring Boot Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/microservice-tutorials/>Microservice Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/kubernetes-tutorials/>Kubernetes Tutorials</a></li></ul></li><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=https://github.com/chensoul target=_blank>About Me</a></li></ul></nav></div></header><div id=content class="site-content container clearfix"><section id=primary class="content-archive content-area post-content-area"><main id=main class=site-main role=main><article class="post type-post"><div class=post-inner-content><header class=entry-header><h2 class=entry-title><a href=https://blog.chensoul.cc/posts/2023/08/16/spring-transaction-management-transactional-in-depth/ rel=bookmark title=[译]深入了解Spring事务管理：@Transactional>[译]深入了解Spring事务管理：@Transactional</a></h2><div class=entry-meta><span class=meta-date><time class="entry-date published" datetime=2023-08-16T00:00:00>2023-08-16
</time></span><span class=meta-author><span class="author vcard">chensoul</span>
</span><span class="tagcloud post-tags"><i class="fa fa-tags"></i>&nbsp;
<a class="tag-cloud-link widget__link widget__link--taglist" href=/tags/spring-boot/ title=spring-boot>spring-boot</a></span></div></header><div class=entry-content><p>您可以使用本指南来简单实用地了解 Spring 使用 @Transactional 注释进行事务管理的工作原理。</p><p>唯一的先决条件？您需要对 ACID 有一个粗略的了解，即什么是数据库事务以及为什么使用它们。此外，这里不讨论分布式事务或反应式事务，但就 Spring 而言，一般原则仍然适用。</p><h2 id=介绍>介绍</h2><p>在本指南中，您将了解 Spring 核心事务抽象框架的主要支柱（这是一个令人困惑的术语，不是吗？） - 用大量代码示例进行描述：</p><ul><li><code>@Transactional</code> （声明式事务管理）与编程式事务管理。</li><li>物理事务与逻辑事务。</li><li>Spring <code>@Transactional</code> 与 JPA/Hibernate 集成。</li><li>Spring <code>@Transactional</code> 与 Spring Boot 或 Spring MVC 集成。</li><li>回滚、代理、常见陷阱等等。</li></ul><p>与 Spring 官方文档相反，本指南不会直接深入探讨 Spring-first 主题，从而让您感到困惑。</p><p>相反，您将以非常规的方式学习 Spring 事务管理：从头开始，一步一步。这意味着，从普通的老式 JDBC 事务管理开始。</p><p>Why? 为什么？</p><p>因为 Spring 所做的一切都是基于这些 JDBC 基础知识。如果您掌握了这些基础知识，稍后您将可以使用 Spring 的 @Transactional 注释节省大量时间。</p><h2 id=普通-jdbc-事务管理的工作原理>普通 JDBC 事务管理的工作原理</h2><p>如果您在不完全了解 JDBC 事务的情况下考虑跳过本节：请不要这样做。</p><h3 id=如何启动提交或回滚-jdbc-事务>如何启动、提交或回滚 JDBC 事务</h3><p>第一个重要的收获是：无论您使用 Spring 的 @Transactional 注释、普通 Hibernate、jOOQ 还是任何其他数据库库，都没有关系。</p><p>最后，它们都执行相同的操作来打开和关闭（我们称之为“管理”）数据库事务。普通的 JDBC 事务管理代码如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.sql.Connection;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Connection connection <span style=color:#f92672>=</span> dataSource.<span style=color:#a6e22e>getConnection</span>(); <span style=color:#75715e>// (1)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span> (connection) {
</span></span><span style=display:flex><span>    connection.<span style=color:#a6e22e>setAutoCommit</span>(<span style=color:#66d9ef>false</span>); <span style=color:#75715e>// (2)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// execute some SQL statements...</span>
</span></span><span style=display:flex><span>    connection.<span style=color:#a6e22e>commit</span>(); <span style=color:#75715e>// (3)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>catch</span> (SQLException e) {
</span></span><span style=display:flex><span>    connection.<span style=color:#a6e22e>rollback</span>(); <span style=color:#75715e>// (4)</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li>您需要连接到数据库才能启动事务。 DriverManager.getConnection（url，user，password）也可以工作，尽管在大多数企业应用程序中，您将配置一个数据源并从中获取连接。</li><li>这是在 Java 中“启动”数据库事务的唯一方法，尽管这个名字听起来有点不对劲。 setAutoCommit(true) 确保每个 SQL 语句自动包装在自己的事务中，而 setAutoCommit(false) 则相反：您是事务的主人，您需要开始调用 <code>*commit*</code> 标志在连接打开的整个时间内都有效，这意味着您只需调用该方法一次，而不是重复。</li><li>让我们提交我们的交易&mldr;​</li><li>或者，如果出现异常，则回滚我们的更改。</li></ol><p>是的，这 4 行（过于简单化的）是当你使用 @Transactional 注释时 Spring 所做的一切。在下一章中，您将了解其工作原理。但在我们开始之前，您还需要学习一些知识。</p><p>（聪明人的一个快速说明：像 HikariCP 这样的连接池库可能会根据配置自动为您切换自动提交模式。但这是一个高级主题。）</p><h3 id=如何使用-jdbc-隔离级别和保存点>如何使用 JDBC 隔离级别和保存点</h3><p>如果您已经使用过 Spring 的 @Transactional 注释，您可能遇到过类似的情况：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span>TransactionDefinition.<span style=color:#a6e22e>NESTED</span>,
</span></span><span style=display:flex><span>               isolation<span style=color:#f92672>=</span>TransactionDefinition.<span style=color:#a6e22e>ISOLATION_READ_UNCOMMITTED</span>)
</span></span></code></pre></div><p>稍后我们将更详细地介绍嵌套 Spring 事务和隔离级别，但再次了解这些参数都可以归结为以下基本 JDBC 代码会有所帮助：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.sql.Connection;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// isolation=TransactionDefinition.ISOLATION_READ_UNCOMMITTED</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>connection.<span style=color:#a6e22e>setTransactionIsolation</span>(Connection.<span style=color:#a6e22e>TRANSACTION_READ_UNCOMMITTED</span>); <span style=color:#75715e>// (1)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// propagation=TransactionDefinition.NESTED</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Savepoint savePoint <span style=color:#f92672>=</span> connection.<span style=color:#a6e22e>setSavepoint</span>(); <span style=color:#75715e>// (2)</span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>connection.<span style=color:#a6e22e>rollback</span>(savePoint);
</span></span></code></pre></div><ol><li>这就是 Spring 在数据库连接上设置隔离级别的方式。不完全是火箭科学，是吗？</li><li>Spring 中的嵌套事务只是 JDBC/数据库保存点。例如，如果您不知道什么是保存点，请查看本<a href=https://docs.oracle.com/javase/tutorial/jdbc/basics/transactions.html target=_blank>教程</a>。请注意，保存点支持取决于您的 JDBC 驱动程序/数据库。</li></ol><h2 id=spring-或-spring-boot-的事务管理如何工作>Spring 或 Spring Boot 的事务管理如何工作</h2><p>现在您已经对 JDBC 事务有了很好的了解，让我们看看简单的、核心的 Spring 是如何管理事务的。这里的所有内容都一一适用于 Spring Boot 和 Spring MVC，稍后会详细介绍。</p><p>Spring 的事务管理或其（名称相当令人困惑的）事务抽象框架实际上是什么？</p><p>请记住，事务管理简单地说就是：Spring 如何启动、提交或回滚 JDBC 事务？这听起来是不是很熟悉？</p><p>问题是：使用普通 JDBC，您只有一种方法 (setAutocommit(false)) 来管理事务，而 Spring 为您提供了许多不同的、更方便的方法来实现相同的目的。</p><h3 id=如何使用-spring-的程序化事务管理>如何使用 Spring 的程序化事务管理？</h3><p>在 Spring 中定义事务的第一种但很少使用的方法是通过编程方式：通过 TransactionTemplate 或直接通过 PlatformTransactionManager。从代码角度来看，它看起来像这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> TransactionTemplate template;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Long <span style=color:#a6e22e>registerUser</span>(User user) {
</span></span><span style=display:flex><span>        Long id <span style=color:#f92672>=</span> template.<span style=color:#a6e22e>execute</span>(status <span style=color:#f92672>-&gt;</span>  {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// execute some SQL that e.g.</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// inserts the user into the db and returns the autogenerated id</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> id;
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>与普通 JDBC 示例相比：</p><ul><li>您不必自己搞乱打开或关闭数据库连接（try-finally）。相反，您使用事务回调。</li><li>您也不必捕获 SQLException，因为 Spring 会为您将这些异常转换为运行时异常。</li><li>并且您可以更好地融入 Spring 生态系统。 TransactionTemplate 将在内部使用 TransactionManager，它将使用数据源。所有这些都是您必须在 Spring 上下文配置中指定的 bean，但以后不必再担心。</li></ul><p>虽然这算是一个小小的改进，但程序化事务管理并不是 Spring 事务框架的主要功能。相反，这都是关于声明式事务管理的。让我们看看那是什么。</p><h3 id=如何使用-spring-的-xml-声明式事务管理>如何使用 Spring 的 XML 声明式事务管理？</h3><p>过去，当 XML 配置成为 Spring 项目的标准时，您可以直接在 XML 中配置事务。除了一些遗留的企业项目之外，您将不再在野外找到这种方法，因为它已被更简单的 @Transactional 注释所取代。</p><p>我们不会在本指南中详细介绍 XML 配置，但您可以使用此示例作为深入研究的起点 - 如果需要的话（直接取自 Spring 官方文档）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;!-- the transactional advice (what &#39;happens&#39;; see the &lt;aop:advisor/&gt; bean below) --&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;tx:advice</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;txAdvice&#34;</span> <span style=color:#a6e22e>transaction-manager=</span><span style=color:#e6db74>&#34;txManager&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>&lt;!-- the transactional semantics... --&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;tx:attributes&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>&lt;!-- all methods starting with &#39;get&#39; are read-only --&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;tx:method</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;get*&#34;</span> <span style=color:#a6e22e>read-only=</span><span style=color:#e6db74>&#34;true&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>&lt;!-- other methods use the default transaction settings (see below) --&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;tx:method</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;*&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;/tx:attributes&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/tx:advice&gt;</span>
</span></span></code></pre></div><p>您使用上面的 XML 块指定 AOP 建议（面向方面 ​​ 的编程），然后可以将其应用到 UserService bean，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;aop:config&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;aop:pointcut</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;userServiceOperation&#34;</span> <span style=color:#a6e22e>expression=</span><span style=color:#e6db74>&#34;execution(* x.y.service.UserService.*(..))&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;aop:advisor</span> <span style=color:#a6e22e>advice-ref=</span><span style=color:#e6db74>&#34;txAdvice&#34;</span> <span style=color:#a6e22e>pointcut-ref=</span><span style=color:#e6db74>&#34;userServiceOperation&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/aop:config&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;bean</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;userService&#34;</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;x.y.service.UserService&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span></code></pre></div><p>您的 UserService bean 将如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Long <span style=color:#a6e22e>registerUser</span>(User user) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// execute some SQL that e.g.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// inserts the user into the db and retrieves the autogenerated id</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> id;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从 Java 代码的角度来看，这种声明式事务方法看起来比编程方法简单得多。但它会导致大量复杂、冗长的 XML，以及切入点和顾问程序配置。</p><p>因此，这就引出了一个问题：是否有比 XML 更好的声明式事务管理方法？是的，有：@Transactional 注释。</p><h3 id=如何使用-spring-的transactional-注解声明式事务管理>如何使用 Spring 的@Transactional 注解（声明式事务管理）</h3><p>现在让我们看看现代 Spring 事务管理通常是什么样子的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Long <span style=color:#a6e22e>registerUser</span>(User user) {
</span></span><span style=display:flex><span>       <span style=color:#75715e>// execute some SQL that e.g.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// inserts the user into the db and retrieves the autogenerated id</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// userDao.save(user);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> id;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这怎么可能？不再需要 XML 配置，也不需要其他代码。相反，您现在需要做两件事：</p><ul><li>确保您的 Spring 配置带有 @EnableTransactionManagement 注释（在 Spring Boot 中，这将自动为您完成）。</li><li>确保您在 Spring 配置中指定了事务管理器（无论如何您都需要这样做）。</li><li>然后 Spring 足够智能，可以透明地为您处理事务：您用 @Transactional 注释注释的任何 bean 的公共方法都将在数据库事务内执行（注意：存在一些陷阱）。</li></ul><p>因此，要使 @Transactional 注释正常工作，您需要做的就是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Configuration</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@EnableTransactionManagement</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MySpringConfig</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> PlatformTransactionManager <span style=color:#a6e22e>txManager</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> yourTxManager; <span style=color:#75715e>// more on that later</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在，当我说 Spring 透明地为您处理事务时。那个的真实意义是什么？</p><p>借助 JDBC 事务示例中的知识，上面的 @Transactional UserService 代码可以直接转换（简化）为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Long <span style=color:#a6e22e>registerUser</span>(User user) {
</span></span><span style=display:flex><span>        Connection connection <span style=color:#f92672>=</span> dataSource.<span style=color:#a6e22e>getConnection</span>(); <span style=color:#75715e>// (1)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> (connection) {
</span></span><span style=display:flex><span>            connection.<span style=color:#a6e22e>setAutoCommit</span>(<span style=color:#66d9ef>false</span>); <span style=color:#75715e>// (1)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// execute some SQL that e.g.</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// inserts the user into the db and retrieves the autogenerated id</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// userDao.save(user); &lt;(2)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            connection.<span style=color:#a6e22e>commit</span>(); <span style=color:#75715e>//(1)</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (SQLException e) {
</span></span><span style=display:flex><span>            connection.<span style=color:#a6e22e>rollback</span>(); <span style=color:#75715e>// (1)</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li>这只是 JDBC 连接的标准打开和关闭。这就是 Spring 的事务注释自动为您做的事情，而无需您显式地编写它。</li><li>这是您自己的代码，通过 DAO 或类似的东西保存用户。</li></ol><p>这个例子可能看起来有点神奇，但是让我们看看 Spring 如何为您插入这个连接代码。</p><h3 id=cglib-和-jdk-代理---transactional-的幕后黑手>CGlib 和 JDK 代理 - @Transactional 的幕后黑手</h3><p>Spring 无法真正重写您的 Java 类，就像我上面所做的那样，以插入连接代码（除非您使用字节码编织等高级技术，但我们现在忽略它）。</p><p>你的 registerUser() 方法实际上只是调用 userDao.save(user) ，没有办法动态改变它。</p><p>但 Spring 有一个优势。它的核心是一个 IoC 容器。它为您实例化一个 UserService 并确保将该 UserService 自动装配到任何其他需要 UserService 的 bean 中。</p><p>现在，每当您在 bean 上使用 @Transactional 时，Spring 都会使用一个小技巧。它不仅实例化 UserService，而且还实例化该 UserService 的事务代理。</p><p>它在 Cglib 库的帮助下通过一种称为代理通过子类化的方法来实现这一点。还有其他构建代理的方法（例如动态 JDK 代理），但我们暂时就这样吧。</p><p>让我们看看这张图中代理的作用：</p><p><img src=/images/spring-transaction-management-01.webp alt=document1></p><p>从该图中可以看出，代理有一项工作。</p><ul><li>打开和关闭数据库连接/事务。</li><li>然后委托给真正的 UserService，即您编写的那个。</li><li>而其他 bean，例如 UserRestController，永远不会知道它们正在与代理通信，而不是与真实的事物通信。</li></ul><p><strong>快速考试</strong></p><p>看一下下面的源代码，告诉我 Spring 自动构造什么类型的 UserService，假设它带有 @Transactional 标记或具有 @Transactional 方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Configuration</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@EnableTransactionManagement</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyAppConfig</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> UserService <span style=color:#a6e22e>userService</span>() {  <span style=color:#75715e>// (1)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> UserService();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li>正确的。 Spring 在这里为您的 UserService 类构造一个动态 CGLib 代理，它可以为您打开和关闭数据库事务。您或任何其他 bean 甚至不会注意到它不是您的 UserService，而是包装您的 UserService 的代理。</li></ol><h3 id=为什么需要事务管理器如-platformtransactionmanager>为什么需要事务管理器（如 PlatformTransactionManager）？</h3><p>现在只缺少一条关键信息，尽管我们已经提到过几次了。</p><p>您的 UserService 会动态被代理，并且代理会为您管理事务。但处理所有事务状态（打开、提交、关闭）的不是代理本身，而是代理委托给事务管理器。</p><p>Spring 为您提供了 PlatformTransactionManager / TransactionManager 接口，默认情况下，它附带了一些方便的实现。其中之一是数据源事务管理器。</p><p>它所做的正是您迄今为止所做的管理事务的操作，但首先，让我们看看所需的 Spring 配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> DataSource <span style=color:#a6e22e>dataSource</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> MysqlDataSource(); <span style=color:#75715e>// (1)</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> PlatformTransactionManager <span style=color:#a6e22e>txManager</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> DataSourceTransactionManager(dataSource()); <span style=color:#75715e>// (2)</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li>您可以在此处创建特定于数据库或特定于连接池的数据源。本示例使用 MySQL。</li><li>在这里，您创建事务管理器，它需要一个数据源才能管理事务。</li></ol><p>简单如。然后，所有事务管理器都有像“doBegin”（用于启动事务）或“doCommit”这样的方法，它们看起来像这样——直接取自 Spring 的源代码并进行了一些简化：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DataSourceTransactionManager</span> <span style=color:#66d9ef>implements</span> PlatformTransactionManager {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doBegin</span>(Object transaction, TransactionDefinition definition) {
</span></span><span style=display:flex><span>        Connection newCon <span style=color:#f92672>=</span> obtainDataSource().<span style=color:#a6e22e>getConnection</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>        con.<span style=color:#a6e22e>setAutoCommit</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// yes, that&#39;s it!</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doCommit</span>(DefaultTransactionStatus status) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>        Connection connection <span style=color:#f92672>=</span> status.<span style=color:#a6e22e>getTransaction</span>().<span style=color:#a6e22e>getConnectionHolder</span>().<span style=color:#a6e22e>getConnection</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            con.<span style=color:#a6e22e>commit</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (SQLException ex) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> TransactionSystemException(<span style=color:#e6db74>&#34;Could not commit JDBC transaction&#34;</span>, ex);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因此，数据源事务管理器在管理事务时使用与您在 JDBC 部分中看到的完全相同的代码。</p><p>考虑到这一点，让我们从上面扩展我们的图片：</p><p><img src=/images/spring-transaction-management-02.webp alt=document2></p><p>总结一下：</p><ol><li>如果 Spring 检测到 bean 上的 @Transactional 注释，它会创建该 bean 的动态代理。</li><li>代理可以访问事务管理器，并要求它打开和关闭事务/连接。</li><li>事务管理器本身将简单地执行您在普通 Java 部分中所做的操作：管理良好的旧 JDBC 连接。</li></ol><h3 id=物理事务和逻辑事务有什么区别>物理事务和逻辑事务有什么区别？</h3><p>想象一下以下两个事务类。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> InvoiceService invoiceService;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>invoice</span>() {
</span></span><span style=display:flex><span>        invoiceService.<span style=color:#a6e22e>createPdf</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// send invoice as email, etc.</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InvoiceService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>createPdf</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>UserService 有一个事务性 Invoice() 方法。它调用 InvoiceService 上的另一个事务方法 createPdf()。</p><p>现在就数据库事务而言，这实际上应该只是一个数据库事务。 （记住：getConnection().setAutocommit(false).commit()。）Spring 调用此物理事务，尽管一开始这听起来有点令人困惑。</p><p>然而，从 Spring 的角度来看，发生了两个逻辑事务：第一个在 UserService 中，另一个在 InvoiceService 中。 Spring 必须足够聪明，知道这两个 @Transactional 方法应该使用相同的底层物理数据库事务。</p><p>如果对 InvoiceService 进行以下更改，情况会有什么不同？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InvoiceService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>(propagation <span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>REQUIRES_NEW</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>createPdf</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>将传播模式更改为 require_new 是告诉 Spring createPDF() 需要在自己的事务中执行，独立于任何其他已存在的事务。回想一下本指南的纯 Java 部分，您是否看到了将事务“拆分”为两半的方法？我也不。</p><p>这基本上意味着您的代码将打开两个到数据库的（物理）连接/事务。 （再次：getConnection() x2.setAutocommit(false) x2.commit() x2）Spring 现在必须足够智能，两个逻辑事务部分 (invoice()/createPdf()) 现在也映射到两个不同的物理数据库交易。</p><p>所以，总结一下：</p><ul><li>物理事务：是您实际的 JDBC 事务。</li><li>逻辑事务：是（可能嵌套的）@Transactional 注解的（Spring）方法。</li></ul><p>这使我们能够更详细地介绍传播模式。</p><h3 id=transactional-传播级别的用途是什么>@Transactional 传播级别的用途是什么？</h3><p>查看 Spring 源代码时，您会发现可以插入 @Transactional 方法的各种传播级别或模式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  <span style=color:#a6e22e>@Transactional</span>(propagation <span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>REQUIRED</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// or</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Transactional</span>(propagation <span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>REQUIRES_NEW</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>// etc</span>
</span></span></code></pre></div><p>完整列表：</p><ul><li>REQUIRED 必需的</li><li>SUPPORTS 支持</li><li>MANDATORY 强制的</li><li>REQUIRES_NEW REQUIRES_NEW</li><li>NOT_SUPPORTED 不支持</li><li>NEVER 绝不</li><li>NESTED 嵌套</li></ul><p><strong>练习：</strong></p><p>在普通 Java 部分中，我向您展示了 JDBC 在事务方面可以执行的所有操作。花点时间思考一下每个 Spring 传播模式最终对您的数据源（或者更确切地说，您的 JDBC 连接）到底做了什么。</p><p>那就看看下面的回答吧。</p><p><strong>答案：</strong></p><ul><li><strong>Required (default)</strong>：我的方法需要一个事务，要么为我打开一个事务，要么使用现有的事务 → getConnection()。设置自动提交（假）。犯罪（）。</li><li><strong>Supports</strong>：我并不关心事务是否打开，我可以以任何一种方式工作 → 与 JDBC 无关</li><li><strong>Mandatory</strong>：我自己不会打开一个事务，但是如果没有人打开一个事务我会哭 → 与 JDBC 无关</li><li><strong>Require_new</strong>：我想要完全自己的事务 → getConnection()。设置自动提交（假）。犯罪（）。</li><li><strong>Not_Supported</strong>：我真的不喜欢事务，我什至会尝试挂起当前正在运行的事务 → 与 JDBC 无关</li><li>**Never：**如果其他人启动事务我会哭 → 与 JDBC 无关</li><li><strong>Nested：</strong> 听起来很复杂，但我们只是在谈论保存点！ → 连接.setSavepoint()</li></ul><p>正如您所看到的，大多数传播模式实际上与数据库或 JDBC 无关，而更多地与您如何使用 Spring 构建程序以及 Spring 期望事务出现的方式/时间/地点有关。</p><p>看这个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>@Transactional</span>(propagation <span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>MANDATORY</span>)
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>myMethod</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// execute some sql</span>
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这种情况下，每当您调用 UserService 类的 myMethod() 时，Spring 都会期望打开一个事务。它本身不会打开一个方法，相反，如果您在没有预先存在的事务的情况下调用该方法，Spring 将抛出异常。请记住这一点，作为“逻辑事务处理”的附加点。</p><h3 id=transactional-隔离级别有什么用>@Transactional 隔离级别有什么用？</h3><p>此时这几乎是一个棘手的问题，但是当您像这样配置 @Transactional 注释时会发生什么？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(isolation <span style=color:#f92672>=</span> Isolation.<span style=color:#a6e22e>REPEATABLE_READ</span>)
</span></span></code></pre></div><p>是的，它确实会导致这样的结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>connection.<span style=color:#a6e22e>setTransactionIsolation</span>(Connection.<span style=color:#a6e22e>TRANSACTION_REPEATABLE_READ</span>);
</span></span></code></pre></div><p>然而，数据库隔离级别是一个复杂的主题，您应该花一些时间来完全掌握它们。一个好的开始是 Postgres <a href=https://www.postgresql.org/docs/9.5/transaction-iso.html target=_blank>官方文档</a>及其有关隔离级别的部分。</p><p>另请注意，在事务期间切换隔离级别时，您必须确保咨询 JDBC 驱动程序/数据库以了解支持哪些场景，哪些不支持。</p><h3 id=最常见的transactional-陷阱>最常见的@Transactional 陷阱</h3><p>Spring 初学者通常会遇到一个陷阱。看一下下面的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>invoice</span>() {
</span></span><span style=display:flex><span>        createPdf();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// send invoice as email, etc.</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>(propagation <span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>REQUIRES_NEW</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>createPdf</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>您有一个带有事务发票方法的 UserService 类。它调用 createPDF()，这也是事务性的。</p><p>一旦有人调用 invoice()，您期望打开多少实际交易？</p><p>不，答案不是两个，而是一个。为什么？</p><p>让我们回到本指南的代理部分。 Spring 为您创建事务性 UserService 代理，但是一旦您进入 UserService 类并调用其他内部方法，就不再涉及代理。这意味着，您没有新的交易。</p><p>我们用一张图来看看：</p><p><img src=/images/spring-transaction-management-03.webp alt=document3></p><p>您可以使用一些技巧（例如自注入）来绕过此限制。但主要的要点是：始终牢记代理事务边界。</p><h3 id=如何在-spring-boot-或-spring-mvc-中使用-transactional>如何在 Spring Boot 或 Spring MVC 中使用 @Transactional</h3><p>到目前为止，我们只讨论了简单的、核心的 Spring。但是 Spring Boot 呢？还是 Spring Web MVC？他们处理交易的方式有什么不同吗？</p><p>最简洁的答案是不。</p><p>对于任一框架（或者更确切地说：Spring 生态系统中的所有框架），您将始终使用 <code>*@Transactional*</code> 注释，并结合事务管理器和 @EnableTransactionManagement 注释。没有其他办法。</p><p>然而，与 Spring Boot 的唯一区别是，它使用 JDBC 自动配置自动设置 <code>*@EnableTransactionManagement*</code> 注释并为您创建 <code>*PlatformTransactionManager*</code> 。在此处了解有关自动配置的更多信息。</p><h3 id=spring-如何处理回滚以及默认回滚策略>Spring 如何处理回滚（以及默认回滚策略）</h3><p>有关 Spring 回滚的部分将在本指南的下一版本中处理。</p><h2 id=spring-和-jpahibernate-事务管理如何工作>Spring 和 JPA/Hibernate 事务管理如何工作</h2><h3 id=目标同步-spring-的-transactional-和-hibernate--jpa>目标：同步 Spring 的 @Transactional 和 Hibernate / JPA</h3><p>在某些时候，您会希望 Spring 应用程序与另一个数据库库集成，例如 Hibernate（一种流行的 JPA 实现）或 Jooq 等。</p><p>让我们以普通 Hibernate 为例（注意：直接使用 Hibernate，或者通过 JPA 使用 Hibernate 并不重要）。</p><p>将之前的 UserService 重写为 Hibernate 如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> SessionFactory sessionFactory; <span style=color:#f92672>/</span> (1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>registerUser</span>(User user) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Session session <span style=color:#f92672>=</span> sessionFactory.<span style=color:#a6e22e>openSession</span>(); <span style=color:#f92672>/</span> (2)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// lets open up a transaction. remember setAutocommit(false)!</span>
</span></span><span style=display:flex><span>        session.<span style=color:#a6e22e>beginTransaction</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// save == insert our objects</span>
</span></span><span style=display:flex><span>        session.<span style=color:#a6e22e>save</span>(user);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// and commit it</span>
</span></span><span style=display:flex><span>        session.<span style=color:#a6e22e>getTransaction</span>().<span style=color:#a6e22e>commit</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// close the session == our jdbc connection</span>
</span></span><span style=display:flex><span>        session.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li>这是一个普通的、旧的 Hibernate SessionFactory，是所有 Hibernate 查询的入口点。</li><li>使用 Hibernate API 手动管理会话（即：数据库连接）和事务。</li></ol><p>然而，上面的代码有一个很大的问题：</p><ul><li>Hibernate 不会知道 Spring 的 @Transactional 注释。</li><li>Spring 的 @Transactional 对 Hibernate 的事务一无所知。</li></ul><p>但我们实际上希望 Spring 和 Hibernate 能够无缝集成，这意味着它们了解彼此的事务。</p><p>用纯代码表示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> SessionFactory sessionFactory; <span style=color:#f92672>/</span> (1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>registerUser</span>(User user) {
</span></span><span style=display:flex><span>        sessionFactory.<span style=color:#a6e22e>getCurrentSession</span>().<span style=color:#a6e22e>save</span>(user); <span style=color:#f92672>/</span> (2)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li>与之前相同的 SessionFactory</li><li>但不再需要手动状态管理。相反， getCurrentSession() 和 @Transactional 是同步的。</li></ol><p>到那里怎么走？</p><h3 id=使用-hibernatetransactionmanager>使用 HibernateTransactionManager</h3><p>对于这个集成问题有一个非常简单的解决方法：</p><p>您将使用 HibernateTransactionManager（如果使用普通 Hibernate）或 JpaTransactionManager（如果通过 JPA 使用 Hibernate），而不是在 Spring 配置中使用 DataSourcePlatformTransactionManager。</p><p>专门的 HibernateTransactionManager 将确保：</p><ol><li>通过 Hibernate（即 SessionFactory）管理事务。</li><li>足够聪明，允许 Spring 在非 Hibernate 中使用相同的事务，即 @Transactional Spring 代码。</li></ol><p>与往常一样，图片可能更容易理解（但请注意，代理和实际服务之间的流程仅在概念上正确且过于简单）。</p><p><img src=/images/spring-transaction-management-04.webp alt=document4></p><p>简而言之，就是如何集成 Spring 和 Hibernate。</p><p>对于其他集成或更深入的理解，快速查看 Spring 提供的所有可能的 PlatformTransactionManager 实现会有所帮助。</p><h2 id=fin>Fin</h2><p>到目前为止，您应该对事务管理如何与 Spring 框架配合使用以及它如何应用于其他 Spring 库（如 Spring Boot 或 Spring WebMVC）有一个很好的概述。最大的收获应该是，最终使用哪个框架并不重要，这都与 JDBC 基础知识有关。</p><p>如果它们正确（记住：getConnection().setAutocommit(false).commit().），您将更容易理解稍后在复杂的企业应用程序中发生的情况。</p><p>谢谢阅读。</p><h2 id=致谢>致谢</h2><p>感谢 Andreas Eisele 对本指南早期版本的反馈。感谢 Ben Horsfield 提供了急需的 Javascript 片段来增强本指南。</p><p>原文链接：<a href=https://www.marcobehler.com/guides/spring-transaction-management-transactional-in-depth target=_blank>https://www.marcobehler.com/guides/spring-transaction-management-transactional-in-depth</a></p></div><div><div style=font-weight:700>Share this post:</div><a class=social-link-item href="https://twitter.com/intent/tweet?text=%5b%e8%af%91%5d%e6%b7%b1%e5%85%a5%e4%ba%86%e8%a7%a3Spring%e4%ba%8b%e5%8a%a1%e7%ae%a1%e7%90%86%ef%bc%9a%40Transactional https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f08%2f16%2fspring-transaction-management-transactional-in-depth%2f" target=_blank rel="noopener noreferrer" title="Click to share on Twitter"><i class="fa-brands fa-square-twitter fa-2xl" style=color:#55acee></i>
</a><a class=social-link-item href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f08%2f16%2fspring-transaction-management-transactional-in-depth%2f&title=%5b%e8%af%91%5d%e6%b7%b1%e5%85%a5%e4%ba%86%e8%a7%a3Spring%e4%ba%8b%e5%8a%a1%e7%ae%a1%e7%90%86%ef%bc%9a%40Transactional" target=_blank rel="noopener noreferrer" title="Click to share on LinkedIn"><i class="fa-brands fa-linkedin fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://telegram.me/share/url?text=%5b%e8%af%91%5d%e6%b7%b1%e5%85%a5%e4%ba%86%e8%a7%a3Spring%e4%ba%8b%e5%8a%a1%e7%ae%a1%e7%90%86%ef%bc%9a%40Transactional&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f08%2f16%2fspring-transaction-management-transactional-in-depth%2f" target=_blank rel="noopener noreferrer" title="Click to share on telegram"><i class="fa-brands fa-telegram fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f08%2f16%2fspring-transaction-management-transactional-in-depth%2f&title=%5b%e8%af%91%5d%e6%b7%b1%e5%85%a5%e4%ba%86%e8%a7%a3Spring%e4%ba%8b%e5%8a%a1%e7%ae%a1%e7%90%86%ef%bc%9a%40Transactional" target=_blank rel="noopener noreferrer" title="Click to share on reddit"><i class="fa-brands fa-reddit fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f08%2f16%2fspring-transaction-management-transactional-in-depth%2f" target=_blank rel="noopener noreferrer" title="Click to share on facebook"><i class="fa-brands fa-facebook fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://api.whatsapp.com/send?text=%5b%e8%af%91%5d%e6%b7%b1%e5%85%a5%e4%ba%86%e8%a7%a3Spring%e4%ba%8b%e5%8a%a1%e7%ae%a1%e7%90%86%ef%bc%9a%40Transactional%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f08%2f16%2fspring-transaction-management-transactional-in-depth%2f" target=_blank rel="noopener noreferrer" title="Click to share on whatsapp"><i class="fa-brands fa-whatsapp fa-2xl" style=color:#007bb5></i></a></div></div></article><nav class="navigation post-navigation" role=navigation><h2 class=screen-reader-text>Post navigation</h2><div class=nav-links><div class=nav-previous><a href=/posts/2023/08/16/spring-boot-docker/ rel=next><span class=post-title>[译]为 Spring Boot 应用程序创建优化的 Docker 映像</span></a></div><div class=nav-next><a href=/posts/2023/08/15/spring-security-oauth2-history/ rel=prev><span class=post-title>Spring Security和OAuth2发展过程</span></a></div></div></nav><h2>Related content</h2><ul><li><a href=/posts/2023/10/13/new-features-in-spring-boot-3-and-spring-6/>[译]Spring Boot3和Spring6中的新特性</a></li><li><a href=/posts/2023/10/12/spring-security-interview-questions/>[译]Spring Security 面试问题</a></li><li><a href=/posts/2023/09/19/spring-security-tutorial/>[译]Spring Security 与 JWT for REST API</a></li><li><a href=/posts/2023/09/19/spring-security-jwt/>[译]如何使用Spring Security和JWT保护您的REST API</a></li><li><a href=/posts/2023/08/25/global-error-handler-in-a-spring-rest-api/>[译]REST API 的自定义错误消息处理</a></li><li><a href=/posts/2023/08/25/spring-events/>[译]Spring Events</a></li><li><a href=/posts/2023/08/25/spring-security-async-principal-propagation/>[译]使用@Async进行Spring Security上下文传播</a></li><li><a href=/posts/2023/08/25/exception-handling-for-rest-with-spring/>[译]使用Spring进行REST的错误处理</a></li><li><a href=/posts/2023/08/25/spring-async/>[译]如何在Spring中执行@Async</a></li><li><a href=/posts/2023/08/18/how-to-implement-jwt-authentication-in-spring-boot-project/>[译]Spring Boot项目如何实现JWT认证？</a></li></ul></main></section></div><div id=footer class=footer-wrap><footer id=colophon class="site-footer container clearfix" role=contentinfo><div id=footer-text class=site-info><span class=credit-link>Made with 🩷
by <a href=/ target=_blank rel="noopener noreferrer">ChenSoul</a></span></div></footer></div></div><script type=text/javascript src=/main.min.js></script></body></html>