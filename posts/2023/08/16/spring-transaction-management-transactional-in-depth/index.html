<!doctype html><html class=no-js lang=zh-cn><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>[译]深入了解Spring事务管理：@Transactional - Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="[译]深入了解Spring事务管理：@Transactional"><meta property="og:description" content="Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/08/16/spring-transaction-management-transactional-in-depth/"><meta property="og:site_name" content="ChenSoul Blog"><meta property="og:image" content><meta itemprop=name content="[译]深入了解Spring事务管理：@Transactional"><meta itemprop=description content="您可以使用本指南来简单实用地了解 Spring 使用 @Transactional 注释进行事务管理的工作原理。"><meta itemprop=datePublished content="2023-08-16T00:00:00+00:00"><meta itemprop=dateModified content="2023-08-16T00:00:00+00:00"><meta itemprop=wordCount content="1292"><meta itemprop=keywords content="Spring-Boot"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="[译]深入了解Spring事务管理：@Transactional"><meta name=twitter:description content="Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials"><meta name=twitter:image content><link rel=preconnect href=//fonts.loli.net crossorigin><link rel=dns-prefetch href=//fonts.loli.net><link rel=stylesheet href="https://fonts.loli.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class="logo logo--mixed"><a class=logo__link href=/ title="ChenSoul Blog" rel=home><div class="logo__item logo__imagebox"><img class=logo__img src=/logo.svg loading=lazy alt="Site logo" width=60 height=60></div><div class="logo__item logo__text"><div class=logo__title>ChenSoul Blog</div><div class=logo__tagline>Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>菜单</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>首页</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>分类</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>关于</span></a></li><li class=menu__item><a class=menu__link href=/index.xml><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>[译]深入了解Spring事务管理：@Transactional</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 110 28 1 1 0 010-28m0 3a3 3 0 100 22 3 3 0 000-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class=meta__text datetime=2023-08-16>2023-08-16</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/spring-boot/ rel=category>Spring-Boot</a></span></div><div class="meta__item-author meta__item"><svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 16 16"><path d="M8 1c2 0 3.5 2 3.5 4.5S10 9 10 9c3 1 4 2 4 6H2c0-4 1-5 4-6 0 0-1.5-1-1.5-3.5S6 1 8 1"/></svg><span class=meta__text>ChenSoul</span></div></div></header><div class="content post__content clearfix"><p>您可以使用本指南来简单实用地了解 Spring 使用 @Transactional 注释进行事务管理的工作原理。</p><p>唯一的先决条件？您需要对 ACID 有一个粗略的了解，即什么是数据库事务以及为什么使用它们。此外，这里不讨论分布式事务或反应式事务，但就 Spring 而言，一般原则仍然适用。</p><h2 id=介绍>介绍</h2><p>在本指南中，您将了解 Spring 核心事务抽象框架的主要支柱（这是一个令人困惑的术语，不是吗？） - 用大量代码示例进行描述：</p><ul><li><code>@Transactional</code> （声明式事务管理）与编程式事务管理。</li><li>物理事务与逻辑事务。</li><li>Spring <code>@Transactional</code> 与 JPA/Hibernate 集成。</li><li>Spring <code>@Transactional</code> 与 Spring Boot 或 Spring MVC 集成。</li><li>回滚、代理、常见陷阱等等。</li></ul><p>与 Spring 官方文档相反，本指南不会直接深入探讨 Spring-first 主题，从而让您感到困惑。</p><p>相反，您将以非常规的方式学习 Spring 事务管理：从头开始，一步一步。这意味着，从普通的老式 JDBC 事务管理开始。</p><p>Why? 为什么？</p><p>因为 Spring 所做的一切都是基于这些 JDBC 基础知识。如果您掌握了这些基础知识，稍后您将可以使用 Spring 的 @Transactional 注释节省大量时间。</p><h2 id=普通-jdbc-事务管理的工作原理>普通 JDBC 事务管理的工作原理</h2><p>如果您在不完全了解 JDBC 事务的情况下考虑跳过本节：请不要这样做。</p><h3 id=如何启动提交或回滚-jdbc-事务>如何启动、提交或回滚 JDBC 事务</h3><p>第一个重要的收获是：无论您使用 Spring 的 @Transactional 注释、普通 Hibernate、jOOQ 还是任何其他数据库库，都没有关系。</p><p>最后，它们都执行相同的操作来打开和关闭（我们称之为“管理”）数据库事务。普通的 JDBC 事务管理代码如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.sql.Connection;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Connection connection <span style=color:#f92672>=</span> dataSource.<span style=color:#a6e22e>getConnection</span>(); <span style=color:#75715e>// (1)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span> (connection) {
</span></span><span style=display:flex><span>    connection.<span style=color:#a6e22e>setAutoCommit</span>(<span style=color:#66d9ef>false</span>); <span style=color:#75715e>// (2)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// execute some SQL statements...</span>
</span></span><span style=display:flex><span>    connection.<span style=color:#a6e22e>commit</span>(); <span style=color:#75715e>// (3)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>catch</span> (SQLException e) {
</span></span><span style=display:flex><span>    connection.<span style=color:#a6e22e>rollback</span>(); <span style=color:#75715e>// (4)</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li>您需要连接到数据库才能启动事务。 DriverManager.getConnection（url，user，password）也可以工作，尽管在大多数企业应用程序中，您将配置一个数据源并从中获取连接。</li><li>这是在 Java 中“启动”数据库事务的唯一方法，尽管这个名字听起来有点不对劲。 setAutoCommit(true) 确保每个 SQL 语句自动包装在自己的事务中，而 setAutoCommit(false) 则相反：您是事务的主人，您需要开始调用 <code>*commit*</code> 标志在连接打开的整个时间内都有效，这意味着您只需调用该方法一次，而不是重复。</li><li>让我们提交我们的交易&mldr;​</li><li>或者，如果出现异常，则回滚我们的更改。</li></ol><p>是的，这 4 行（过于简单化的）是当你使用 @Transactional 注释时 Spring 所做的一切。在下一章中，您将了解其工作原理。但在我们开始之前，您还需要学习一些知识。</p><p>（聪明人的一个快速说明：像 HikariCP 这样的连接池库可能会根据配置自动为您切换自动提交模式。但这是一个高级主题。）</p><h3 id=如何使用-jdbc-隔离级别和保存点>如何使用 JDBC 隔离级别和保存点</h3><p>如果您已经使用过 Spring 的 @Transactional 注释，您可能遇到过类似的情况：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span>TransactionDefinition.<span style=color:#a6e22e>NESTED</span>,
</span></span><span style=display:flex><span>               isolation<span style=color:#f92672>=</span>TransactionDefinition.<span style=color:#a6e22e>ISOLATION_READ_UNCOMMITTED</span>)
</span></span></code></pre></div><p>稍后我们将更详细地介绍嵌套 Spring 事务和隔离级别，但再次了解这些参数都可以归结为以下基本 JDBC 代码会有所帮助：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.sql.Connection;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// isolation=TransactionDefinition.ISOLATION_READ_UNCOMMITTED</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>connection.<span style=color:#a6e22e>setTransactionIsolation</span>(Connection.<span style=color:#a6e22e>TRANSACTION_READ_UNCOMMITTED</span>); <span style=color:#75715e>// (1)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// propagation=TransactionDefinition.NESTED</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Savepoint savePoint <span style=color:#f92672>=</span> connection.<span style=color:#a6e22e>setSavepoint</span>(); <span style=color:#75715e>// (2)</span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>connection.<span style=color:#a6e22e>rollback</span>(savePoint);
</span></span></code></pre></div><ol><li>这就是 Spring 在数据库连接上设置隔离级别的方式。不完全是火箭科学，是吗？</li><li>Spring 中的嵌套事务只是 JDBC/数据库保存点。例如，如果您不知道什么是保存点，请查看本<a href=https://docs.oracle.com/javase/tutorial/jdbc/basics/transactions.html target=_blank>教程</a>。请注意，保存点支持取决于您的 JDBC 驱动程序/数据库。</li></ol><h2 id=spring-或-spring-boot-的事务管理如何工作>Spring 或 Spring Boot 的事务管理如何工作</h2><p>现在您已经对 JDBC 事务有了很好的了解，让我们看看简单的、核心的 Spring 是如何管理事务的。这里的所有内容都一一适用于 Spring Boot 和 Spring MVC，稍后会详细介绍。</p><p>Spring 的事务管理或其（名称相当令人困惑的）事务抽象框架实际上是什么？</p><p>请记住，事务管理简单地说就是：Spring 如何启动、提交或回滚 JDBC 事务？这听起来是不是很熟悉？</p><p>问题是：使用普通 JDBC，您只有一种方法 (setAutocommit(false)) 来管理事务，而 Spring 为您提供了许多不同的、更方便的方法来实现相同的目的。</p><h3 id=如何使用-spring-的程序化事务管理>如何使用 Spring 的程序化事务管理？</h3><p>在 Spring 中定义事务的第一种但很少使用的方法是通过编程方式：通过 TransactionTemplate 或直接通过 PlatformTransactionManager。从代码角度来看，它看起来像这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> TransactionTemplate template;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Long <span style=color:#a6e22e>registerUser</span>(User user) {
</span></span><span style=display:flex><span>        Long id <span style=color:#f92672>=</span> template.<span style=color:#a6e22e>execute</span>(status <span style=color:#f92672>-&gt;</span>  {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// execute some SQL that e.g.</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// inserts the user into the db and returns the autogenerated id</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> id;
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>与普通 JDBC 示例相比：</p><ul><li>您不必自己搞乱打开或关闭数据库连接（try-finally）。相反，您使用事务回调。</li><li>您也不必捕获 SQLException，因为 Spring 会为您将这些异常转换为运行时异常。</li><li>并且您可以更好地融入 Spring 生态系统。 TransactionTemplate 将在内部使用 TransactionManager，它将使用数据源。所有这些都是您必须在 Spring 上下文配置中指定的 bean，但以后不必再担心。</li></ul><p>虽然这算是一个小小的改进，但程序化事务管理并不是 Spring 事务框架的主要功能。相反，这都是关于声明式事务管理的。让我们看看那是什么。</p><h3 id=如何使用-spring-的-xml-声明式事务管理>如何使用 Spring 的 XML 声明式事务管理？</h3><p>过去，当 XML 配置成为 Spring 项目的标准时，您可以直接在 XML 中配置事务。除了一些遗留的企业项目之外，您将不再在野外找到这种方法，因为它已被更简单的 @Transactional 注释所取代。</p><p>我们不会在本指南中详细介绍 XML 配置，但您可以使用此示例作为深入研究的起点 - 如果需要的话（直接取自 Spring 官方文档）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;!-- the transactional advice (what &#39;happens&#39;; see the &lt;aop:advisor/&gt; bean below) --&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;tx:advice</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;txAdvice&#34;</span> <span style=color:#a6e22e>transaction-manager=</span><span style=color:#e6db74>&#34;txManager&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>&lt;!-- the transactional semantics... --&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;tx:attributes&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>&lt;!-- all methods starting with &#39;get&#39; are read-only --&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;tx:method</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;get*&#34;</span> <span style=color:#a6e22e>read-only=</span><span style=color:#e6db74>&#34;true&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>&lt;!-- other methods use the default transaction settings (see below) --&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;tx:method</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;*&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;/tx:attributes&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/tx:advice&gt;</span>
</span></span></code></pre></div><p>您使用上面的 XML 块指定 AOP 建议（面向方面 ​​ 的编程），然后可以将其应用到 UserService bean，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;aop:config&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;aop:pointcut</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;userServiceOperation&#34;</span> <span style=color:#a6e22e>expression=</span><span style=color:#e6db74>&#34;execution(* x.y.service.UserService.*(..))&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;aop:advisor</span> <span style=color:#a6e22e>advice-ref=</span><span style=color:#e6db74>&#34;txAdvice&#34;</span> <span style=color:#a6e22e>pointcut-ref=</span><span style=color:#e6db74>&#34;userServiceOperation&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/aop:config&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;bean</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;userService&#34;</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;x.y.service.UserService&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span></code></pre></div><p>您的 UserService bean 将如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Long <span style=color:#a6e22e>registerUser</span>(User user) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// execute some SQL that e.g.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// inserts the user into the db and retrieves the autogenerated id</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> id;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从 Java 代码的角度来看，这种声明式事务方法看起来比编程方法简单得多。但它会导致大量复杂、冗长的 XML，以及切入点和顾问程序配置。</p><p>因此，这就引出了一个问题：是否有比 XML 更好的声明式事务管理方法？是的，有：@Transactional 注释。</p><h3 id=如何使用-spring-的transactional-注解声明式事务管理>如何使用 Spring 的@Transactional 注解（声明式事务管理）</h3><p>现在让我们看看现代 Spring 事务管理通常是什么样子的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Long <span style=color:#a6e22e>registerUser</span>(User user) {
</span></span><span style=display:flex><span>       <span style=color:#75715e>// execute some SQL that e.g.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// inserts the user into the db and retrieves the autogenerated id</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// userDao.save(user);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> id;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这怎么可能？不再需要 XML 配置，也不需要其他代码。相反，您现在需要做两件事：</p><ul><li>确保您的 Spring 配置带有 @EnableTransactionManagement 注释（在 Spring Boot 中，这将自动为您完成）。</li><li>确保您在 Spring 配置中指定了事务管理器（无论如何您都需要这样做）。</li><li>然后 Spring 足够智能，可以透明地为您处理事务：您用 @Transactional 注释注释的任何 bean 的公共方法都将在数据库事务内执行（注意：存在一些陷阱）。</li></ul><p>因此，要使 @Transactional 注释正常工作，您需要做的就是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Configuration</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@EnableTransactionManagement</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MySpringConfig</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> PlatformTransactionManager <span style=color:#a6e22e>txManager</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> yourTxManager; <span style=color:#75715e>// more on that later</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在，当我说 Spring 透明地为您处理事务时。那个的真实意义是什么？</p><p>借助 JDBC 事务示例中的知识，上面的 @Transactional UserService 代码可以直接转换（简化）为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Long <span style=color:#a6e22e>registerUser</span>(User user) {
</span></span><span style=display:flex><span>        Connection connection <span style=color:#f92672>=</span> dataSource.<span style=color:#a6e22e>getConnection</span>(); <span style=color:#75715e>// (1)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> (connection) {
</span></span><span style=display:flex><span>            connection.<span style=color:#a6e22e>setAutoCommit</span>(<span style=color:#66d9ef>false</span>); <span style=color:#75715e>// (1)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// execute some SQL that e.g.</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// inserts the user into the db and retrieves the autogenerated id</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// userDao.save(user); &lt;(2)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            connection.<span style=color:#a6e22e>commit</span>(); <span style=color:#75715e>//(1)</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (SQLException e) {
</span></span><span style=display:flex><span>            connection.<span style=color:#a6e22e>rollback</span>(); <span style=color:#75715e>// (1)</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li>这只是 JDBC 连接的标准打开和关闭。这就是 Spring 的事务注释自动为您做的事情，而无需您显式地编写它。</li><li>这是您自己的代码，通过 DAO 或类似的东西保存用户。</li></ol><p>这个例子可能看起来有点神奇，但是让我们看看 Spring 如何为您插入这个连接代码。</p><h3 id=cglib-和-jdk-代理---transactional-的幕后黑手>CGlib 和 JDK 代理 - @Transactional 的幕后黑手</h3><p>Spring 无法真正重写您的 Java 类，就像我上面所做的那样，以插入连接代码（除非您使用字节码编织等高级技术，但我们现在忽略它）。</p><p>你的 registerUser() 方法实际上只是调用 userDao.save(user) ，没有办法动态改变它。</p><p>但 Spring 有一个优势。它的核心是一个 IoC 容器。它为您实例化一个 UserService 并确保将该 UserService 自动装配到任何其他需要 UserService 的 bean 中。</p><p>现在，每当您在 bean 上使用 @Transactional 时，Spring 都会使用一个小技巧。它不仅实例化 UserService，而且还实例化该 UserService 的事务代理。</p><p>它在 Cglib 库的帮助下通过一种称为代理通过子类化的方法来实现这一点。还有其他构建代理的方法（例如动态 JDK 代理），但我们暂时就这样吧。</p><p>让我们看看这张图中代理的作用：</p><p><img src=/images/spring-transaction-management-01.webp alt=document1></p><p>从该图中可以看出，代理有一项工作。</p><ul><li>打开和关闭数据库连接/事务。</li><li>然后委托给真正的 UserService，即您编写的那个。</li><li>而其他 bean，例如 UserRestController，永远不会知道它们正在与代理通信，而不是与真实的事物通信。</li></ul><p><strong>快速考试</strong></p><p>看一下下面的源代码，告诉我 Spring 自动构造什么类型的 UserService，假设它带有 @Transactional 标记或具有 @Transactional 方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Configuration</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@EnableTransactionManagement</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyAppConfig</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> UserService <span style=color:#a6e22e>userService</span>() {  <span style=color:#75715e>// (1)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> UserService();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li>正确的。 Spring 在这里为您的 UserService 类构造一个动态 CGLib 代理，它可以为您打开和关闭数据库事务。您或任何其他 bean 甚至不会注意到它不是您的 UserService，而是包装您的 UserService 的代理。</li></ol><h3 id=为什么需要事务管理器如-platformtransactionmanager>为什么需要事务管理器（如 PlatformTransactionManager）？</h3><p>现在只缺少一条关键信息，尽管我们已经提到过几次了。</p><p>您的 UserService 会动态被代理，并且代理会为您管理事务。但处理所有事务状态（打开、提交、关闭）的不是代理本身，而是代理委托给事务管理器。</p><p>Spring 为您提供了 PlatformTransactionManager / TransactionManager 接口，默认情况下，它附带了一些方便的实现。其中之一是数据源事务管理器。</p><p>它所做的正是您迄今为止所做的管理事务的操作，但首先，让我们看看所需的 Spring 配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> DataSource <span style=color:#a6e22e>dataSource</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> MysqlDataSource(); <span style=color:#75715e>// (1)</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> PlatformTransactionManager <span style=color:#a6e22e>txManager</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> DataSourceTransactionManager(dataSource()); <span style=color:#75715e>// (2)</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li>您可以在此处创建特定于数据库或特定于连接池的数据源。本示例使用 MySQL。</li><li>在这里，您创建事务管理器，它需要一个数据源才能管理事务。</li></ol><p>简单如。然后，所有事务管理器都有像“doBegin”（用于启动事务）或“doCommit”这样的方法，它们看起来像这样——直接取自 Spring 的源代码并进行了一些简化：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DataSourceTransactionManager</span> <span style=color:#66d9ef>implements</span> PlatformTransactionManager {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doBegin</span>(Object transaction, TransactionDefinition definition) {
</span></span><span style=display:flex><span>        Connection newCon <span style=color:#f92672>=</span> obtainDataSource().<span style=color:#a6e22e>getConnection</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>        con.<span style=color:#a6e22e>setAutoCommit</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// yes, that&#39;s it!</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doCommit</span>(DefaultTransactionStatus status) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>        Connection connection <span style=color:#f92672>=</span> status.<span style=color:#a6e22e>getTransaction</span>().<span style=color:#a6e22e>getConnectionHolder</span>().<span style=color:#a6e22e>getConnection</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            con.<span style=color:#a6e22e>commit</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (SQLException ex) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> TransactionSystemException(<span style=color:#e6db74>&#34;Could not commit JDBC transaction&#34;</span>, ex);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因此，数据源事务管理器在管理事务时使用与您在 JDBC 部分中看到的完全相同的代码。</p><p>考虑到这一点，让我们从上面扩展我们的图片：</p><p><img src=/images/spring-transaction-management-02.webp alt=document2></p><p>总结一下：</p><ol><li>如果 Spring 检测到 bean 上的 @Transactional 注释，它会创建该 bean 的动态代理。</li><li>代理可以访问事务管理器，并要求它打开和关闭事务/连接。</li><li>事务管理器本身将简单地执行您在普通 Java 部分中所做的操作：管理良好的旧 JDBC 连接。</li></ol><h3 id=物理事务和逻辑事务有什么区别>物理事务和逻辑事务有什么区别？</h3><p>想象一下以下两个事务类。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> InvoiceService invoiceService;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>invoice</span>() {
</span></span><span style=display:flex><span>        invoiceService.<span style=color:#a6e22e>createPdf</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// send invoice as email, etc.</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InvoiceService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>createPdf</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>UserService 有一个事务性 Invoice() 方法。它调用 InvoiceService 上的另一个事务方法 createPdf()。</p><p>现在就数据库事务而言，这实际上应该只是一个数据库事务。 （记住：getConnection().setAutocommit(false).commit()。）Spring 调用此物理事务，尽管一开始这听起来有点令人困惑。</p><p>然而，从 Spring 的角度来看，发生了两个逻辑事务：第一个在 UserService 中，另一个在 InvoiceService 中。 Spring 必须足够聪明，知道这两个 @Transactional 方法应该使用相同的底层物理数据库事务。</p><p>如果对 InvoiceService 进行以下更改，情况会有什么不同？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InvoiceService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>(propagation <span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>REQUIRES_NEW</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>createPdf</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>将传播模式更改为 require_new 是告诉 Spring createPDF() 需要在自己的事务中执行，独立于任何其他已存在的事务。回想一下本指南的纯 Java 部分，您是否看到了将事务“拆分”为两半的方法？我也不。</p><p>这基本上意味着您的代码将打开两个到数据库的（物理）连接/事务。 （再次：getConnection() x2.setAutocommit(false) x2.commit() x2）Spring 现在必须足够智能，两个逻辑事务部分 (invoice()/createPdf()) 现在也映射到两个不同的物理数据库交易。</p><p>所以，总结一下：</p><ul><li>物理事务：是您实际的 JDBC 事务。</li><li>逻辑事务：是（可能嵌套的）@Transactional 注解的（Spring）方法。</li></ul><p>这使我们能够更详细地介绍传播模式。</p><h3 id=transactional-传播级别的用途是什么>@Transactional 传播级别的用途是什么？</h3><p>查看 Spring 源代码时，您会发现可以插入 @Transactional 方法的各种传播级别或模式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  <span style=color:#a6e22e>@Transactional</span>(propagation <span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>REQUIRED</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// or</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Transactional</span>(propagation <span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>REQUIRES_NEW</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>// etc</span>
</span></span></code></pre></div><p>完整列表：</p><ul><li>REQUIRED 必需的</li><li>SUPPORTS 支持</li><li>MANDATORY 强制的</li><li>REQUIRES_NEW REQUIRES_NEW</li><li>NOT_SUPPORTED 不支持</li><li>NEVER 绝不</li><li>NESTED 嵌套</li></ul><p><strong>练习：</strong></p><p>在普通 Java 部分中，我向您展示了 JDBC 在事务方面可以执行的所有操作。花点时间思考一下每个 Spring 传播模式最终对您的数据源（或者更确切地说，您的 JDBC 连接）到底做了什么。</p><p>那就看看下面的回答吧。</p><p><strong>答案：</strong></p><ul><li><strong>Required (default)</strong>：我的方法需要一个事务，要么为我打开一个事务，要么使用现有的事务 → getConnection()。设置自动提交（假）。犯罪（）。</li><li><strong>Supports</strong>：我并不关心事务是否打开，我可以以任何一种方式工作 → 与 JDBC 无关</li><li><strong>Mandatory</strong>：我自己不会打开一个事务，但是如果没有人打开一个事务我会哭 → 与 JDBC 无关</li><li><strong>Require_new</strong>：我想要完全自己的事务 → getConnection()。设置自动提交（假）。犯罪（）。</li><li><strong>Not_Supported</strong>：我真的不喜欢事务，我什至会尝试挂起当前正在运行的事务 → 与 JDBC 无关</li><li>**Never：**如果其他人启动事务我会哭 → 与 JDBC 无关</li><li><strong>Nested：</strong> 听起来很复杂，但我们只是在谈论保存点！ → 连接.setSavepoint()</li></ul><p>正如您所看到的，大多数传播模式实际上与数据库或 JDBC 无关，而更多地与您如何使用 Spring 构建程序以及 Spring 期望事务出现的方式/时间/地点有关。</p><p>看这个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>@Transactional</span>(propagation <span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>MANDATORY</span>)
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>myMethod</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// execute some sql</span>
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这种情况下，每当您调用 UserService 类的 myMethod() 时，Spring 都会期望打开一个事务。它本身不会打开一个方法，相反，如果您在没有预先存在的事务的情况下调用该方法，Spring 将抛出异常。请记住这一点，作为“逻辑事务处理”的附加点。</p><h3 id=transactional-隔离级别有什么用>@Transactional 隔离级别有什么用？</h3><p>此时这几乎是一个棘手的问题，但是当您像这样配置 @Transactional 注释时会发生什么？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(isolation <span style=color:#f92672>=</span> Isolation.<span style=color:#a6e22e>REPEATABLE_READ</span>)
</span></span></code></pre></div><p>是的，它确实会导致这样的结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>connection.<span style=color:#a6e22e>setTransactionIsolation</span>(Connection.<span style=color:#a6e22e>TRANSACTION_REPEATABLE_READ</span>);
</span></span></code></pre></div><p>然而，数据库隔离级别是一个复杂的主题，您应该花一些时间来完全掌握它们。一个好的开始是 Postgres <a href=https://www.postgresql.org/docs/9.5/transaction-iso.html target=_blank>官方文档</a>及其有关隔离级别的部分。</p><p>另请注意，在事务期间切换隔离级别时，您必须确保咨询 JDBC 驱动程序/数据库以了解支持哪些场景，哪些不支持。</p><h3 id=最常见的transactional-陷阱>最常见的@Transactional 陷阱</h3><p>Spring 初学者通常会遇到一个陷阱。看一下下面的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>invoice</span>() {
</span></span><span style=display:flex><span>        createPdf();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// send invoice as email, etc.</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>(propagation <span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>REQUIRES_NEW</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>createPdf</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>您有一个带有事务发票方法的 UserService 类。它调用 createPDF()，这也是事务性的。</p><p>一旦有人调用 invoice()，您期望打开多少实际交易？</p><p>不，答案不是两个，而是一个。为什么？</p><p>让我们回到本指南的代理部分。 Spring 为您创建事务性 UserService 代理，但是一旦您进入 UserService 类并调用其他内部方法，就不再涉及代理。这意味着，您没有新的交易。</p><p>我们用一张图来看看：</p><p><img src=/images/spring-transaction-management-03.webp alt=document3></p><p>您可以使用一些技巧（例如自注入）来绕过此限制。但主要的要点是：始终牢记代理事务边界。</p><h3 id=如何在-spring-boot-或-spring-mvc-中使用-transactional>如何在 Spring Boot 或 Spring MVC 中使用 @Transactional</h3><p>到目前为止，我们只讨论了简单的、核心的 Spring。但是 Spring Boot 呢？还是 Spring Web MVC？他们处理交易的方式有什么不同吗？</p><p>最简洁的答案是不。</p><p>对于任一框架（或者更确切地说：Spring 生态系统中的所有框架），您将始终使用 <code>*@Transactional*</code> 注释，并结合事务管理器和 @EnableTransactionManagement 注释。没有其他办法。</p><p>然而，与 Spring Boot 的唯一区别是，它使用 JDBC 自动配置自动设置 <code>*@EnableTransactionManagement*</code> 注释并为您创建 <code>*PlatformTransactionManager*</code> 。在此处了解有关自动配置的更多信息。</p><h3 id=spring-如何处理回滚以及默认回滚策略>Spring 如何处理回滚（以及默认回滚策略）</h3><p>有关 Spring 回滚的部分将在本指南的下一版本中处理。</p><h2 id=spring-和-jpahibernate-事务管理如何工作>Spring 和 JPA/Hibernate 事务管理如何工作</h2><h3 id=目标同步-spring-的-transactional-和-hibernate--jpa>目标：同步 Spring 的 @Transactional 和 Hibernate / JPA</h3><p>在某些时候，您会希望 Spring 应用程序与另一个数据库库集成，例如 Hibernate（一种流行的 JPA 实现）或 Jooq 等。</p><p>让我们以普通 Hibernate 为例（注意：直接使用 Hibernate，或者通过 JPA 使用 Hibernate 并不重要）。</p><p>将之前的 UserService 重写为 Hibernate 如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> SessionFactory sessionFactory; <span style=color:#f92672>/</span> (1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>registerUser</span>(User user) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Session session <span style=color:#f92672>=</span> sessionFactory.<span style=color:#a6e22e>openSession</span>(); <span style=color:#f92672>/</span> (2)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// lets open up a transaction. remember setAutocommit(false)!</span>
</span></span><span style=display:flex><span>        session.<span style=color:#a6e22e>beginTransaction</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// save == insert our objects</span>
</span></span><span style=display:flex><span>        session.<span style=color:#a6e22e>save</span>(user);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// and commit it</span>
</span></span><span style=display:flex><span>        session.<span style=color:#a6e22e>getTransaction</span>().<span style=color:#a6e22e>commit</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// close the session == our jdbc connection</span>
</span></span><span style=display:flex><span>        session.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li>这是一个普通的、旧的 Hibernate SessionFactory，是所有 Hibernate 查询的入口点。</li><li>使用 Hibernate API 手动管理会话（即：数据库连接）和事务。</li></ol><p>然而，上面的代码有一个很大的问题：</p><ul><li>Hibernate 不会知道 Spring 的 @Transactional 注释。</li><li>Spring 的 @Transactional 对 Hibernate 的事务一无所知。</li></ul><p>但我们实际上希望 Spring 和 Hibernate 能够无缝集成，这意味着它们了解彼此的事务。</p><p>用纯代码表示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> SessionFactory sessionFactory; <span style=color:#f92672>/</span> (1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>registerUser</span>(User user) {
</span></span><span style=display:flex><span>        sessionFactory.<span style=color:#a6e22e>getCurrentSession</span>().<span style=color:#a6e22e>save</span>(user); <span style=color:#f92672>/</span> (2)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li>与之前相同的 SessionFactory</li><li>但不再需要手动状态管理。相反， getCurrentSession() 和 @Transactional 是同步的。</li></ol><p>到那里怎么走？</p><h3 id=使用-hibernatetransactionmanager>使用 HibernateTransactionManager</h3><p>对于这个集成问题有一个非常简单的解决方法：</p><p>您将使用 HibernateTransactionManager（如果使用普通 Hibernate）或 JpaTransactionManager（如果通过 JPA 使用 Hibernate），而不是在 Spring 配置中使用 DataSourcePlatformTransactionManager。</p><p>专门的 HibernateTransactionManager 将确保：</p><ol><li>通过 Hibernate（即 SessionFactory）管理事务。</li><li>足够聪明，允许 Spring 在非 Hibernate 中使用相同的事务，即 @Transactional Spring 代码。</li></ol><p>与往常一样，图片可能更容易理解（但请注意，代理和实际服务之间的流程仅在概念上正确且过于简单）。</p><p><img src=/images/spring-transaction-management-04.webp alt=document4></p><p>简而言之，就是如何集成 Spring 和 Hibernate。</p><p>对于其他集成或更深入的理解，快速查看 Spring 提供的所有可能的 PlatformTransactionManager 实现会有所帮助。</p><h2 id=fin>Fin</h2><p>到目前为止，您应该对事务管理如何与 Spring 框架配合使用以及它如何应用于其他 Spring 库（如 Spring Boot 或 Spring WebMVC）有一个很好的概述。最大的收获应该是，最终使用哪个框架并不重要，这都与 JDBC 基础知识有关。</p><p>如果它们正确（记住：getConnection().setAutocommit(false).commit().），您将更容易理解稍后在复杂的企业应用程序中发生的情况。</p><p>谢谢阅读。</p><h2 id=致谢>致谢</h2><p>感谢 Andreas Eisele 对本指南早期版本的反馈。感谢 Ben Horsfield 提供了急需的 Javascript 片段来增强本指南。</p><p>原文链接：<a href=https://www.marcobehler.com/guides/spring-transaction-management-transactional-in-depth target=_blank>https://www.marcobehler.com/guides/spring-transaction-management-transactional-in-depth</a></p></div><footer class=post__footer><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 000-6 3 3 0 000 6"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/spring-boot/ rel=tag>spring-boot</a></li></ul></div></footer></footer></article></main><nav class="pagination flex"><div class="pagination__item pagination__item--prev"><a class=pagination__link href=/posts/2023/08/16/spring-boot-docker/ rel=prev><p class=pagination__title>«&#8201;上一篇: [译]为 Spring Boot 应用程序创建优化的 Docker 映像</p></a></div><div class="pagination__item pagination__item--next"><a class=pagination__link href=/posts/2023/08/16/spring-security-authentication-and-authorization/ rel=next><p class=pagination__title>&#8201;» 下一篇: [译]Spring Security：深入了解身份验证和授权</p></a></div></nav><footer class=post__footer><div class=post-related><h3>相关文章</h3><ul class=post-related-list><li class=post-related-item><a href=/posts/2023/08/16/spring-boot-docker/ target=_blank title="[译]为 Spring Boot 应用程序创建优化的 Docker 映像">[译]为 Spring Boot 应用程序创建优化的 Docker 映像</a></li><li class=post-related-item><a href=/posts/2023/07/26/spring-boot-exception-handling/ target=_blank title="[译]Spring Boot异常处理完整指南">[译]Spring Boot异常处理完整指南</a></li><li class=post-related-item><a href=/posts/2023/07/26/spring-boot-null-safety-annotations/ target=_blank title="[译]使用 Spring 的 Null-Safety 注解保护您的代码免受 NullPointerExceptions 的影响">[译]使用 Spring 的 Null-Safety 注解保护您的代码免受 NullPointerExceptions 的影响</a></li><li class=post-related-item><a href=/posts/2023/07/26/spring-boot-info-endpoint/ target=_blank title="[译]使用Spring Boot Actuator公开有用的信息端点">[译]使用Spring Boot Actuator公开有用的信息端点</a></li></ul></div></footer><div class="authorbox clearfix"><figure class=authorbox__avatar><img alt="ChenSoul avatar" src=/avatar.jpg class=avatar height=60 width=60 loading=lazy></figure><div class=authorbox__header><span class=authorbox__name>关于 ChenSoul</span></div><div class=authorbox__description>一个来自中国武汉的开发者，主要撰写软件开发和开源方面的文章。浏览我的<a href=%28/posts%29>博客文章</a>，订阅我的 <a href=/index.xml>RSS</a> 源，或了解更多<a href=/about/>关于我</a>的信息。</div></div><p><h3>欢迎留言！</h3></p><div id=remark42></div><script>var remark_config={host:"https://comment.chensoul.cc",site_id:"remark",components:["embed"],url:"https://blog.chensoul.cc/posts/2023/08/16/spring-transaction-management-transactional-in-depth/",locale:"zh"};!function(e,t){for(s=0;s<e.length;s++){var s,n=t.createElement("script"),o=".js",i=t.head||t.body;"noModule"in n?(n.type="module",o=".mjs"):n.async=!0,n.defer=!0,n.src=remark_config.host+"/web/"+e[s]+o,i.appendChild(n)}}(remark_config.components||["embed"],document)</script></div><aside class="sidebar sidebar--right"><div class="post__toc toc"><div class=toc__title>目录</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#介绍>介绍</a></li><li><a href=#普通-jdbc-事务管理的工作原理>普通 JDBC 事务管理的工作原理</a><ul><li><a href=#如何启动提交或回滚-jdbc-事务>如何启动、提交或回滚 JDBC 事务</a></li><li><a href=#如何使用-jdbc-隔离级别和保存点>如何使用 JDBC 隔离级别和保存点</a></li></ul></li><li><a href=#spring-或-spring-boot-的事务管理如何工作>Spring 或 Spring Boot 的事务管理如何工作</a><ul><li><a href=#如何使用-spring-的程序化事务管理>如何使用 Spring 的程序化事务管理？</a></li><li><a href=#如何使用-spring-的-xml-声明式事务管理>如何使用 Spring 的 XML 声明式事务管理？</a></li><li><a href=#如何使用-spring-的transactional-注解声明式事务管理>如何使用 Spring 的@Transactional 注解（声明式事务管理）</a></li><li><a href=#cglib-和-jdk-代理---transactional-的幕后黑手>CGlib 和 JDK 代理 - @Transactional 的幕后黑手</a></li><li><a href=#为什么需要事务管理器如-platformtransactionmanager>为什么需要事务管理器（如 PlatformTransactionManager）？</a></li><li><a href=#物理事务和逻辑事务有什么区别>物理事务和逻辑事务有什么区别？</a></li><li><a href=#transactional-传播级别的用途是什么>@Transactional 传播级别的用途是什么？</a></li><li><a href=#transactional-隔离级别有什么用>@Transactional 隔离级别有什么用？</a></li><li><a href=#最常见的transactional-陷阱>最常见的@Transactional 陷阱</a></li><li><a href=#如何在-spring-boot-或-spring-mvc-中使用-transactional>如何在 Spring Boot 或 Spring MVC 中使用 @Transactional</a></li><li><a href=#spring-如何处理回滚以及默认回滚策略>Spring 如何处理回滚（以及默认回滚策略）</a></li></ul></li><li><a href=#spring-和-jpahibernate-事务管理如何工作>Spring 和 JPA/Hibernate 事务管理如何工作</a><ul><li><a href=#目标同步-spring-的-transactional-和-hibernate--jpa>目标：同步 Spring 的 @Transactional 和 Hibernate / JPA</a></li><li><a href=#使用-hibernatetransactionmanager>使用 HibernateTransactionManager</a></li></ul></li><li><a href=#fin>Fin</a></li><li><a href=#致谢>致谢</a></li></ul></nav></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__links><a class=footer__link href=/>首页</a> | <a class=footer__link href=/categories/>分类</a> | <a class=footer__link href=/about/>关于</a> | <a class=footer__link href=/index.xml>RSS</a></div><div class=footer__copyright>&copy; 2025 ChenSoul.
<span class=footer__copyright-credits>基于 <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> 引擎和 <a href=https://github.com/chensoul/rose-hugo/ rel="nofollow noopener" target=_blank>Rose Hugo</a> 主题</span></div></div><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script defer src=https://umami.chensoul.cc/random-string.js data-website-id=1e07d36d-bec3-4ba6-9459-876b1ac3bbe7></script></footer></div><script>"use strict";(function(t){var i=t.querySelector(".menu__btn"),o=t.querySelector(".menu__list");function a(){o.classList.toggle("menu__list--active"),o.classList.toggle("menu__list--transition"),this.classList.toggle("menu__btn--active"),this.setAttribute("aria-expanded",this.getAttribute("aria-expanded")==="true"?"false":"true")}function r(){this.classList.remove("menu__list--transition")}i&&o&&(i.addEventListener("click",a,!1),o.addEventListener("transitionend",r,!1))})(document,window)</script></body></html>