<!doctype html><html lang=en-US prefix="og: http://ogp.me/ns#"><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="原文链接：How to Secure your REST APIs with Spring Security & JSON Web Tokens (JWTs)"><title>[译]如何使用Spring Security和JWT保护您的REST API | ChenSoul</title><link rel=canonical href=https://blog.chensoul.cc/posts/2023/09/19/spring-security-jwt/><link rel=preconnect href=https://fonts.font.im><link rel=preconnect href=https://fonts.loli.net crossorigin><link href="https://fonts.loli.net/css2?family=Roboto+Slab:wght@400;500;700&display=swap" rel=stylesheet><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.chensoul.cc/images/favicon.webp"><meta name=twitter:title content="[译]如何使用Spring Security和JWT保护您的REST API"><meta name=twitter:description content="原文链接：How to Secure your REST APIs with Spring Security & JSON Web Tokens (JWTs)"><meta name=twitter:creator content="@ichensoul"><meta property="og:locale" content="en_US"><meta property="og:site_name" content="chensoul"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/09/19/spring-security-jwt/"><meta property="og:site_name" content="ChenSoul"><meta property="og:title" content="[译]如何使用Spring Security和JWT保护您的REST API"><meta property="og:description" content="原文链接：How to Secure your REST APIs with Spring Security & JSON Web Tokens (JWTs)"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-19T00:00:00+00:00"><meta property="article:modified_time" content="2023-09-19T00:00:00+00:00"><meta property="article:tag" content="Spring-Security"><meta property="og:image" content="https://blog.chensoul.cc/images/favicon.webp"><meta itemprop=name content="[译]如何使用Spring Security和JWT保护您的REST API"><meta itemprop=description content="原文链接：How to Secure your REST APIs with Spring Security & JSON Web Tokens (JWTs)"><meta itemprop=datePublished content="2023-09-19T00:00:00+00:00"><meta itemprop=dateModified content="2023-09-19T00:00:00+00:00"><meta itemprop=wordCount content="921"><meta itemprop=image content="https://blog.chensoul.cc/images/favicon.webp"><meta itemprop=keywords content="Spring-Security"><link rel=stylesheet href=https://cdnjs.loli.net/ajax/libs/font-awesome/6.4.0/css/all.min.css media=all><link rel=stylesheet href=/main.min.css type=text/css media=all><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"TechArticle","name":"[译]如何使用Spring Security和JWT保护您的REST API","headline":"[译]如何使用Spring Security和JWT保护您的REST API","inLanguage":"en-US","url":"https://blog.chensoul.cc/posts/2023/09/19/spring-security-jwt/","description":"\u003cp\u003e原文链接：\u003ca href=\"https://www.danvega.dev/blog/spring-security-jwt\" target=\"_blank\"\u003eHow to Secure your REST APIs with Spring Security \u0026amp; JSON Web Tokens (JWTs)\u003c/a\u003e\u003c/p\u003e","wordCount":"921","keywords":["spring-security"],"datePublished":"2023-09-19T00:00:00Z","dateModified":"2023-09-19T00:00:00Z","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/09/19/spring-security-jwt/"},"publisher":{"@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/posts/2023/09/19/spring-security-jwt/"}},{"@context":"https://schema.org","@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/","sameAs":["https://x.com/ichensoul","https://github.com/chensoul","https://www.linkedin.com/in/","https://www.youtube.com/@chensoul","https://t.me/chensouls"]}]}</script><script defer src=https://umami.chensoul.cc/random-string.js data-website-id=4718b57b-c900-4a61-a7af-0fe1fb1d50ce></script></head><body class="home blog post-layout-one-column"><button onclick=topFunction() id=scrollTopBtn title="Go to top">
<i class="fa-solid fa-arrow-up"></i></button><div id=header-top class=header-bar-wrap></div><div id=page class=site><a class="skip-link screen-reader-text" href=#content>Skip to content</a><header id=masthead class="site-header clearfix" role=banner><div class="header-main container clearfix"><div id=logo class="site-branding clearfix"><h1 class=site-title><a href=/ title=ChenSoul rel=home>ChenSoul</a></h1><p class=site-description>Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials</p></div><div class="header-widgets clearfix"><aside id=search-2 class="header-widget widget_search"><form role=search method=get class=search-form onsubmit="return searchSite(event)"><label><span class=screen-reader-text>Search for:</span>
<input type=search class=search-field placeholder="Enter search keyword" name=query id=query title="Enter search keyword">
</label><button type=submit class=search-submit title=Search> <span class=genericon-search></span>
<span class=screen-reader-text>Search</span></button></form></aside></div></div><div id=main-navigation-wrap class=primary-navigation-wrap><nav id=main-navigation class="primary-navigation navigation container clearfix" role=navigation><ul id=menu-home class=main-navigation-menu><li class="menu-item menu-item-type-custom menu-item-object-custom
current-menu-item current_page_item menu-item-home"><a href=/>Home</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/spring-boot/>Spring Boot</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/architecture/>Architecture</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/microservice/>Microservice</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/kubernetes/>Kubernetes</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category
menu-item-has-children"><a href=/tutorials/>Tutorials</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/spring-boot-tutorials/>Spring Boot Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/microservice-tutorials/>Microservice Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/kubernetes-tutorials/>Kubernetes Tutorials</a></li></ul></li><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=https://github.com/chensoul target=_blank>About Me</a></li></ul></nav></div></header><div id=content class="site-content container clearfix"><section id=primary class="content-archive content-area post-content-area"><main id=main class=site-main role=main><article class="post type-post"><div class=post-inner-content><header class=entry-header><h2 class=entry-title><a href=https://blog.chensoul.cc/posts/2023/09/19/spring-security-jwt/ rel=bookmark title="[译]如何使用Spring Security和JWT保护您的REST API">[译]如何使用Spring Security和JWT保护您的REST API</a></h2><div class=entry-meta><span class=meta-date><time class="entry-date published" datetime=2023-09-19T00:00:00>2023-09-19
</time></span><span class=meta-author><span class="author vcard">chensoul</span>
</span><span class="tagcloud post-tags"><i class="fa fa-tags"></i>&nbsp;
<a class="tag-cloud-link widget__link widget__link--taglist" href=/tags/spring-security/ title=spring-security>spring-security</a></span></div></header><div class=entry-content><p>原文链接：<a href=https://www.danvega.dev/blog/spring-security-jwt target=_blank>How to Secure your REST APIs with Spring Security & JSON Web Tokens (JWTs)</a></p><p>如果您快速搜索如何使用 JSON Web Tokens 在 Spring Boot 中保护 REST API，您会发现很多相同的结果。这些结果包含一种方法，该方法涉及编写自定义过滤器链并引入第三方库来编码和解码 JWT。</p><p>在看完这些令人费解且令人困惑的教程后，我说必须有一种更简单的方法来做到这一点。我做了任何直接接触 Spring Security 团队的人都会做的事情，我向他们寻求帮助。他们告诉我，Spring Security 确实使用 oAuth2 资源服务器内置了对 JWT 的支持。</p><p>在本教程中，您将学习如何使用 JSON Web Tokens (JWT) 和 Spring Security 来保护您的 API。我并不是说这种方法无论如何都很容易，但对我来说，它比其他选择更有意义。</p><p><a href=https://github.com/danvega/jwt target=_blank>Github 仓库</a></p><h2 id=应用架构>应用架构</h2><p>在我们开始编写一些代码之前，我想确保我们对于我们正在构建的内容都达成共识。在下面的示例中，您有一个客户端应用程序，它可以是一个简单的命令行应用程序、一个用 Angular 或 Vue 等编写的完整前端应用程序，或者系统中的其他一些服务。</p><p>该客户端应用程序将调用使用 Spring Boot 编写的服务器应用程序，该应用程序通过 REST API 公开数据。在下面的示例中，它是一个整体，但如果您有分布式架构，则同样适用。当前有 3 个 REST 控制器公开资源产品、订单和客户。</p><p>您要做的是保护所有资源，以便当客户端调用 REST API 时，客户端将收到 401（未经授权），这意味着客户端请求尚未完成，因为它缺少所请求资源的有效身份验证凭据。</p><p><img src=/images/app-arch-401.webp alt="Application Architecture: 401 Unauthorized"></p><h3 id=json-网络令牌-jwt>JSON 网络令牌 (JWT)</h3><p>JSON Web 令牌是一种开放方法，用于在两方之间安全地表示声明。 JWT 是一组声明（JSON 属性-值对），它们共同构成一个 JSON 对象。它由三部分组成：</p><ul><li>Header: 由两个属性组成：{ &ldquo;alg&rdquo;: &ldquo;HS256&rdquo;, &ldquo;typ&rdquo;: &ldquo;JWT&rdquo; }。 alg 是用于加密 JWT 的算法。</li><li>Payload: 这是存储要发送的数据的地方；该数据存储为 JSON 属性-值对。</li><li>Signature: 这是通过加密创建的，使用标头中指定的算法：（i）base64Url 编码的标头，（ii）base64Url 编码的有效负载，以及（iii）秘密（或私钥）：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span>HMACSHA256(base64UrlEncode(header) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;.&#34;</span> <span style=color:#f92672>+</span> base64UrlEncode(payload), secret<span style=color:#f92672>|</span>privateKey)
</span></span></code></pre></div><p>最终的 JWT 由三部分组成。每个都是 base64Url 编码的，并且与下一个之间用点分隔。有关更多详细信息，请参阅 openid.net 和 jwt.io 网站。</p><p>您将引入一个新的身份验证控制器，客户端可以使用其身份验证凭据（用户名 + 密码）向该控制器发出请求，并且当成功通过身份验证时，服务将返回 JWT。</p><p><img src=/images/app-arch-jwt.webp alt="Application Architecture: JSON Web Token (JWT)"></p><p>然后，客户端将存储 JWT，并且每个后续请求将通过 Authorization 标头传递它。当服务器应用程序收到带有 JWT 的请求时，它将验证它是否是有效令牌，如果是，则允许请求继续。</p><p><img src=/images/app-arch-with-jwt-200.webp alt="Application Architecture: Request with JSON Web Token (JWT)"></p><h2 id=入门>入门</h2><p>首先，您将前往 start.spring.io 并创建一个新项目。填写项目的元数据并添加以下依赖项：</p><ul><li>Spring Web</li><li>oAuth2 Resource Server oAuth2</li><li>Spring Configuration Processor</li></ul><p><img src=/images/start-spring-io.webp alt="Spring Initializer"></p><p>这将在您的 <code>pom.xml</code> 中生成以下依赖项</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.boot<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-boot-starter-web<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.boot<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-boot-starter-oauth2-resource-server<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.boot<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-boot-configuration-processor<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;optional&gt;</span>true<span style=color:#f92672>&lt;/optional&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>我知道你在想什么，Spring Security 怎么样？如果您深入研究 <code>spring-boot-starter-oauth2-resource-server</code> ，您会发现它包含 Spring Security Starter，其中包含您需要的一切。</p><h2 id=rest-api>REST API</h2><p>您需要做的第一件事是创建一个您想要保护的 REST API。出于演示目的并保持简单，使用返回字符串的单个方法在 <code>controller</code> 包中创建 <code>HomeController</code> 。请求映射处理程序方法可以接受一系列参数，其中之一是 <code>java.security.Principal</code> 。这将允许您打印出当前经过身份验证的用户的用户名。</p><p>Spring Security 采用默认安全的安全方法。这意味着，如果您启动应用程序并尝试访问 http://localhost:8080，您将被重定向到登录页面。如果您想登录，可以输入用户名 <code>user</code> ，密码将生成并应在控制台输出中列出。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@RestController</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HomeController</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@GetMapping</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>home</span>(Principal principal) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Hello, &#34;</span> <span style=color:#f92672>+</span> principal.<span style=color:#a6e22e>getName</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img src=/images/please-sign-in.webp alt="Spring Security Login"></p><h2 id=spring-安全配置>SPRING 安全配置</h2><p>默认的安全配置足以让您启动并运行，但您需要提供自己的安全配置来满足应用程序的需求。过去，您可以扩展 <code>WebSecurityConfigurerAdapter</code> ，但这在 Spring Security 5.7.x 中已被弃用。如果您有兴趣了解有关此更改的更多信息，可以查看<a href=https://youtu.be/s4X4SJv2RrU target=_blank>本教程</a>。</p><p>首先，在 <code>config</code> 包中创建一个名为 <code>SecurityConfig</code> 的新类。该类将具有以下配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Configuration</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@EnableWebSecurity</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SecurityConfig</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> SecurityFilterChain <span style=color:#a6e22e>securityFilterChain</span>(HttpSecurity http) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> http
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>csrf</span>(csrf <span style=color:#f92672>-&gt;</span> csrf.<span style=color:#a6e22e>disable</span>()) <span style=color:#75715e>// (1)</span>
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>authorizeRequests</span>( auth <span style=color:#f92672>-&gt;</span> auth
</span></span><span style=display:flex><span>                        .<span style=color:#a6e22e>anyRequest</span>().<span style=color:#a6e22e>authenticated</span>() <span style=color:#75715e>// (2)</span>
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>sessionManagement</span>(session <span style=color:#f92672>-&gt;</span> session.<span style=color:#a6e22e>sessionCreationPolicy</span>(SessionCreationPolicy.<span style=color:#a6e22e>STATELESS</span>)) <span style=color:#75715e>// (3)</span>
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>httpBasic</span>(Customizer.<span style=color:#a6e22e>withDefaults</span>()) <span style=color:#75715e>// (4)</span>
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li>禁用跨站点请求伪造 (CSRF)</li><li>应针对应用程序中的任何请求对用户进行身份验证。</li><li>Spring Security 永远不会创建 HttpSession，也永远不会使用它来获取安全上下文。</li><li>Spring Security 的 HTTP 基本身份验证支持默认启用。但是，一旦提供任何基于 servlet 的配置，就必须显式提供 HTTP Basic。</li></ol><p>⚠️ 警告：在启用会话管理的同时，切勿禁用 CSRF 保护！这样做会使您面临跨站点请求伪造攻击。</p><p>现在您已经有了自定义安全配置，您需要一个不是 Spring Boot 提供的默认用户的用户。以下配置将使用 <code>NoOpPasswordEncoder</code> 创建内存中用户。这是一个密码编码器，不执行任何操作，对于测试很有用，但不应在生产中使用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> InMemoryUserDetailsManager <span style=color:#a6e22e>users</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> InMemoryUserDetailsManager(
</span></span><span style=display:flex><span>            User.<span style=color:#a6e22e>withUsername</span>(<span style=color:#e6db74>&#34;dvega&#34;</span>)
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>password</span>(<span style=color:#e6db74>&#34;{noop}password&#34;</span>)
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>authorities</span>(<span style=color:#e6db74>&#34;read&#34;</span>)
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>build</span>()
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>配置新用户后，您应该能够重新启动应用程序并访问 http://localhost:8080。您将看到一个对话框，要求输入用户名和密码，如果一切正常，您应该能够使用 <code>dvega</code> + <code>password</code> 登录。</p><p><img src=/images/http-basic-auth.webp alt="Spring Security HTTP Basic"></p><h2 id=oauth-20-资源服务器>OAUTH 2.0 资源服务器</h2><p>如果您看过我之前的教程，那么您到目前为止所做的一切应该很熟悉，但我知道这不是您来这里的目的。 Spring Security 支持使用两种形式的 OAuth 2.0 不记名令牌保护端点：</p><ul><li>JWT</li><li>Opaque Tokens</li></ul><p>在应用程序将其权限管理委托给<a href=https://tools.ietf.org/html/rfc6749 target=_blank>授权服务器</a>（例如，Okta 或 <a href=https://spring.io/projects/spring-authorization-server target=_blank>Spring 授权服务器</a>）的情况下，这非常方便。资源服务器可以咨询该授权服务器来授权请求 ​​。</p><p>在本教程中，您将使用自签名 JWT，这将无需引入授权服务器。虽然这适用于本示例，但您的应用程序要求可能有所不同，因此什么时候不再接受使用自签名 JWT？我也向 Spring Security 团队提出了这个问题，并得到了一些非常好的答案。</p><blockquote><p>当您达到无法接受自签名 JWT 的权衡时。一个例子可能是您想要引入刷新令牌的时刻。</p></blockquote><blockquote><p>我想补充一点，当您拥有多个服务或者您希望能够强化安全性时，不同的授权服务器更有意义（隔离像身份验证这样重要的东西可以提供价值，因为攻击面减少了）</p></blockquote><p>我们可能会花很多时间讨论授权和资源服务器。为了让本教程围绕这个主题，我将给您留下一些非常好的资源，我建议您在有时间时阅读它们。</p><ul><li><a href=https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/index.html target=_blank>OAuth2 Resource Server</a></li><li><a href=https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/jwt.html target=_blank>OAuth2 Resource Server JWT</a></li><li><a href=https://spring.io/projects/spring-authorization-server target=_blank>Spring Authorization Server</a></li></ul><h3 id=oauth-2-资源服务器配置>OAUTH 2 资源服务器配置</h3><p>现在您已经知道什么是资源服务器以及它的用途，您需要配置一个。您可以通过设置 <code>.oauth2ResourceServer()</code> 在安全配置中执行此操作。这可以是自定义资源服务器配置器，或者您可以使用 Spring 提供的 <code>OAuth2ResourceServerConfigurer</code> 类。</p><p><code>OAuth2ResourceServerConfigurer</code> 是 OAuth 2.0 资源服务器支持的 <code>AbstractHttpConfigurer</code> 。默认情况下，这会连接一个 <code>BearerTokenAuthenticationFilter</code> ，它可用于解析对承载令牌的请求并进行身份验证尝试。</p><p>该配置类有以下可用选项：</p><ul><li><code>accessDeniedHandler</code> - 自定义处理拒绝访问错误的方式。</li><li><code>authenticationEntryPoint</code> - 自定义如何处理身份验证失败。</li><li><code>bearerTokenResolver</code> - 自定义如何从请求中解析承载令牌。</li><li><code>jwt</code>(Customizer) - 启用 Jwt 编码的不记名令牌支持。</li><li><code>opaqueToken</code>(Customizer) -启用不透明的不记名令牌支持。</li></ul><p>您将使用 JWT，因此配置选项可以使用方法引用，并且看起来像 <code>OAuth2ResourceServerConfigurer::jwt</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> SecurityFilterChain <span style=color:#a6e22e>securityFilterChain</span>(HttpSecurity http) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> http
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>csrf</span>(csrf <span style=color:#f92672>-&gt;</span> csrf.<span style=color:#a6e22e>disable</span>())
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>authorizeRequests</span>( auth <span style=color:#f92672>-&gt;</span> auth
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>anyRequest</span>().<span style=color:#a6e22e>authenticated</span>()
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>oauth2ResourceServer</span>(OAuth2ResourceServerConfigurer::jwt)
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>sessionManagement</span>(session <span style=color:#f92672>-&gt;</span> session.<span style=color:#a6e22e>sessionCreationPolicy</span>(SessionCreationPolicy.<span style=color:#a6e22e>STATELESS</span>))
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>httpBasic</span>(withDefaults())
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当您使用 JWT 定制器时，您需要提供以下其中一项：</p><ul><li>通过 <code>OAuth2ResourceServerConfigurer.JwtConfigurer.jwkSetUri</code> 提供 Jwk Set Uri</li><li>通过 <code>OAuth2ResourceServerConfigurer.JwtConfigurer.decoder</code> 提供 JwtDecoder 实例</li><li>公开 JwtDecoder bean。</li></ul><p>如果您尝试运行该应用程序而不提供上述选项之一，您将收到以下错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Description:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Parameter 0 of method setFilterChains in
</span></span><span style=display:flex><span>org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration
</span></span><span style=display:flex><span>required a bean of type &#39;org.springframework.security.oauth2.jwt.JwtDecoder&#39; that could not be found.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Action:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Consider defining a bean of type &#39;org.springframework.security.oauth2.jwt.JwtDecoder&#39;
</span></span><span style=display:flex><span>in your configuration.
</span></span></code></pre></div><h3 id=签署-json-网络令牌>签署 JSON 网络令牌</h3><p>下一步是创建一个新的 <code>JwtDecoder</code> bean，但我认为我们需要讨论一下我们将在这里做什么。正如您之前了解到的，JWT 由 3 个部分组成：标头、有效负载和签名。签名是通过加密标头+有效负载和秘密（或私钥）来创建的。</p><p>JWT 可以使用对称密钥（共享密钥）或非对称密钥（私有-公共对的私有密钥）进行加密。</p><ul><li>对称密钥：相同的密钥用于加密（创建 JWT 时）和解密（MobileTogether Server 使用该密钥来验证 JWT）。对称密钥（也称为共享密钥）作为设置存储在 MobileTogether Server 中。有关使用对称密钥的详细信息，请参阅对称密钥：共享密钥。</li><li>非对称密钥：加密（私钥）和解密（公钥）使用不同的密钥。公钥作为设置存储在 MobileTogether 服务器中，以便可以验证 JWT。有关对 JWT 使用非对称加密的信息，请参阅非对称密钥：公钥。</li></ul><p>每种方法都有优点/缺点，但通常建议您使用非对称密钥，因此这就是您在此处采用的方法。</p><h3 id=公钥和私钥>公钥和私钥</h3><p>您将创建一个公钥/私钥对。您可以通过代码来完成此操作，但我认为如果您在这里手动执行此操作可能会更有意义。我将在 <code>/src/main/rescurces/certs</code> 下的新文件夹中创建它们。我将使用默认安装在 macOS 上的 OpenSSL，但您应该能够在您使用的任何操作系统上安装它。</p><p>通常情况下，您可以运行前两个命令。第三条命令的原因是私钥需要采用 PEM 编码的 PKCS#8 格式。切换到该 certs 目录并分别运行以下每个命令。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># create rsa key pair</span>
</span></span><span style=display:flex><span>openssl genrsa -out keypair.pem <span style=color:#ae81ff>2048</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># extract public key</span>
</span></span><span style=display:flex><span>openssl rsa -in keypair.pem -pubout -out public.pem
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># create private key in PKCS#8 format</span>
</span></span><span style=display:flex><span>openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out private.pem
</span></span></code></pre></div><p>如果一切运行没有错误并且您同时拥有公钥和私钥，则可以删除 <code>keypair.pem</code></p><h3 id=jwtdecoder>JWTDECODER</h3><p>公钥和私钥就位后，您可以将注意力集中到定义 <code>JwtDecoder</code> bean 上。首先，在 <code>config</code> 包中创建一个名为 <code>RsaKeyProperties</code> 的新记录类，这将用于外部化公钥和私钥。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@ConfigurationProperties</span>(prefix <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;rsa&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>record</span> <span style=color:#a6e22e>RsaKeyProperties</span>(RSAPublicKey publicKey, RSAPrivateKey privateKey) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果您运行构建并打开 <code>application.properties</code> ，您应该获得私钥和公钥配置的 IntelliSense。添加以下配置，以便您的应用程序可以找到您的密钥。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>rsa.private-key<span style=color:#f92672>=</span>classpath:certs/private.pem
</span></span><span style=display:flex><span>rsa.public-key<span style=color:#f92672>=</span>classpath:certs/public.pem
</span></span></code></pre></div><p>接下来，您需要在主类上启用配置属性：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@SpringBootApplication</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@EnableConfigurationProperties</span>(RsaKeyProperties.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JwtDemoApplication</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>		SpringApplication.<span style=color:#a6e22e>run</span>(JwtDemoApplication.<span style=color:#a6e22e>class</span>, args);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>回到 <code>SecurityConfig</code> ，您可以获取自动装配的实例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Configuration</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@EnableWebSecurity</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SecurityConfig</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> RsaKeyProperties rsaKeys;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>SecurityConfig</span>(RsaKeyProperties rsaKeys) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>rsaKeys</span> <span style=color:#f92672>=</span> rsaKeys;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>现在您可以使用公钥创建 <code>JwtDecoder</code> 。这是您通常需要引入第三方库的事情，但您不需要这样做。资源服务器为您带来的依赖项之一是 ``spring-security-oauth2-jose`，它包含一个名为 Nimbus Jose JWT 的库。您可以使用刚刚创建的公钥返回 Nimbus JWT 解码器。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>JwtDecoder <span style=color:#a6e22e>jwtDecoder</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> NimbusJwtDecoder.<span style=color:#a6e22e>withPublicKey</span>(rsaKeys.<span style=color:#a6e22e>publicKey</span>()).<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>此时，您应该能够运行该应用程序而不会出现任何错误。</p><h2 id=身份验证控制器和令牌服务>身份验证控制器和令牌服务</h2><p>您已准备好密钥并定义了解码器，这是一种破译 JWT 的方法。如果您还记得之前的架构图，用户将需要使用用户名和密码登录。如果他们通过身份验证，您将生成一个新的 JSON Web 令牌并将其在响应中发回。</p><p><img src=/images/app-arch-jwt-02.webp alt="Application Architecture: JSON Web Token (JWT)"></p><p>为此，您首先需要创建一个 <code>JwtEncoder</code> 类型的 bean，并且可以在 <code>SecurityConfig</code> 中执行此操作。编码器将用于将我们之前了解的签名编码为令牌，并使用我们的私钥对其进行签名。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>JwtEncoder <span style=color:#a6e22e>jwtEncoder</span>() {
</span></span><span style=display:flex><span>    JWK jwk <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> RSAKey.<span style=color:#a6e22e>Builder</span>(rsaKeys.<span style=color:#a6e22e>publicKey</span>()).<span style=color:#a6e22e>privateKey</span>(rsaKeys.<span style=color:#a6e22e>privateKey</span>()).<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>    JWKSource<span style=color:#f92672>&lt;</span>SecurityContext<span style=color:#f92672>&gt;</span> jwks <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ImmutableJWKSet<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#66d9ef>new</span> JWKSet(jwk));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> NimbusJwtEncoder(jwks);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>您可以直接在身份验证控制器中使用编码器，但我觉得您应该将其提取到服务层。在名为 <code>service</code> 的新包中创建一个名为 <code>TokenService</code> 的新类，该类将使用新的 <code>JwtEncoder</code> 生成令牌。在以下示例中，令牌将在 1 小时后过期，但您可以调整它以满足您的需要。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TokenService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> JwtEncoder encoder;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>TokenService</span>(JwtEncoder encoder) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>encoder</span> <span style=color:#f92672>=</span> encoder;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>generateToken</span>(Authentication authentication) {
</span></span><span style=display:flex><span>        Instant now <span style=color:#f92672>=</span> Instant.<span style=color:#a6e22e>now</span>();
</span></span><span style=display:flex><span>        String scope <span style=color:#f92672>=</span> authentication.<span style=color:#a6e22e>getAuthorities</span>().<span style=color:#a6e22e>stream</span>()
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>map</span>(GrantedAuthority::getAuthority)
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>collect</span>(Collectors.<span style=color:#a6e22e>joining</span>(<span style=color:#e6db74>&#34; &#34;</span>));
</span></span><span style=display:flex><span>        JwtClaimsSet claims <span style=color:#f92672>=</span> JwtClaimsSet.<span style=color:#a6e22e>builder</span>()
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>issuer</span>(<span style=color:#e6db74>&#34;self&#34;</span>)
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>issuedAt</span>(now)
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>expiresAt</span>(now.<span style=color:#a6e22e>plus</span>(1, ChronoUnit.<span style=color:#a6e22e>HOURS</span>))
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>subject</span>(authentication.<span style=color:#a6e22e>getName</span>())
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>claim</span>(<span style=color:#e6db74>&#34;scope&#34;</span>, scope)
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>encoder</span>.<span style=color:#a6e22e>encode</span>(JwtEncoderParameters.<span style=color:#a6e22e>from</span>(claims)).<span style=color:#a6e22e>getTokenValue</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>接下来在 <code>controller</code> 包中创建一个名为 <code>AuthController</code> 的新控制器。这将包含一个 POST 方法，该方法将使用新的令牌服务为经过身份验证的用户生成令牌。正如您所看到的，有一些用于调试目的的日志记录，以便在开发中您将看到用户请求 JWT 和创建的令牌。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@RestController</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AuthController</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Logger LOG <span style=color:#f92672>=</span> LoggerFactory.<span style=color:#a6e22e>getLogger</span>(AuthController.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> TokenService tokenService;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>AuthController</span>(TokenService tokenService) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>tokenService</span> <span style=color:#f92672>=</span> tokenService;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/token&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>token</span>(Authentication authentication) {
</span></span><span style=display:flex><span>        LOG.<span style=color:#a6e22e>debug</span>(<span style=color:#e6db74>&#34;Token requested for user: &#39;{}&#39;&#34;</span>, authentication.<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span>        String token <span style=color:#f92672>=</span> tokenService.<span style=color:#a6e22e>generateToken</span>(authentication);
</span></span><span style=display:flex><span>        LOG.<span style=color:#a6e22e>debug</span>(<span style=color:#e6db74>&#34;Token granted: {}&#34;</span>, token);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> token;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果一切都正确完成，您应该能够毫无错误地启动您的应用程序。</p><h2 id=spring-安全测试>SPRING 安全测试</h2><p>这样，您应该使用 JWT 保护您的根路径。现在您只需要测试一下即可。</p><h3 id=手动测试>手动测试</h3><p>您可以通过多种方法手动测试这一点，但在本教程中，我将向您展示 2.</p><p><strong>Postman</strong></p><p>测试这一点的一个简单方法是使用 Postman 等工具。如果您向令牌端点创建新的 POST 请求，您可以从“授权”选项卡中选择“基本身份验证”并输入您的凭据。如果一切正常，您将在响应中返回生成的 JWT。</p><p><img src=/images/postman-basic-auth.webp alt="Postman Basic Auth"></p><p>复制 JWT 并为 http://localhost:8080 创建新的 GET 请求。转到“授权”选项卡并选择“承载令牌”并粘贴生成的令牌。如果您发送请求，您应该取回从 <code>HomeController</code> 中的 home 方法返回的字符串。</p><p><img src=/images/postman-with-jwt-response.webp alt="Postman with JWT Response"></p><p><strong>命令行</strong></p><p>我非常喜欢命令行和 <a href=https://httpie.io/ target=_blank>httpie</a> 工具。它简化了在终端中测试 API 的命令的编写。您可以使用以下命令使用您的凭据向令牌端点发送请求：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>http POST :8080/token --auth dvega:password -v
</span></span></code></pre></div><p><code>-v</code> 参数将打印请求和响应</p><p><img src=/images/httpie-auth.webp alt="Httpie with Authorization"></p><p>响应将包含生成的 JWT 令牌。如果您在没有授权标头或没有正确令牌的情况下向根路径发出请求，您将收到 401（拒绝）响应。但是，如果您以正确的格式包含 Authorization 标头，您将获得从 <code>HomeController</code> 中的 home 方法返回的字符串。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>http :8080 <span style=color:#e6db74>&#39;Authorization: Bearer JWT_TOKEN_HERE&#39;</span>
</span></span></code></pre></div><p><img src=/images/httpie-success.webp alt="Httpie Response Success"></p><h3 id=自动化测试>自动化测试</h3><p>手动测试很棒，因为您可以看到一切都按预期运行。但是，您将需要一些适当的自动化测试，以便在进行更改时您可以确信没有任何内容破坏现有功能。我不会对此进行过多讨论，但我想为您提供一个简单的示例来说明如何编写此类测试。</p><p>当您引入资源服务器时，有一个依赖项没有引入，那就是 <code>spring-security-test</code> 。在编写任何与安全相关的测试之前，您需要将其添加到您的 <code>pom.xml</code> 中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.security<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;artifactId&gt;</span>spring-security-test<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>当您编写仅关注 Web 层配置的切片测试时，服务类将不会添加到应用程序上下文中。为了使一切正常工作，您需要手动导入 <code>SercurityConfig</code> 和 <code>TokenService</code> 类。这些测试应该是不言自明的，但如果您希望我进行这些测试，请联系我并告诉我。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@WebMvcTest</span>({HomeController.<span style=color:#a6e22e>class</span>, AuthController.<span style=color:#a6e22e>class</span>})
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Import</span>({SecurityConfig.<span style=color:#a6e22e>class</span>, TokenService.<span style=color:#a6e22e>class</span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HomeControllerTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    MockMvc mvc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>rootWhenUnauthenticatedThen401</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mvc</span>.<span style=color:#a6e22e>perform</span>(get(<span style=color:#e6db74>&#34;/&#34;</span>))
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>andExpect</span>(status().<span style=color:#a6e22e>isUnauthorized</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>rootWhenAuthenticatedThenSaysHelloUser</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        MvcResult result <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mvc</span>.<span style=color:#a6e22e>perform</span>(post(<span style=color:#e6db74>&#34;/token&#34;</span>)
</span></span><span style=display:flex><span>                        .<span style=color:#a6e22e>with</span>(httpBasic(<span style=color:#e6db74>&#34;dvega&#34;</span>, <span style=color:#e6db74>&#34;password&#34;</span>)))
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>andExpect</span>(status().<span style=color:#a6e22e>isOk</span>())
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>andReturn</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        String token <span style=color:#f92672>=</span> result.<span style=color:#a6e22e>getResponse</span>().<span style=color:#a6e22e>getContentAsString</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mvc</span>.<span style=color:#a6e22e>perform</span>(get(<span style=color:#e6db74>&#34;/&#34;</span>)
</span></span><span style=display:flex><span>                        .<span style=color:#a6e22e>header</span>(<span style=color:#e6db74>&#34;Authorization&#34;</span>, <span style=color:#e6db74>&#34;Bearer &#34;</span> <span style=color:#f92672>+</span> token))
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>andExpect</span>(content().<span style=color:#a6e22e>string</span>(<span style=color:#e6db74>&#34;Hello, dvega&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@WithMockUser</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>rootWithMockUserStatusIsOK</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mvc</span>.<span style=color:#a6e22e>perform</span>(get(<span style=color:#e6db74>&#34;/&#34;</span>)).<span style=color:#a6e22e>andExpect</span>(status().<span style=color:#a6e22e>isOk</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=结论>结论</h2><p>当我开始创建本教程时，我的全部目标是让您知道有一种更简单的方法可以使用 JWT 来保护您的 API。我希望现在您知道 Spring Security 使用 oAuth2 资源服务器内置了对 JSON Web 令牌的支持，您可以在下一个项目中使用它。这只是如何在 Spring Boot 应用程序中使用 JWT 的起跑线，绝不是终点线。如果您对具体配置有疑问，请<a href=https://twitter.com/therealdanvega target=_blank>与我联系</a>。</p><p>我感到非常幸运，能够在 VMware 这样的公司工作，并且能够接触到一些非常聪明的人。当您与一群总是愿意分享知识和提供帮助的优秀人士一起工作时，这种访问就意味着更重要。我要特别感谢以下帮助我将这些内容整合在一起的人：</p><ul><li>Steve Riesenberg</li><li>Rob Winch</li><li>Josh Cummings</li><li>Toshiaki Maki</li></ul></div><div><div style=font-weight:700>Share this post:</div><a class=social-link-item href="https://twitter.com/intent/tweet?text=%5b%e8%af%91%5d%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8Spring%20Security%e5%92%8cJWT%e4%bf%9d%e6%8a%a4%e6%82%a8%e7%9a%84REST%20API https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f09%2f19%2fspring-security-jwt%2f" target=_blank rel="noopener noreferrer" title="Click to share on Twitter"><i class="fa-brands fa-square-twitter fa-2xl" style=color:#55acee></i>
</a><a class=social-link-item href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f09%2f19%2fspring-security-jwt%2f&title=%5b%e8%af%91%5d%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8Spring%20Security%e5%92%8cJWT%e4%bf%9d%e6%8a%a4%e6%82%a8%e7%9a%84REST%20API" target=_blank rel="noopener noreferrer" title="Click to share on LinkedIn"><i class="fa-brands fa-linkedin fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://telegram.me/share/url?text=%5b%e8%af%91%5d%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8Spring%20Security%e5%92%8cJWT%e4%bf%9d%e6%8a%a4%e6%82%a8%e7%9a%84REST%20API&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f09%2f19%2fspring-security-jwt%2f" target=_blank rel="noopener noreferrer" title="Click to share on telegram"><i class="fa-brands fa-telegram fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f09%2f19%2fspring-security-jwt%2f&title=%5b%e8%af%91%5d%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8Spring%20Security%e5%92%8cJWT%e4%bf%9d%e6%8a%a4%e6%82%a8%e7%9a%84REST%20API" target=_blank rel="noopener noreferrer" title="Click to share on reddit"><i class="fa-brands fa-reddit fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f09%2f19%2fspring-security-jwt%2f" target=_blank rel="noopener noreferrer" title="Click to share on facebook"><i class="fa-brands fa-facebook fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://api.whatsapp.com/send?text=%5b%e8%af%91%5d%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8Spring%20Security%e5%92%8cJWT%e4%bf%9d%e6%8a%a4%e6%82%a8%e7%9a%84REST%20API%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f09%2f19%2fspring-security-jwt%2f" target=_blank rel="noopener noreferrer" title="Click to share on whatsapp"><i class="fa-brands fa-whatsapp fa-2xl" style=color:#007bb5></i></a></div></div></article><nav class="navigation post-navigation" role=navigation><h2 class=screen-reader-text>Post navigation</h2><div class=nav-links><div class=nav-previous><a href=/posts/2023/09/19/spring-security-tutorial/ rel=next><span class=post-title>[译]Spring Security 与 JWT for REST API</span></a></div><div class=nav-next><a href=/posts/2023/08/25/global-error-handler-in-a-spring-rest-api/ rel=prev><span class=post-title>[译]REST API 的自定义错误消息处理</span></a></div></div></nav><h2>Related content</h2><ul><li><a href=/posts/2023/10/13/new-features-in-spring-boot-3-and-spring-6/>[译]Spring Boot3和Spring6中的新特性</a></li><li><a href=/posts/2023/10/12/spring-security-interview-questions/>[译]Spring Security 面试问题</a></li><li><a href=/posts/2023/09/19/spring-security-tutorial/>[译]Spring Security 与 JWT for REST API</a></li><li><a href=/posts/2023/08/25/global-error-handler-in-a-spring-rest-api/>[译]REST API 的自定义错误消息处理</a></li><li><a href=/posts/2023/08/25/spring-events/>[译]Spring Events</a></li><li><a href=/posts/2023/08/25/spring-security-async-principal-propagation/>[译]使用@Async进行Spring Security上下文传播</a></li><li><a href=/posts/2023/08/25/exception-handling-for-rest-with-spring/>[译]使用Spring进行REST的错误处理</a></li><li><a href=/posts/2023/08/25/spring-async/>[译]如何在Spring中执行@Async</a></li><li><a href=/posts/2023/08/18/how-to-implement-jwt-authentication-in-spring-boot-project/>[译]Spring Boot项目如何实现JWT认证？</a></li><li><a href=/posts/2023/08/18/how-to-implement-security-in-spring-boot-project/>[译]Spring Boot项目如何实现Security？</a></li></ul></main></section></div><div id=footer class=footer-wrap><footer id=colophon class="site-footer container clearfix" role=contentinfo><div id=footer-text class=site-info><span class=credit-link>Made with 🩷
by <a href=/ target=_blank rel="noopener noreferrer">ChenSoul</a></span></div></footer></div></div><script type=text/javascript src=/main.min.js></script></body></html>