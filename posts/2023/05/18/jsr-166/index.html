<!doctype html><html lang=en-US prefix="og: http://ogp.me/ns#"><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="JSR 介绍
JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 JSR 335，新的日期和时间 API 对应的是 JSR 310。"><title>JSR 166规范 | ChenSoul</title><link rel=canonical href=https://blog.chensoul.cc/posts/2023/05/18/jsr-166/><link rel=preconnect href=https://fonts.font.im><link rel=preconnect href=https://fonts.loli.net crossorigin><link href="https://fonts.loli.net/css2?family=Roboto+Slab:wght@400;500;700&display=swap" rel=stylesheet><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.chensoul.cc/images/favicon.webp"><meta name=twitter:title content="JSR 166规范"><meta name=twitter:description content="JSR 介绍 JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 JSR 335，新的日期和时间 API 对应的是 JSR 310。"><meta name=twitter:creator content="@ichensoul"><meta property="og:locale" content="en_US"><meta property="og:site_name" content="chensoul"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/05/18/jsr-166/"><meta property="og:site_name" content="ChenSoul"><meta property="og:title" content="JSR 166规范"><meta property="og:description" content="JSR 介绍 JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 JSR 335，新的日期和时间 API 对应的是 JSR 310。"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-18T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-18T00:00:00+00:00"><meta property="article:tag" content="Java"><meta property="og:image" content="https://blog.chensoul.cc/images/favicon.webp"><meta itemprop=name content="JSR 166规范"><meta itemprop=description content="JSR 介绍 JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 JSR 335，新的日期和时间 API 对应的是 JSR 310。"><meta itemprop=datePublished content="2023-05-18T00:00:00+00:00"><meta itemprop=dateModified content="2023-05-18T00:00:00+00:00"><meta itemprop=wordCount content="664"><meta itemprop=image content="https://blog.chensoul.cc/images/favicon.webp"><meta itemprop=keywords content="Java"><link rel=stylesheet href=https://cdnjs.loli.net/ajax/libs/font-awesome/6.4.0/css/all.min.css media=all><link rel=stylesheet href=/main.min.css type=text/css media=all><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"TechArticle","name":"JSR 166规范","headline":"JSR 166规范","inLanguage":"en-US","url":"https://blog.chensoul.cc/posts/2023/05/18/jsr-166/","description":"\u003ch2 id=\"jsr-介绍\"\u003eJSR 介绍\u003c/h2\u003e\n\u003cp\u003eJSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 \u003ca href=\"http://jcp.org/en/jsr/detail?id=335\" target=\"_blank\"\u003eJSR 335\u003c/a\u003e，新的日期和时间 API 对应的是 \u003ca href=\"http://jcp.org/en/jsr/detail?id=310\" target=\"_blank\"\u003eJSR 310\u003c/a\u003e。\u003c/p\u003e","wordCount":"664","keywords":["java"],"datePublished":"2023-05-18T00:00:00Z","dateModified":"2023-05-18T00:00:00Z","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2023/05/18/jsr-166/"},"publisher":{"@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/posts/2023/05/18/jsr-166/"}},{"@context":"https://schema.org","@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/","sameAs":["https://x.com/ichensoul","https://github.com/chensoul","https://www.linkedin.com/in/","https://www.youtube.com/@chensoul","https://t.me/chensouls"]}]}</script><script defer src=https://umami.chensoul.cc/random-string.js data-website-id=4718b57b-c900-4a61-a7af-0fe1fb1d50ce></script></head><body class="home blog post-layout-one-column"><button onclick=topFunction() id=scrollTopBtn title="Go to top">
<i class="fa-solid fa-arrow-up"></i></button><div id=header-top class=header-bar-wrap></div><div id=page class=site><a class="skip-link screen-reader-text" href=#content>Skip to content</a><header id=masthead class="site-header clearfix" role=banner><div class="header-main container clearfix"><div id=logo class="site-branding clearfix"><h1 class=site-title><a href=/ title=ChenSoul rel=home>ChenSoul</a></h1><p class=site-description>Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials</p></div><div class="header-widgets clearfix"><aside id=search-2 class="header-widget widget_search"><form role=search method=get class=search-form onsubmit="return searchSite(event)"><label><span class=screen-reader-text>Search for:</span>
<input type=search class=search-field placeholder="Enter search keyword" name=query id=query title="Enter search keyword">
</label><button type=submit class=search-submit title=Search> <span class=genericon-search></span>
<span class=screen-reader-text>Search</span></button></form></aside></div></div><div id=main-navigation-wrap class=primary-navigation-wrap><nav id=main-navigation class="primary-navigation navigation container clearfix" role=navigation><ul id=menu-home class=main-navigation-menu><li class="menu-item menu-item-type-custom menu-item-object-custom
current-menu-item current_page_item menu-item-home"><a href=/>Home</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/spring-boot/>Spring Boot</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/architecture/>Architecture</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/microservice/>Microservice</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/kubernetes/>Kubernetes</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category
menu-item-has-children"><a href=/tutorials/>Tutorials</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/spring-boot-tutorials/>Spring Boot Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/microservice-tutorials/>Microservice Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/kubernetes-tutorials/>Kubernetes Tutorials</a></li></ul></li><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=https://github.com/chensoul target=_blank>About Me</a></li></ul></nav></div></header><div id=content class="site-content container clearfix"><section id=primary class="content-archive content-area post-content-area"><main id=main class=site-main role=main><article class="post type-post"><div class=post-inner-content><header class=entry-header><h2 class=entry-title><a href=https://blog.chensoul.cc/posts/2023/05/18/jsr-166/ rel=bookmark title="JSR 166规范">JSR 166规范</a></h2><div class=entry-meta><span class=meta-date><time class="entry-date published" datetime=2023-05-18T00:00:00>2023-05-18
</time></span><span class=meta-author><span class="author vcard">chensoul</span>
</span><span class="tagcloud post-tags"><i class="fa fa-tags"></i>&nbsp;
<a class="tag-cloud-link widget__link widget__link--taglist" href=/tags/java/ title=java>java</a></span></div></header><div class=entry-content><h2 id=jsr-介绍>JSR 介绍</h2><p>JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 <a href="http://jcp.org/en/jsr/detail?id=335" target=_blank>JSR 335</a>，新的日期和时间 API 对应的是 <a href="http://jcp.org/en/jsr/detail?id=310" target=_blank>JSR 310</a>。</p><p><a href="https://jcp.org/en/jsr/detail?id=166" target=_blank>JSR 166</a> 是 Doug Lea 提出的一个关于 Java 并发编程的规范提案。JDK1.5 之前，我们控制程序并发访问同步代码只能使用 synchronized，那个时候 synchronized 的性能还没优化好，性能并不好，控制线程也只能使用 Object 的 wait 和 notify 方法。这个时候 Doug Lea 给 JCP 提交了 JSR-166 的提案，在提交 JSR-166 之前，Doug Lea 已经使用了类似 J.U.C 包功能的代码已经三年多了，这些代码就是 J.U.C 的原型。</p><p>J.U.C，即 <code>java.util.concurrent</code> 的缩写，该包参考自 EDU.oswego.cs.dl.util.concurrent，是 JSR 166 标准规范的一个实现。</p><ul><li>Doug Lea 主页：<a href=https://gee.cs.oswego.edu/ target=_blank>Doug Lea&rsquo;s Home Page</a></li><li>JSR-166：<a href=https://gee.cs.oswego.edu/dl/concurrency-interest/index.html target=_blank>Concurrency JSR-166 Interest Site</a></li><li>JSR 166 Slider：<a href=https://gee.cs.oswego.edu/dl/concurrency-interest/jsr166-slides.pdf target=_blank>JSR-166: Concurrency Utilities</a></li><li>java.util.concurrent JavaDoc: <a href=https://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/package-summary.html target=_blank>JDK 1.5 </a>、 <a href=https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html target=_blank>JDK 7 </a>、 <a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html target=_blank>JDK 8 </a>、 <a href=https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/package-summary.html target=_blank>JDK 9</a></li></ul><p><img src=../../../static/images/jsr-166-concurrency-utilities.webp alt=jsr-166-concurrency-utilities></p><p>JSR-166 包括多个规范，每个规范都引入了一些新的接口和类，以下是详细描述：</p><ol><li><code>JSR-166（Java SE 5）</code>：定义了 Java 并发包的核心接口和类，包括 Executors 框架、Queues、Timing、Synchronizers、Concurrent Collections、Memory Consistency Properties、Atomic、Locks 等。这些接口和类提供了一种方便、高效、可扩展的方式来处理异步任务和并发编程。</li><li><code>JSR-166x（Java SE 7）</code>：定义了 Java 并发包中的一些新特性，包括 Phaser、TransferQueue、Exchanger、LinkedTransferQueue 等接口和类。其中 Phaser 支持分阶段执行任务，TransferQueue 和 LinkedTransferQueue 实现了高效的生产者-消费者模式，Exchanger 支持两个线程之间交换数据。</li><li><code>JSR-166y（Java SE 8）</code>：定义了 Java 并发包中的一些新特性，包括 StampedLock、CompletableFuture、LongAdder 等接口和类。其中 StampedLock 是一种乐观锁，支持读写分离，CompletableFuture 支持异步任务执行和结果处理，LongAdder 是一种高效的计数器。</li><li><code>JSR-166z（Java SE 9）</code>：定义了 Java 并发包中的一些新特性，包括 VarHandle、Fences 等接口和类。其中 VarHandle 提供了一种更加灵活的原子操作方式，Fences 提供了一些方法用于控制内存屏障。</li></ol><h2 id=juc>JUC</h2><p>java.util.concurrent 包下的类以及引入版本（没有标注版本号的为 <code>1.5</code> ）：</p><ul><li>java.util.concurrent<ul><li>java.util.concurrent.locks<ul><li>AbstractOwnableSynchronizer <code>1.6</code></li><li>AbstractQueuedLongSynchronizer <code>1.6</code></li><li>AbstractQueuedSynchronizer</li><li>Condition</li><li>Lock</li><li>LockSupport</li><li>ReadWriteLock</li><li>ReentrantLock</li><li>ReentrantReadWriteLock</li><li>StampedLock <code>1.8</code></li></ul></li><li>java.util.concurrent.atomic<ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicIntegerArray</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLong</li><li>AtomicLongArray</li><li>AtomicLongFieldUpdater</li><li>AtomicMarkableReference</li><li>AtomicReference</li><li>AtomicReferenceArray</li><li>AtomicReferenceFieldUpdater</li><li>AtomicStampedReference</li><li>DoubleAccumulator <code>1.8</code></li><li>DoubleAdder <code>1.8</code></li><li>LongAccumulator <code>1.8</code></li><li>LongAdder <code>1.8</code></li></ul></li><li>AbstractExecutorService</li><li>ArrayBlockingQueue</li><li>BlockingDeque <code>1.6</code></li><li>BlockingQueue</li><li>BrokenBarrierException</li><li>Callable</li><li>CancellationException</li><li>CompletableFuture <code>1.8</code></li><li>CompletionException <code>1.8</code></li><li>CompletionService</li><li>CompletionStage <code>1.8</code></li><li>ConcurrentHashMap</li><li>ConcurrentLinkedDeque <code>1.7</code></li><li>ConcurrentLinkedQueue</li><li>ConcurrentMap</li><li>ConcurrentNavigableMap <code>1.6</code></li><li>ConcurrentSkipListMap <code>1.6</code></li><li>ConcurrentSkipListSet <code>1.6</code></li><li>CopyOnWriteArrayList</li><li>CopyOnWriteArraySet</li><li>CountDownLatch</li><li>CountedCompleter <code>1.8</code></li><li>CyclicBarrier</li><li>Delayed</li><li>DelayQueue</li><li>Exchanger</li><li>ExecutionException</li><li>Executor</li><li>ExecutorCompletionService</li><li>Executors</li><li>ExecutorService</li><li>Flow <code>1.9</code></li><li>ForkJoinPool <code>1.7</code></li><li>ForkJoinTask <code>1.7</code></li><li>ForkJoinWorkerThread <code>1.7</code></li><li>Future</li><li>FutureTask</li><li>LinkedBlockingDeque <code>1.6</code></li><li>LinkedBlockingQueue</li><li>LinkedTransferQueue <code>1.7</code></li><li>Phaser <code>1.7</code></li><li>PriorityBlockingQueue</li><li>RecursiveAction <code>1.7</code></li><li>RecursiveTask <code>1.7</code></li><li>RejectedExecutionException</li><li>RejectedExecutionHandler</li><li>RunnableFuture</li><li>RunnableScheduledFuture</li><li>ScheduledExecutorService</li><li>ScheduledFuture</li><li>ScheduledThreadPoolExecutor</li><li>Semaphore</li><li>SubmissionPublisher <code>1.9</code></li><li>SynchronousQueue</li><li>ThreadFactory</li><li>ThreadLocalRandom <code>1.7</code></li><li>ThreadPoolExecutor</li><li>TimeoutException</li><li>TimeUnit</li><li>TransferQueue <code>1.7</code></li></ul></li></ul><p>大致可以分为以下几类：</p><ul><li>原子更新</li><li>锁和条件</li><li>线程池</li><li>并发容器</li><li>同步器</li></ul><p>在学习 <code>JUC</code> 之前我们需要了解 <code>CAS</code>，<code>AQS</code> 和 <code>Unsafe</code>。</p><ul><li>CAS：</li><li>AQS：</li><li>Unsafe：</li></ul><h2 id=cas>CAS</h2><p>CAS（<code>Compare and Swap</code>）是一种基于原子性操作的并发编程技术，常用于实现线程安全的数据结构和算法。CAS 操作由三个参数组成：内存位置 V、期望值 A、新值 B。当且仅当 V 的值等于 A 时，CAS 操作才会将 V 的值设置为 B，否则不做任何操作。它的实现原理可以简单概括为以下几个步骤：</p><ol><li>读取内存位置 V 的值，同时记录下该值的版本号或标记位。</li><li>检查内存位置 V 的值是否等于期望值 A。如果相等，则执行第 3 步；否则，操作失败。</li><li>将新值 B 写入内存位置 V，并更新其版本号或标记位。</li><li>返回操作结果。</li></ol><p>CAS 操作是一种<code>乐观锁</code>机制，它不需要锁定整个共享资源，而是只针对需要修改的值进行原子性操作，从而避免了锁的竞争和开销。在执行 CAS 操作时，线程会对内存位置进行读取和写入，但同时也会检查内存位置的版本号或标记位，以保证操作的原子性和一致性。</p><p>需要注意的是，如果多个线程同时执行 CAS 操作，可能会出现 ABA 问题。例如，线程 A 读取内存位置 V 的值为 A，然后线程 B 将 V 的值修改为 B，最后线程 B 又将 V 的值修改为 A。此时，线程 A 执行 CAS 操作时，会发现内存位置 V 的值还是 A，虽然这个 A 的版本号或标记位与之前不同，但线程 A 并不知道 V 的值曾经被修改过，因此会将新值写入内存位置 V，从而导致数据不一致。为了解决 ABA 问题，可以使用带有版本号或标记位的 CAS 操作，或者使用其他的并发编程技术，例如锁或读写锁。</p><p>Java 中的<code>AtomicXXX</code>类实现了 CAS 操作，例如 AtomicInteger、AtomicLong 等。这些类提供了一组原子性操作方法，例如 get()、set()、addAndGet()、compareAndSet()等，它们可以被多个线程安全地使用。</p><p>CAS 操作虽然免去了锁的开销，但也存在一些问题。首先，CAS 操作需要进行多次尝试，直到成功为止。如果并发程度较高，多个线程同时进行 CAS 操作，可能会导致大量的 CAS 操作失败，从而降低性能。其次，CAS 操作只能保证单个变量的原子性操作，无法保证多个变量之间的操作的原子性，因此需要额外的措施来保证多个变量之间的一致性。</p><p>下面是一个使用 AtomicInteger 实现简单计数器的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.atomic.AtomicInteger;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Counter</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> AtomicInteger value <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicInteger(0);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>increment</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> oldValue, newValue;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>            oldValue <span style=color:#f92672>=</span> value.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>            newValue <span style=color:#f92672>=</span> oldValue <span style=color:#f92672>+</span> 1;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>value.<span style=color:#a6e22e>compareAndSet</span>(oldValue, newValue));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getValue</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> value.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在上面的示例中，<code>increment()</code> 方法使用 do-while 循环和<code>compareAndSet()</code>方法执行 CAS 操作来增加计数器的值。该方法重复使用<code>get()</code>方法读取计数器的当前值，计算新值，然后尝试使用<code>compareAndSet()</code>方法更新计数器。循环将继续，直到 CAS 操作成功并且计数器成功更新。</p><p><code>getValue()</code> 方法使用<code>get()</code>方法简单地返回计数器的当前值。</p><p>需要注意的是，在使用 CAS 操作时，需要小心处理潜在的 ABA 问题，其中共享变量的值可能在初始读取和更新尝试之间多次更改。一种处理方法是在共享变量中使用版本号或时间戳，以确保更新仅在值未更改的情况下成功。</p><p>ABA 问题是在使用 CAS（<code>Compare-and-Swap</code>）操作进行并发编程时经常遇到的一个问题。它发生在一个线程从共享内存位置读取一个值，然后另一个线程将该值更改为另一个值，最后又将其更改回原始值，从而使第一个线程的操作意外成功。</p><p>为了处理 ABA 问题，常用的方法是在共享内存位置中添加一个版本号或时间戳。版本号或时间戳可以在每次修改内存位置时进行递增或更新。这可以确保 CAS 操作不仅检查值，还检查内存位置的版本号或时间戳。</p><p>以下是使用版本号处理 ABA 问题的示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.atomic.AtomicStampedReference;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConcurrentStack</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> AtomicStampedReference<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> top <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicStampedReference<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#66d9ef>null</span>, 0);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>push</span>(T value) {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> newHead <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;&gt;</span>(value);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> stampHolder <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> oldHead;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>            oldHead <span style=color:#f92672>=</span> top.<span style=color:#a6e22e>get</span>(stampHolder);
</span></span><span style=display:flex><span>            newHead.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> oldHead;
</span></span><span style=display:flex><span>            stampHolder<span style=color:#f92672>[</span>0<span style=color:#f92672>]++</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>top.<span style=color:#a6e22e>compareAndSet</span>(oldHead, newHead, stampHolder<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>-</span> 1, stampHolder<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> T <span style=color:#a6e22e>pop</span>() {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> oldHead;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> stampHolder <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>            oldHead <span style=color:#f92672>=</span> top.<span style=color:#a6e22e>get</span>(stampHolder);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (oldHead <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>top.<span style=color:#a6e22e>compareAndSet</span>(oldHead, oldHead.<span style=color:#a6e22e>next</span>, stampHolder<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>, stampHolder<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> 1));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> oldHead.<span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> T value;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> next;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Node</span>(T value) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在上面的示例中，<code>ConcurrentStack</code> 类使用 <code>AtomicStampedReference</code> 存储栈顶节点。<code>AtomicStampedReference</code> 类存储值的引用和版本号，版本号在引用更改时进行更新。</p><p><code>push()</code> 方法使用新值创建一个新的 <code>Node</code>，然后尝试使用 CAS 操作将其推入栈中。循环将继续，直到 CAS 操作成功，节点成功推入栈中。</p><p><code>pop()</code> 方法尝试使用 CAS 操作从栈中弹出顶部节点。循环将继续，直到顶部节点成功弹出或栈为空为止。</p><p>通过使用具有版本号的 <code>AtomicStampedReference</code>，<code>ConcurrentStack</code> 类可以处理在并发操作中可能发生的 ABA 问题。</p><h2 id=aqs>AQS</h2><p>AQS（<code>AbstractQueuedSynchronizer</code>）是 Java 中用于实现同步器（如锁，信号量等）的框架，它提供了一些基本的同步操作，例如<code>获取锁</code>、<code>释放锁</code>、<code>等待条件</code>、<code>唤醒线程</code>等。</p><p>AQS 的实现原理基于一个双向链表，用于维护等待线程的队列。当一个线程需要获取同步器时，它会首先尝试使用 CAS 操作来获取同步器，如果获取成功，则继续执行；如果获取失败，则将线程加入等待队列中，并将其挂起。当同步器释放时，它会唤醒等待队列中的一个或多个线程，并将它们从等待队列中移除，使它们可以继续执行。</p><p>AQS 的等待队列是通过一个双向链表来实现的，每个节点代表一个等待线程，节点中包含了线程的状态以及等待条件等信息。等待队列中的节点是按照等待时间的先后顺序排列的，先等待的线程排在前面，后等待的线程排在后面。当一个线程被唤醒时，它会重新尝试获取同步器，如果获取成功，则继续执行；如果获取失败，则它会再次加入等待队列中，并将自己挂起。</p><p>AQS 的具体实现是通过重写其内部的一些方法来实现的。例如，<code>tryAcquire()</code> 方法用于实现获取同步器的逻辑，它会首先尝试使用 CAS 操作来获取同步器，如果获取成功，则返回 true；否则返回 false。<code>tryRelease()</code> 方法用于实现释放同步器的逻辑，它会释放同步器，并唤醒等待队列中的一个或多个线程。<code>tryAcquireShared()</code> 和 <code>tryReleaseShared()</code> 方法则用于实现共享式同步器的逻辑，它们类似于 <code>tryAcquire()</code> 和 <code>tryRelease()</code> 方法，但是可以支持多个线程同时获取或释放同步器。</p><h2 id=unsafe>Unsafe</h2><p>Unsafe 类是 Java 中一个非常特殊且强大的类，它提供了一些不安全的操作，例如直接操作内存、线程挂起和恢复等。Unsafe 类是 Java 中少数几个不被公开支持的类之一，它主要被用于 Java 核心库和其他一些高级框架中，如 Netty、Hadoop 和 Kafka 等。</p><p>由于 Unsafe 类提供了一些不安全的操作，因此它的使用需要非常小心。如果不正确地使用 Unsafe 类，可能会导致程序崩溃或安全漏洞。因此，Java 官方并不建议开发人员使用 Unsafe 类，而是建议开发人员使用更加安全和标准的 Java API。</p><p>Unsafe 类中一些常用的方法包括：</p><ol><li><code>allocateMemory(long size)</code>：分配一段指定大小的内存空间。</li><li><code>freeMemory(long address)</code>：释放指定地址的内存空间。</li><li><code>putXXX(Object target, long offset, XXX value)</code>：将指定类型的值写入目标对象的指定偏移量处。</li><li><code>getXXX(Object target, long offset)</code>：从目标对象的指定偏移量处读取指定类型的值。</li><li><code>park(boolean isAbsolute, long time)</code>：挂起当前线程，直到被其他线程唤醒或指定的时间到期。</li><li><code>unpark(Thread thread)</code>：恢复指定线程的运行。</li></ol><p>需要注意的是，Unsafe 类中的大部分方法都是 native 方法，实现方式依赖于底层操作系统和硬件平台。这意味着 Unsafe 类中的方法在不同的平台上可能会有不同的行为，因此需要针对不同的平台进行测试和验证。</p><p>Java 9 中官方提出了移除 Sun.misc.Unsafe 类，并在该版本中将该类标记为不推荐使用。然而，由于 Unsafe 类在 Java 语言生态中的应用非常广泛，许多框架和库都依赖于 Unsafe 类来实现高性能和低层次的操作。因此，在 Java 9 中，官方引入了 jdk.internal.misc.Unsafe 类来替代 Sun.misc.Unsafe 类的功能，以保持对 Java 生态中使用 Unsafe 类的支持。</p></div><div><div style=font-weight:700>Share this post:</div><a class=social-link-item href="https://twitter.com/intent/tweet?text=JSR%20166%e8%a7%84%e8%8c%83 https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f18%2fjsr-166%2f" target=_blank rel="noopener noreferrer" title="Click to share on Twitter"><i class="fa-brands fa-square-twitter fa-2xl" style=color:#55acee></i>
</a><a class=social-link-item href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f18%2fjsr-166%2f&title=JSR%20166%e8%a7%84%e8%8c%83" target=_blank rel="noopener noreferrer" title="Click to share on LinkedIn"><i class="fa-brands fa-linkedin fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://telegram.me/share/url?text=JSR%20166%e8%a7%84%e8%8c%83&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f18%2fjsr-166%2f" target=_blank rel="noopener noreferrer" title="Click to share on telegram"><i class="fa-brands fa-telegram fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f18%2fjsr-166%2f&title=JSR%20166%e8%a7%84%e8%8c%83" target=_blank rel="noopener noreferrer" title="Click to share on reddit"><i class="fa-brands fa-reddit fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f18%2fjsr-166%2f" target=_blank rel="noopener noreferrer" title="Click to share on facebook"><i class="fa-brands fa-facebook fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://api.whatsapp.com/send?text=JSR%20166%e8%a7%84%e8%8c%83%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2023%2f05%2f18%2fjsr-166%2f" target=_blank rel="noopener noreferrer" title="Click to share on whatsapp"><i class="fa-brands fa-whatsapp fa-2xl" style=color:#007bb5></i></a></div></div></article><nav class="navigation post-navigation" role=navigation><h2 class=screen-reader-text>Post navigation</h2><div class=nav-links><div class=nav-previous><a href=/posts/2023/05/22/docker-continuous-integration/ rel=next><span class=post-title>[译]Build Robust Continuous Integration With Docker and Friends</span></a></div><div class=nav-next><a href=/posts/2023/05/18/weekly_review_19/ rel=prev><span class=post-title>周报-19｜武功山看日出、Python初学建议</span></a></div></div></nav><h2>Related content</h2><ul><li><a href=/posts/2023/12/14/all-things-about-microprofile/>All things about MicroProfile</a></li><li><a href=/posts/2023/11/02/jhipster-intro/>JHipster安装和介绍</a></li><li><a href=/posts/2025/06/06/oauth2-client-login-in-thingsboard/>Thingsboard源码中的OAuth2登录实现</a></li><li><a href=/posts/2025/04/30/codes-in-thingsboard/>Thingsboard源码中的代码片段</a></li><li><a href=/posts/2025/03/31/canal-install-test/>Canal原理、安装和测试</a></li><li><a href=/posts/2025/03/28/id-generator/>常见分布式 ID 解决方案</a></li><li><a href=/posts/2025/02/17/top-n-using-redis/>如何实现榜单 top N 统计</a></li><li><a href=/posts/2025/02/14/rate-limit/>什么是限流</a></li><li><a href=/posts/2025/02/14/retry-for-timeout/>区分偶发性超时和频繁超时的重试策略</a></li><li><a href=/posts/2024/12/03/github-actions-in-thingsboard/>ThingsBoard源码中的Github Actions</a></li></ul></main></section></div><div id=footer class=footer-wrap><footer id=colophon class="site-footer container clearfix" role=contentinfo><div id=footer-text class=site-info><span class=credit-link>Made with 🩷
by <a href=/ target=_blank rel="noopener noreferrer">ChenSoul</a></span></div></footer></div></div><script type=text/javascript src=/main.min.js></script></body></html>