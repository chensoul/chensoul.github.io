<!doctype html><html class=no-js lang=zh-cn><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>JSR 166规范 - Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="JSR 166规范"><meta property="og:description" content="Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2023/05/18/jsr-166/"><meta property="og:site_name" content="ChenSoul Blog"><meta property="og:image" content><meta itemprop=name content="JSR 166规范"><meta itemprop=description content="JSR 介绍 JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 JSR 335，新的日期和时间 API 对应的是 JSR 310。"><meta itemprop=datePublished content="2023-05-18T00:00:00+00:00"><meta itemprop=dateModified content="2023-05-18T00:00:00+00:00"><meta itemprop=wordCount content="664"><meta itemprop=keywords content="Java"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="JSR 166规范"><meta name=twitter:description content="Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials"><meta name=twitter:image content><link rel=preconnect href=//fonts.loli.net crossorigin><link rel=dns-prefetch href=//fonts.loli.net><link rel=stylesheet href="https://fonts.loli.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class="logo logo--mixed"><a class=logo__link href=/ title="ChenSoul Blog" rel=home><div class="logo__item logo__imagebox"><img class=logo__img src=/logo.svg loading=lazy alt="Site logo" width=60 height=60></div><div class="logo__item logo__text"><div class=logo__title>ChenSoul Blog</div><div class=logo__tagline>Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>菜单</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>首页</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>分类</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>关于</span></a></li><li class=menu__item><a class=menu__link href=/index.xml><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>JSR 166规范</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 110 28 1 1 0 010-28m0 3a3 3 0 100 22 3 3 0 000-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class=meta__text datetime=2023-05-18>2023-05-18</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/java/ rel=category>Java</a></span></div><div class="meta__item-author meta__item"><svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 16 16"><path d="M8 1c2 0 3.5 2 3.5 4.5S10 9 10 9c3 1 4 2 4 6H2c0-4 1-5 4-6 0 0-1.5-1-1.5-3.5S6 1 8 1"/></svg><span class=meta__text>ChenSoul</span></div></div></header><div class="content post__content clearfix"><h2 id=jsr-介绍>JSR 介绍</h2><p>JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 <a href="http://jcp.org/en/jsr/detail?id=335" target=_blank>JSR 335</a>，新的日期和时间 API 对应的是 <a href="http://jcp.org/en/jsr/detail?id=310" target=_blank>JSR 310</a>。</p><p><a href="https://jcp.org/en/jsr/detail?id=166" target=_blank>JSR 166</a> 是 Doug Lea 提出的一个关于 Java 并发编程的规范提案。JDK1.5 之前，我们控制程序并发访问同步代码只能使用 synchronized，那个时候 synchronized 的性能还没优化好，性能并不好，控制线程也只能使用 Object 的 wait 和 notify 方法。这个时候 Doug Lea 给 JCP 提交了 JSR-166 的提案，在提交 JSR-166 之前，Doug Lea 已经使用了类似 J.U.C 包功能的代码已经三年多了，这些代码就是 J.U.C 的原型。</p><p>J.U.C，即 <code>java.util.concurrent</code> 的缩写，该包参考自 EDU.oswego.cs.dl.util.concurrent，是 JSR 166 标准规范的一个实现。</p><ul><li>Doug Lea 主页：<a href=https://gee.cs.oswego.edu/ target=_blank>Doug Lea&rsquo;s Home Page</a></li><li>JSR-166：<a href=https://gee.cs.oswego.edu/dl/concurrency-interest/index.html target=_blank>Concurrency JSR-166 Interest Site</a></li><li>JSR 166 Slider：<a href=https://gee.cs.oswego.edu/dl/concurrency-interest/jsr166-slides.pdf target=_blank>JSR-166: Concurrency Utilities</a></li><li>java.util.concurrent JavaDoc: <a href=https://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/package-summary.html target=_blank>JDK 1.5 </a>、 <a href=https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html target=_blank>JDK 7 </a>、 <a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html target=_blank>JDK 8 </a>、 <a href=https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/package-summary.html target=_blank>JDK 9</a></li></ul><p><img src=/images/jsr-166-concurrency-utilities.webp alt=jsr-166-concurrency-utilities></p><p>JSR-166 包括多个规范，每个规范都引入了一些新的接口和类，以下是详细描述：</p><ol><li><code>JSR-166（Java SE 5）</code>：定义了 Java 并发包的核心接口和类，包括 Executors 框架、Queues、Timing、Synchronizers、Concurrent Collections、Memory Consistency Properties、Atomic、Locks 等。这些接口和类提供了一种方便、高效、可扩展的方式来处理异步任务和并发编程。</li><li><code>JSR-166x（Java SE 7）</code>：定义了 Java 并发包中的一些新特性，包括 Phaser、TransferQueue、Exchanger、LinkedTransferQueue 等接口和类。其中 Phaser 支持分阶段执行任务，TransferQueue 和 LinkedTransferQueue 实现了高效的生产者-消费者模式，Exchanger 支持两个线程之间交换数据。</li><li><code>JSR-166y（Java SE 8）</code>：定义了 Java 并发包中的一些新特性，包括 StampedLock、CompletableFuture、LongAdder 等接口和类。其中 StampedLock 是一种乐观锁，支持读写分离，CompletableFuture 支持异步任务执行和结果处理，LongAdder 是一种高效的计数器。</li><li><code>JSR-166z（Java SE 9）</code>：定义了 Java 并发包中的一些新特性，包括 VarHandle、Fences 等接口和类。其中 VarHandle 提供了一种更加灵活的原子操作方式，Fences 提供了一些方法用于控制内存屏障。</li></ol><h2 id=juc>JUC</h2><p>java.util.concurrent 包下的类以及引入版本（没有标注版本号的为 <code>1.5</code> ）：</p><ul><li>java.util.concurrent<ul><li>java.util.concurrent.locks<ul><li>AbstractOwnableSynchronizer <code>1.6</code></li><li>AbstractQueuedLongSynchronizer <code>1.6</code></li><li>AbstractQueuedSynchronizer</li><li>Condition</li><li>Lock</li><li>LockSupport</li><li>ReadWriteLock</li><li>ReentrantLock</li><li>ReentrantReadWriteLock</li><li>StampedLock <code>1.8</code></li></ul></li><li>java.util.concurrent.atomic<ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicIntegerArray</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLong</li><li>AtomicLongArray</li><li>AtomicLongFieldUpdater</li><li>AtomicMarkableReference</li><li>AtomicReference</li><li>AtomicReferenceArray</li><li>AtomicReferenceFieldUpdater</li><li>AtomicStampedReference</li><li>DoubleAccumulator <code>1.8</code></li><li>DoubleAdder <code>1.8</code></li><li>LongAccumulator <code>1.8</code></li><li>LongAdder <code>1.8</code></li></ul></li><li>AbstractExecutorService</li><li>ArrayBlockingQueue</li><li>BlockingDeque <code>1.6</code></li><li>BlockingQueue</li><li>BrokenBarrierException</li><li>Callable</li><li>CancellationException</li><li>CompletableFuture <code>1.8</code></li><li>CompletionException <code>1.8</code></li><li>CompletionService</li><li>CompletionStage <code>1.8</code></li><li>ConcurrentHashMap</li><li>ConcurrentLinkedDeque <code>1.7</code></li><li>ConcurrentLinkedQueue</li><li>ConcurrentMap</li><li>ConcurrentNavigableMap <code>1.6</code></li><li>ConcurrentSkipListMap <code>1.6</code></li><li>ConcurrentSkipListSet <code>1.6</code></li><li>CopyOnWriteArrayList</li><li>CopyOnWriteArraySet</li><li>CountDownLatch</li><li>CountedCompleter <code>1.8</code></li><li>CyclicBarrier</li><li>Delayed</li><li>DelayQueue</li><li>Exchanger</li><li>ExecutionException</li><li>Executor</li><li>ExecutorCompletionService</li><li>Executors</li><li>ExecutorService</li><li>Flow <code>1.9</code></li><li>ForkJoinPool <code>1.7</code></li><li>ForkJoinTask <code>1.7</code></li><li>ForkJoinWorkerThread <code>1.7</code></li><li>Future</li><li>FutureTask</li><li>LinkedBlockingDeque <code>1.6</code></li><li>LinkedBlockingQueue</li><li>LinkedTransferQueue <code>1.7</code></li><li>Phaser <code>1.7</code></li><li>PriorityBlockingQueue</li><li>RecursiveAction <code>1.7</code></li><li>RecursiveTask <code>1.7</code></li><li>RejectedExecutionException</li><li>RejectedExecutionHandler</li><li>RunnableFuture</li><li>RunnableScheduledFuture</li><li>ScheduledExecutorService</li><li>ScheduledFuture</li><li>ScheduledThreadPoolExecutor</li><li>Semaphore</li><li>SubmissionPublisher <code>1.9</code></li><li>SynchronousQueue</li><li>ThreadFactory</li><li>ThreadLocalRandom <code>1.7</code></li><li>ThreadPoolExecutor</li><li>TimeoutException</li><li>TimeUnit</li><li>TransferQueue <code>1.7</code></li></ul></li></ul><p>大致可以分为以下几类：</p><ul><li>原子更新</li><li>锁和条件</li><li>线程池</li><li>并发容器</li><li>同步器</li></ul><p>在学习 <code>JUC</code> 之前我们需要了解 <code>CAS</code>，<code>AQS</code> 和 <code>Unsafe</code>。</p><ul><li>CAS：</li><li>AQS：</li><li>Unsafe：</li></ul><h2 id=cas>CAS</h2><p>CAS（<code>Compare and Swap</code>）是一种基于原子性操作的并发编程技术，常用于实现线程安全的数据结构和算法。CAS 操作由三个参数组成：内存位置 V、期望值 A、新值 B。当且仅当 V 的值等于 A 时，CAS 操作才会将 V 的值设置为 B，否则不做任何操作。它的实现原理可以简单概括为以下几个步骤：</p><ol><li>读取内存位置 V 的值，同时记录下该值的版本号或标记位。</li><li>检查内存位置 V 的值是否等于期望值 A。如果相等，则执行第 3 步；否则，操作失败。</li><li>将新值 B 写入内存位置 V，并更新其版本号或标记位。</li><li>返回操作结果。</li></ol><p>CAS 操作是一种<code>乐观锁</code>机制，它不需要锁定整个共享资源，而是只针对需要修改的值进行原子性操作，从而避免了锁的竞争和开销。在执行 CAS 操作时，线程会对内存位置进行读取和写入，但同时也会检查内存位置的版本号或标记位，以保证操作的原子性和一致性。</p><p>需要注意的是，如果多个线程同时执行 CAS 操作，可能会出现 ABA 问题。例如，线程 A 读取内存位置 V 的值为 A，然后线程 B 将 V 的值修改为 B，最后线程 B 又将 V 的值修改为 A。此时，线程 A 执行 CAS 操作时，会发现内存位置 V 的值还是 A，虽然这个 A 的版本号或标记位与之前不同，但线程 A 并不知道 V 的值曾经被修改过，因此会将新值写入内存位置 V，从而导致数据不一致。为了解决 ABA 问题，可以使用带有版本号或标记位的 CAS 操作，或者使用其他的并发编程技术，例如锁或读写锁。</p><p>Java 中的<code>AtomicXXX</code>类实现了 CAS 操作，例如 AtomicInteger、AtomicLong 等。这些类提供了一组原子性操作方法，例如 get()、set()、addAndGet()、compareAndSet()等，它们可以被多个线程安全地使用。</p><p>CAS 操作虽然免去了锁的开销，但也存在一些问题。首先，CAS 操作需要进行多次尝试，直到成功为止。如果并发程度较高，多个线程同时进行 CAS 操作，可能会导致大量的 CAS 操作失败，从而降低性能。其次，CAS 操作只能保证单个变量的原子性操作，无法保证多个变量之间的操作的原子性，因此需要额外的措施来保证多个变量之间的一致性。</p><p>下面是一个使用 AtomicInteger 实现简单计数器的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.atomic.AtomicInteger;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Counter</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> AtomicInteger value <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicInteger(0);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>increment</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> oldValue, newValue;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>            oldValue <span style=color:#f92672>=</span> value.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>            newValue <span style=color:#f92672>=</span> oldValue <span style=color:#f92672>+</span> 1;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>value.<span style=color:#a6e22e>compareAndSet</span>(oldValue, newValue));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getValue</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> value.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在上面的示例中，<code>increment()</code> 方法使用 do-while 循环和<code>compareAndSet()</code>方法执行 CAS 操作来增加计数器的值。该方法重复使用<code>get()</code>方法读取计数器的当前值，计算新值，然后尝试使用<code>compareAndSet()</code>方法更新计数器。循环将继续，直到 CAS 操作成功并且计数器成功更新。</p><p><code>getValue()</code> 方法使用<code>get()</code>方法简单地返回计数器的当前值。</p><p>需要注意的是，在使用 CAS 操作时，需要小心处理潜在的 ABA 问题，其中共享变量的值可能在初始读取和更新尝试之间多次更改。一种处理方法是在共享变量中使用版本号或时间戳，以确保更新仅在值未更改的情况下成功。</p><p>ABA 问题是在使用 CAS（<code>Compare-and-Swap</code>）操作进行并发编程时经常遇到的一个问题。它发生在一个线程从共享内存位置读取一个值，然后另一个线程将该值更改为另一个值，最后又将其更改回原始值，从而使第一个线程的操作意外成功。</p><p>为了处理 ABA 问题，常用的方法是在共享内存位置中添加一个版本号或时间戳。版本号或时间戳可以在每次修改内存位置时进行递增或更新。这可以确保 CAS 操作不仅检查值，还检查内存位置的版本号或时间戳。</p><p>以下是使用版本号处理 ABA 问题的示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.atomic.AtomicStampedReference;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConcurrentStack</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> AtomicStampedReference<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> top <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicStampedReference<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#66d9ef>null</span>, 0);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>push</span>(T value) {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> newHead <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;&gt;</span>(value);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> stampHolder <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> oldHead;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>            oldHead <span style=color:#f92672>=</span> top.<span style=color:#a6e22e>get</span>(stampHolder);
</span></span><span style=display:flex><span>            newHead.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> oldHead;
</span></span><span style=display:flex><span>            stampHolder<span style=color:#f92672>[</span>0<span style=color:#f92672>]++</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>top.<span style=color:#a6e22e>compareAndSet</span>(oldHead, newHead, stampHolder<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>-</span> 1, stampHolder<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> T <span style=color:#a6e22e>pop</span>() {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> oldHead;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> stampHolder <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>            oldHead <span style=color:#f92672>=</span> top.<span style=color:#a6e22e>get</span>(stampHolder);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (oldHead <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>top.<span style=color:#a6e22e>compareAndSet</span>(oldHead, oldHead.<span style=color:#a6e22e>next</span>, stampHolder<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>, stampHolder<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> 1));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> oldHead.<span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> T value;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> next;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Node</span>(T value) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在上面的示例中，<code>ConcurrentStack</code> 类使用 <code>AtomicStampedReference</code> 存储栈顶节点。<code>AtomicStampedReference</code> 类存储值的引用和版本号，版本号在引用更改时进行更新。</p><p><code>push()</code> 方法使用新值创建一个新的 <code>Node</code>，然后尝试使用 CAS 操作将其推入栈中。循环将继续，直到 CAS 操作成功，节点成功推入栈中。</p><p><code>pop()</code> 方法尝试使用 CAS 操作从栈中弹出顶部节点。循环将继续，直到顶部节点成功弹出或栈为空为止。</p><p>通过使用具有版本号的 <code>AtomicStampedReference</code>，<code>ConcurrentStack</code> 类可以处理在并发操作中可能发生的 ABA 问题。</p><h2 id=aqs>AQS</h2><p>AQS（<code>AbstractQueuedSynchronizer</code>）是 Java 中用于实现同步器（如锁，信号量等）的框架，它提供了一些基本的同步操作，例如<code>获取锁</code>、<code>释放锁</code>、<code>等待条件</code>、<code>唤醒线程</code>等。</p><p>AQS 的实现原理基于一个双向链表，用于维护等待线程的队列。当一个线程需要获取同步器时，它会首先尝试使用 CAS 操作来获取同步器，如果获取成功，则继续执行；如果获取失败，则将线程加入等待队列中，并将其挂起。当同步器释放时，它会唤醒等待队列中的一个或多个线程，并将它们从等待队列中移除，使它们可以继续执行。</p><p>AQS 的等待队列是通过一个双向链表来实现的，每个节点代表一个等待线程，节点中包含了线程的状态以及等待条件等信息。等待队列中的节点是按照等待时间的先后顺序排列的，先等待的线程排在前面，后等待的线程排在后面。当一个线程被唤醒时，它会重新尝试获取同步器，如果获取成功，则继续执行；如果获取失败，则它会再次加入等待队列中，并将自己挂起。</p><p>AQS 的具体实现是通过重写其内部的一些方法来实现的。例如，<code>tryAcquire()</code> 方法用于实现获取同步器的逻辑，它会首先尝试使用 CAS 操作来获取同步器，如果获取成功，则返回 true；否则返回 false。<code>tryRelease()</code> 方法用于实现释放同步器的逻辑，它会释放同步器，并唤醒等待队列中的一个或多个线程。<code>tryAcquireShared()</code> 和 <code>tryReleaseShared()</code> 方法则用于实现共享式同步器的逻辑，它们类似于 <code>tryAcquire()</code> 和 <code>tryRelease()</code> 方法，但是可以支持多个线程同时获取或释放同步器。</p><h2 id=unsafe>Unsafe</h2><p>Unsafe 类是 Java 中一个非常特殊且强大的类，它提供了一些不安全的操作，例如直接操作内存、线程挂起和恢复等。Unsafe 类是 Java 中少数几个不被公开支持的类之一，它主要被用于 Java 核心库和其他一些高级框架中，如 Netty、Hadoop 和 Kafka 等。</p><p>由于 Unsafe 类提供了一些不安全的操作，因此它的使用需要非常小心。如果不正确地使用 Unsafe 类，可能会导致程序崩溃或安全漏洞。因此，Java 官方并不建议开发人员使用 Unsafe 类，而是建议开发人员使用更加安全和标准的 Java API。</p><p>Unsafe 类中一些常用的方法包括：</p><ol><li><code>allocateMemory(long size)</code>：分配一段指定大小的内存空间。</li><li><code>freeMemory(long address)</code>：释放指定地址的内存空间。</li><li><code>putXXX(Object target, long offset, XXX value)</code>：将指定类型的值写入目标对象的指定偏移量处。</li><li><code>getXXX(Object target, long offset)</code>：从目标对象的指定偏移量处读取指定类型的值。</li><li><code>park(boolean isAbsolute, long time)</code>：挂起当前线程，直到被其他线程唤醒或指定的时间到期。</li><li><code>unpark(Thread thread)</code>：恢复指定线程的运行。</li></ol><p>需要注意的是，Unsafe 类中的大部分方法都是 native 方法，实现方式依赖于底层操作系统和硬件平台。这意味着 Unsafe 类中的方法在不同的平台上可能会有不同的行为，因此需要针对不同的平台进行测试和验证。</p><p>Java 9 中官方提出了移除 Sun.misc.Unsafe 类，并在该版本中将该类标记为不推荐使用。然而，由于 Unsafe 类在 Java 语言生态中的应用非常广泛，许多框架和库都依赖于 Unsafe 类来实现高性能和低层次的操作。因此，在 Java 9 中，官方引入了 jdk.internal.misc.Unsafe 类来替代 Sun.misc.Unsafe 类的功能，以保持对 Java 生态中使用 Unsafe 类的支持。</p></div><footer class=post__footer><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 000-6 3 3 0 000 6"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/java/ rel=tag>java</a></li></ul></div></footer></footer></article></main><nav class="pagination flex"><div class="pagination__item pagination__item--prev"><a class=pagination__link href=/posts/2023/05/18/weekly_review_19/ rel=prev><p class=pagination__title>«&#8201;上一篇: 周报-19｜武功山看日出、Python初学建议</p></a></div><div class="pagination__item pagination__item--next"><a class=pagination__link href=/posts/2023/05/22/docker-continuous-integration/ rel=next><p class=pagination__title>&#8201;» 下一篇: [译]Build Robust Continuous Integration With Docker and Friends</p></a></div></nav><footer class=post__footer></footer><div class="authorbox clearfix"><figure class=authorbox__avatar><img alt="ChenSoul avatar" src=/avatar.jpg class=avatar height=60 width=60 loading=lazy></figure><div class=authorbox__header><span class=authorbox__name>关于 ChenSoul</span></div><div class=authorbox__description>一个来自中国武汉的开发者，主要撰写软件开发和开源方面的文章。浏览我的<a href=%28/posts%29>博客文章</a>，订阅我的 <a href=/index.xml>RSS</a> 源，或了解更多<a href=/about/>关于我</a>的信息。</div></div><p><h3>欢迎留言！</h3></p><div id=remark42></div><script>var remark_config={host:"https://comment.chensoul.cc",site_id:"remark",components:["embed"],url:"https://blog.chensoul.cc/posts/2023/05/18/jsr-166/",locale:"zh"};!function(e,t){for(s=0;s<e.length;s++){var s,n=t.createElement("script"),o=".js",i=t.head||t.body;"noModule"in n?(n.type="module",o=".mjs"):n.async=!0,n.defer=!0,n.src=remark_config.host+"/web/"+e[s]+o,i.appendChild(n)}}(remark_config.components||["embed"],document)</script></div><aside class="sidebar sidebar--right"><div class="post__toc toc"><div class=toc__title>目录</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#jsr-介绍>JSR 介绍</a></li><li><a href=#juc>JUC</a></li><li><a href=#cas>CAS</a></li><li><a href=#aqs>AQS</a></li><li><a href=#unsafe>Unsafe</a></li></ul></nav></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__links><a class=footer__link href=/>首页</a> | <a class=footer__link href=/categories/>分类</a> | <a class=footer__link href=/about/>关于</a> | <a class=footer__link href=/index.xml>RSS</a></div><div class=footer__copyright>&copy; 2025 ChenSoul.
<span class=footer__copyright-credits>基于 <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> 引擎和 <a href=https://github.com/chensoul/rose-hugo/ rel="nofollow noopener" target=_blank>Rose Hugo</a> 主题</span></div></div><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script defer src=https://umami.chensoul.cc/random-string.js data-website-id=1e07d36d-bec3-4ba6-9459-876b1ac3bbe7></script></footer></div><script>"use strict";(function(t){var i=t.querySelector(".menu__btn"),o=t.querySelector(".menu__list");function a(){o.classList.toggle("menu__list--active"),o.classList.toggle("menu__list--transition"),this.classList.toggle("menu__btn--active"),this.setAttribute("aria-expanded",this.getAttribute("aria-expanded")==="true"?"false":"true")}function r(){this.classList.remove("menu__list--transition")}i&&o&&(i.addEventListener("click",a,!1),o.addEventListener("transitionend",r,!1))})(document,window)</script></body></html>