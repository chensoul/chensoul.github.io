<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>[译]JMS 2.0 中的新增功能（第二部分）- 新的消息传送功能 - ChenSoul Blog</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="[译]JMS 2.0 中的新增功能（第二部分）- 新的消息传送功能"><meta property="og:description" content="Java, Spring Boot, JPA, Hibernate, SQL, REST API, Microservice, Architecture, CI/CD, Docker, Kubernetes, Cloud, and DevOps Tutorials"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2024/07/24/jms20/"><meta property="og:site_name" content="ChenSoul Blog"><meta property="og:image" content><meta itemprop=name content="[译]JMS 2.0 中的新增功能（第二部分）- 新的消息传送功能"><meta itemprop=description content="原文链接：https://www.oracle.com/technical-resources/articles/java/jms2messaging.html
作者：Nigel Deakin 出版日期：2013 年 5 月"><meta itemprop=datePublished content="2024-07-24T00:00:00+00:00"><meta itemprop=dateModified content="2024-07-24T00:00:00+00:00"><meta itemprop=wordCount content="961"><meta itemprop=keywords content="Jms"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="[译]JMS 2.0 中的新增功能（第二部分）- 新的消息传送功能"><meta name=twitter:description content="Java, Spring Boot, JPA, Hibernate, SQL, REST API, Microservice, Architecture, CI/CD, Docker, Kubernetes, Cloud, and DevOps Tutorials"><meta name=twitter:image content><link rel=preconnect href=//fonts.loli.net crossorigin><link rel=dns-prefetch href=//fonts.loli.net><link rel=stylesheet href="https://fonts.loli.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="ChenSoul Blog" rel=home><div class="logo__item logo__text"><div class=logo__title>ChenSoul Blog</div><div class=logo__tagline>Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/tools/><span class=menu__text>Tools</span></a></li><li class=menu__item><a class=menu__link href=/tutorials/><span class=menu__text>Tutorials</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>About</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>[译]JMS 2.0 中的新增功能（第二部分）- 新的消息传送功能</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 110 28 1 1 0 010-28m0 3a3 3 0 100 22 3 3 0 000-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class=meta__text datetime=2024-07-24T00:00:00Z>2024-07-24</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/java/ rel=category>Java</a></span></div></div></header><div class="content post__content clearfix"><p>原文链接：<a href=https://www.oracle.com/technical-resources/articles/java/jms2messaging.html target=_blank>https://www.oracle.com/technical-resources/articles/java/jms2messaging.html</a></p><p><em>作者：Nigel Deakin</em>
出版日期：2013 年 5 月</p><p><strong>了解如何利用 JMS 2.0 中的新消息传递功能。</strong></p><p>本文是两部分系列文章中的第二部分，介绍了 Java 消息服务 (JMS) 2.0 中引入的一些新消息传递功能。本文假设读者对 JMS 1.1 有基本的了解。</p><p>在<a href=https://www.oracle.com/technical-resources/articles/java/jms20.html target=_blank>第一部分</a>中，我们了解了 JMS 2.0 中引入的新的易用特性。在这里，我们来了解一下重要的新消息传递特性。</p><p>JMS 2.0 于 2013 年 4 月发布，这是自 2002 年发布 1.1 版以来 JMS 规范的首次更新。人们可能会认为，一个长期保持不变的 API 已经变得毫无生机和无人使用。但是，如果根据不同实现的数量来判断 API 标准的成功，JMS 是最成功的 API 之一。</p><p>JMS 2.0 的重点是跟上近年来对其他企业 Java 技术所做的易用性改进。同时还借此机会引入了许多新的消息传递功能。</p><p>JMS 2.0 是 Java EE 7 平台的一部分，可用于 Java EE Web 或 EJB 应用程序。它也可以单独用于 Java SE 环境中。正如我下面所解释的那样，某些功能仅在独立环境中可用，而其他功能仅在 Java EE Web 或 EJB 应用程序中可用。</p><p>这里我们讨论 JMS 2.0 中的五个重要的新消息传递功能。</p><h4 id=允许多个消费者订阅同一主题>允许多个消费者订阅同一主题</h4><p>在 JMS 1.1 中，一个主题的订阅不允许同时有多个使用者。这意味着，处理主题订阅上的消息的工作不能在多个线程、连接或 Java 虚拟机 (JVM) 之间共享，从而限制了应用程序的可伸缩性。JMS 2.0 中引入了一种称为共享订阅的新主题订阅，从而消除了此<em>限制</em>。</p><p>让我们回顾一下主题订阅在 JMS 1.1 中的工作方式。在清单 1 中，方法<code>createConsumer</code>on<code>Session</code>用于创建指定主题的<em>非持久订阅</em>（我们稍后将讨论<em>持久订阅）：</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>createUnsharedConsumer</span>(ConnectionFactory connectionFactory, Topic topic) 
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>throws</span> JMSException {
</span></span><span style=display:flex><span>   Connection connection <span style=color:#f92672>=</span> connectionFactory.<span style=color:#a6e22e>createConnection</span>();
</span></span><span style=display:flex><span>   Session session <span style=color:#f92672>=</span> connection.<span style=color:#a6e22e>createSession</span>(<span style=color:#66d9ef>false</span>, Session.<span style=color:#a6e22e>AUTO_ACKNOWLEDGE</span>);
</span></span><span style=display:flex><span>   MessageConsumer messageConsumer <span style=color:#f92672>=</span> session.<span style=color:#a6e22e>createConsumer</span>(topic);
</span></span><span style=display:flex><span>   connection.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>   Message message <span style=color:#f92672>=</span> messageConsumer.<span style=color:#a6e22e>receive</span>(10000);
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>while</span> (message <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Message received: &#34;</span> <span style=color:#f92672>+</span> ((TextMessage) message).<span style=color:#a6e22e>getText</span>());
</span></span><span style=display:flex><span>      message <span style=color:#f92672>=</span> messageConsumer.<span style=color:#a6e22e>receive</span>(10000);
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   connection.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>清单 1</strong></p><p>在清单 1 中，消费者将收到发送到该主题的每条消息的副本。但是，如果应用程序处理每条消息需要很长时间，该怎么办？我们如何通过在两个 JVM 之间分担处理这些消息的工作（例如，一个 JVM 处理一些消息，另一个 JVM 处理剩余消息）来提高应用程序的可扩展性？</p><p>在 JMS 1.1 中，无法在普通 Java SE 应用程序中执行此操作。（在 Java EE 中，您可以使用消息驱动 bean [MDB] 池来执行此操作）。如果您<code>createConsumer</code>在单独的 JVM（或同一 JVM 上的单独线程）中创建第二个使用者，则每个使用者将使用单独的订阅，因此它将收到主题收到的每条消息的副本。这不是我们想要的。如果您将“订阅”视为接收发送到主题的每条消息的副本的逻辑实体，那么我们希望两个使用者使用相同的订阅。</p><p>JMS 2.0 提供了一种解决方案。您可以使用新方法创建“共享”非持久订阅：<code>createSharedConsumer</code>。此方法在 上<code>Session</code>（对于使用传统 API 的应用程序）和 上<code>JMSContext</code>（对于使用简化 API 的应用程序）都可用。由于两个 JVM 需要能够识别它们需要共享的订阅，因此它们需要提供一个名称来标识共享订阅，如清单 2 所示。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>createSharedConsumer</span>(ConnectionFactory connectionFactory, Topic topic) <span style=color:#66d9ef>throws</span> JMSException {
</span></span><span style=display:flex><span>   Connection connection <span style=color:#f92672>=</span> connectionFactory.<span style=color:#a6e22e>createConnection</span>();
</span></span><span style=display:flex><span>   Session session <span style=color:#f92672>=</span> connection.<span style=color:#a6e22e>createSession</span>(<span style=color:#66d9ef>false</span>, Session.<span style=color:#a6e22e>AUTO_ACKNOWLEDGE</span>);
</span></span><span style=display:flex><span>   MessageConsumer messageConsumer <span style=color:#f92672>=</span> session.<span style=color:#a6e22e>createSharedConsumer</span>(topic,<span style=color:#e6db74>&#34;mySubscription&#34;</span>);
</span></span><span style=display:flex><span>   connection.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>   Message message <span style=color:#f92672>=</span> messageConsumer.<span style=color:#a6e22e>receive</span>(10000);
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>while</span> (message <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Message received: &#34;</span> <span style=color:#f92672>+</span> ((TextMessage) message).<span style=color:#a6e22e>getText</span>());
</span></span><span style=display:flex><span>      message <span style=color:#f92672>=</span> messageConsumer.<span style=color:#a6e22e>receive</span>(10000);
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   connection.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>清单 2</strong></p><p>如果您在两个单独的 JVM 中运行清单 2 中的代码，则发送到主题的每条消息都将传递给两个消费者中的一个。这允许他们共享处理来自订阅的消息的工作。</p><p><code>createDurableSubscriber</code>使用持久订阅的应用程序也可以使用相同的功能。在 JMS 1.1 中，使用on方法创建持久订阅<code>Session</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>MessageConsumer messageConsumer <span style=color:#f92672>=</span> session.<span style=color:#a6e22e>createDurableSubscription</span>(topic,<span style=color:#e6db74>&#34;myDurableSub&#34;</span>);
</span></span></code></pre></div><p>这将创建一个<code>myDurableSub</code>针对指定主题的持久订阅。但是，与以前一样，无法在两个 JVM 之间或同一 JVM 上的两个线程之间共享处理此持久订阅上的消息的工作。根据您尝试执行的操作，您将获得一个<code>JMSException</code>或两个不同的订阅。</p><p>JMS 2.0 再次为这个问题提供了解决方案。现在，您可以使用新方法创建“共享”持久订阅。此方法在 上（对于使用传统 API 的应用程序）和 上（对于使用简化 API 的应用程序）<code>createSharedDurableConsumer</code>都可用。<code>Session``JMSContext</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>MessageConsumer messageConsumer <span style=color:#f92672>=</span> session.<span style=color:#a6e22e>createSharedDurableConsumer</span>(topic,<span style=color:#e6db74>&#34;myDurableSub&#34;</span>);
</span></span></code></pre></div><p>总而言之，JMS 1.1 定义了两种不同类型的主题订阅，而 JMS 2.0 定义了四种类型，所有这些类型都可以使用经典或简化的 API 来创建：</p><ul><li><strong>非共享非持久订阅</strong>。这些订阅在 JMS 1.1 和 JMS 2.0 中均可用，并且使用 创建<code>createConsumer</code>。它们只能有一个消费者。设置客户端标识符是可选的。</li><li><strong>非共享持久订阅</strong>。这些订阅在 JMS 1.1 和 JMS 2.0 中均可用，使用或创建<code>createDurableSubscriber</code>（仅在 JMS 2.0 中）<code>createDurableConsumer</code>。它们只能有一个消费者。必须设置客户端标识符，订阅由订阅名称和客户端标识符的组合来标识。</li><li><strong>共享非持久订阅</strong>。这些订阅仅在 JMS 2.0 中可用，并且使用 创建<code>createSharedConsumer</code>。它们可以有任意数量的消费者。设置客户端标识符是可选的。订阅由订阅名称和客户端标识符（如果已设置）的组合标识。</li><li><strong>共享持久订阅</strong>。这些仅在 JMS 2.0 中可用，并且使用 创建<code>createSharedDurableConsumer</code>。它们可以有任意数量的消费者。设置客户端标识符是可选的。订阅由订阅名称和客户端标识符（如果已设置）的组合标识。</li></ul><h4 id=配送延迟>配送延迟</h4><p>您现在可以指定消息的传送延迟。JMS 提供程序将在指定的传送延迟过去后才传送消息。</p><p>如果您使用的是经典 API，则需要在发送消息之前通过调用来设置传送延迟（以毫秒为单位），如清单 3 所示<code>setDeliveryDelay</code>。<code>MessageProducer</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sendWithDeliveryDelayClassic</span>(ConnectionFactory connectionFactory,Queue queue) 
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>throws</span> JMSException {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>/</span> send a message with a delivery delay of 20 seconds
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>try</span> (Connection connection <span style=color:#f92672>=</span> connectionFactory.<span style=color:#a6e22e>createConnection</span>();){
</span></span><span style=display:flex><span>      Session session <span style=color:#f92672>=</span> con.<span style=color:#a6e22e>createSession</span>();
</span></span><span style=display:flex><span>      MessageProducer messageProducer <span style=color:#f92672>=</span> session.<span style=color:#a6e22e>createProducer</span>(queue);
</span></span><span style=display:flex><span>      messageProducer.<span style=color:#a6e22e>setDeliveryDelay</span>(20000);
</span></span><span style=display:flex><span>      TextMessage textMessage <span style=color:#f92672>=</span> session.<span style=color:#a6e22e>createTextMessage</span>(<span style=color:#e6db74>&#34;Hello world&#34;</span>);
</span></span><span style=display:flex><span>      messageProducer.<span style=color:#a6e22e>send</span>(textMessage);
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>清单 3</strong></p><p>如果您使用的是简化 API，则需要<code>setDeliveryDelay</code>在<code>JMSProducer</code>发送消息之前调用。此方法返回对象<code>JMSProducer</code>，它允许您在同一行中创建 JMSProducer、设置交付延迟和发送消息，如清单 4 所示。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sendWithDeliveryDelaySimplified</span>(ConnectionFactory connectionFactory,Queue queue)
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>throws</span> JMSException {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>// send a message with a delivery delay of 20 seconds</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>try</span> (JMSContext context <span style=color:#f92672>=</span> connectionFactory.<span style=color:#a6e22e>createContext</span>();){
</span></span><span style=display:flex><span>      context.<span style=color:#a6e22e>createProducer</span>().<span style=color:#a6e22e>setDeliveryDelay</span>(20000).<span style=color:#a6e22e>send</span>(queue,<span style=color:#e6db74>&#34;Hello world&#34;</span>);
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>清单 4</strong></p><h4 id=异步发送消息>异步发送消息</h4><p>JMS 2.0 的另一个新特性是能够异步发送消息。</p><p>此功能适用于在 Java SE 或 Java EE 应用程序客户端容器中运行的应用程序。不适用于在 Java EE Web 或 EJB 容器中运行的应用程序。</p><p>通常，发送持久消息时，send 方法直到 JMS 客户端将消息发送到服务器并收到回复以通知客户端该消息已被安全接收并持久化后才会返回。我们称此为<em>同步发送</em>。</p><p><em>JMS 2.0 引入了执行异步发送</em>的功能。当异步发送消息时，发送方法会将消息发送到服务器，然后将控制权返回给应用程序，而无需等待服务器的回复。应用程序可以做一些有用的事情，例如发送另一条消息或执行某些处理，而不是在 JMS 客户端等待回复时被无谓地阻塞。</p><p>当收到服务器的回复以表明消息已被服务器接收并持久保存时，JMS 提供程序将通过调用<code>onCompletion</code>应用程序指定的<code>CompletionListener</code>对象上的回调方法来通知应用程序。</p><p>在应用程序中使用异步发送的主要方式有两种</p><ul><li>允许应用程序在等待服务器回复的时间间隔内执行其他操作（如更新显示或写入数据库）</li><li>允许连续发送大量消息，而无需在每条消息后等待服务器的回复</li></ul><p>清单 5 是一个示例，说明如何使用经典 API 实现其中的第一个：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>asyncSendClassic</span>(ConnectionFactory connectionFactory,Queue queue)
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>// send a message asynchronously</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>try</span> (Connection connection <span style=color:#f92672>=</span> connectionFactory.<span style=color:#a6e22e>createConnection</span>();){
</span></span><span style=display:flex><span>      Session session <span style=color:#f92672>=</span> connection.<span style=color:#a6e22e>createSession</span>();
</span></span><span style=display:flex><span>      MessageProducer messageProducer <span style=color:#f92672>=</span> session.<span style=color:#a6e22e>createProducer</span>(queue);
</span></span><span style=display:flex><span>      TextMessage textMessage <span style=color:#f92672>=</span> session.<span style=color:#a6e22e>createTextMessage</span>(<span style=color:#e6db74>&#34;Hello world&#34;</span>);
</span></span><span style=display:flex><span>      CountDownLatch latch <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CountDownLatch(1);
</span></span><span style=display:flex><span>      MyCompletionListener myCompletionListener <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyCompletionListener(latch);
</span></span><span style=display:flex><span>      messageProducer.<span style=color:#a6e22e>send</span>(textMessage,<span style=color:#66d9ef>new</span> MyCompletionListener(latch));
</span></span><span style=display:flex><span>      System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Message sent, now waiting for reply&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// at this point we can do something else before waiting for the reply</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// this is not shown here</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// now wait for the reply from the server </span>
</span></span><span style=display:flex><span>      latch.<span style=color:#a6e22e>await</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (myCompletionListener.<span style=color:#a6e22e>getException</span>()<span style=color:#f92672>==</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>         System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Reply received from server&#34;</span>);
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>throw</span> myCompletionListener.<span style=color:#a6e22e>getException</span>();
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>清单 5</strong></p><p>清单 5 中使用的类<code>MyCompletionListener</code>是应用程序提供的单独类，它实现了接口<code>javax.jms.CompletionListener</code>，如清单 6 所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyCompletionListener</span> <span style=color:#66d9ef>implements</span> CompletionListener {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   CountDownLatch latch;
</span></span><span style=display:flex><span>   Exception exception;
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>MyCompletionListener</span>(CountDownLatch latch) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>latch</span><span style=color:#f92672>=</span>latch;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onCompletion</span>(Message message) {
</span></span><span style=display:flex><span>      latch.<span style=color:#a6e22e>countDown</span>();
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onException</span>(Message message, Exception exception) {
</span></span><span style=display:flex><span>      latch.<span style=color:#a6e22e>countDown</span>();
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>exception</span><span style=color:#f92672>=</span>exception;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> Exception <span style=color:#a6e22e>getException</span>(){
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> exception;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>清单 6</strong></p><p>在清单 6 中，我们使用一种新方法<code>MessageProducer</code>发送消息，而无需等待服务器的回复。这就是<code>send(Message message, CompletionListener listener)</code>。使用此方法发送消息允许应用程序在服务器处理消息时执行其他操作。当应用程序准备继续时，它使用<code>java.util.concurrent.CountDownLatch</code>等待，直到收到来自服务器的回复。收到回复后，应用程序可以继续执行，并且对消息已成功发送的信心程度与正常同步发送后相同。</p><p>如果使用 JMS 2.0 简化 API，异步发送消息会稍微简单一些，如清单 7 所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>asyncSendSimplified</span>(ConnectionFactory connectionFactory,Queue queue) 
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>// send a message asynchronously</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>try</span> (JMSContext context <span style=color:#f92672>=</span> connectionFactory.<span style=color:#a6e22e>createContext</span>();){
</span></span><span style=display:flex><span>      CountDownLatch latch <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CountDownLatch(1);
</span></span><span style=display:flex><span>      MyCompletionListener myCompletionListener <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyCompletionListener(latch);
</span></span><span style=display:flex><span>      context.<span style=color:#a6e22e>createProducer</span>().<span style=color:#a6e22e>setAsync</span>(myCompletionListener).<span style=color:#a6e22e>send</span>(queue,<span style=color:#e6db74>&#34;Hello world&#34;</span>);
</span></span><span style=display:flex><span>      System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Message sent, now waiting for reply&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// at this point we can do something else before waiting for the reply</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// this is not shown here</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      latch.<span style=color:#a6e22e>await</span>();
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (myCompletionListener.<span style=color:#a6e22e>getException</span>()<span style=color:#f92672>==</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>         System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Reply received from server&#34;</span>);
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>throw</span> myCompletionListener.<span style=color:#a6e22e>getException</span>();
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><p><strong>清单 7</strong></p><p>在这种情况下，在调用之前<code>setAsync(CompletionListener listener)</code>调用该方法。由于支持方法链，您可以在同一行上执行这两项操作。<code>JMSProducer``send(Message message)``JMSProducer</code></p><h4 id=jmsxdeliverycount>JMSXDeliveryCount</h4><p>JMS 2.0 允许接收消息的应用程序确定该消息被重新传送的次数。可以从消息属性中获取此信息<code>JMSXDeliveryCount</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>int</span> deliveryCount <span style=color:#f92672>=</span> message.<span style=color:#a6e22e>getIntProperty</span>(<span style=color:#e6db74>&#34;JMSXDeliveryCount&#34;</span>);
</span></span></code></pre></div><p><code>JMSXDeliveryCount</code>不是一个新属性；它是在 JMS 1.1 中定义的。然而，在 JMS 1.1 中，JMS 提供程序可以选择是否实际设置它，这意味着使用它的应用程序代码不可移植。在 JMS 2.0 中，JMS 提供程序必须设置此属性，以便可移植应用程序能够使用它。</p><p>那么为什么应用程序想要知道消息被重新传递了多少次？</p><p>如果重新传送消息，则意味着之前传送该消息的尝试由于某种原因失败。如果重复重新传送消息，则原因可能是接收应用程序出现问题。应用程序可能能够接收消息但无法处理它，因此会抛出异常或回滚事务。如果由于某种原因导致消息无法处理，例如消息在某种程度上“不好”，则同一条消息将被反复重新传送，从而浪费资源并阻止处理后续“好”消息。</p><p>此<code>JMSXDeliveryCount</code>属性允许消费应用程序检测某条消息是否已被多次重新传送，因此在某种程度上属于“坏消息”。应用程序可以使用此信息采取一些特殊操作（而不是简单地触发另一次重新传送），例如消费该消息并将其发送到单独的“坏消息”队列以供管理员操作。</p><p>一些 JMS 提供商已经提供了非标准功能来检测重复重新传送的消息并将其转移到死消息队列。虽然 JMS 2.0 定义了应如何处理此类消息，但该<code>JMSXDeliveryCount</code>属性允许应用程序以可移植的方式实现自己的“坏”消息处理代码。</p><p>清单 8 显示了<code>MessageListener</code>抛出<code>RuntimeException</code>模拟处理“坏”消息时出错的 。<code>MessageListener</code>使用该<code>JMSXDeliveryCount</code>属性来检测消息是否已被重新传递十次并采取不同的操作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyMessageListener</span> <span style=color:#66d9ef>implements</span> MessageListener {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onMessage</span>(Message message) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>int</span> deliveryCount <span style=color:#f92672>=</span> message.<span style=color:#a6e22e>getIntProperty</span>(<span style=color:#e6db74>&#34;JMSXDeliveryCount&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (deliveryCount<span style=color:#f92672>&lt;</span>10){
</span></span><span style=display:flex><span>       <span style=color:#75715e>// now throw a RuntimeException </span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>/</span> to simulate a problem processing the message
</span></span><span style=display:flex><span>       <span style=color:#75715e>// the message will then be redelivered</span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(<span style=color:#e6db74>&#34;Exception thrown to simulate a bad message&#34;</span>);
</span></span><span style=display:flex><span>         } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>       <span style=color:#75715e>// message has been redelivered ten times, </span>
</span></span><span style=display:flex><span>       <span style=color:#75715e>// let&#39;s do something to prevent endless redeliveries</span>
</span></span><span style=display:flex><span>       <span style=color:#75715e>// such as sending it to dead message queue</span>
</span></span><span style=display:flex><span>       <span style=color:#75715e>// details omitted</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>catch</span> (JMSException e) {
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(e);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>清单 8</strong></p><h4 id=mdb-配置属性>MDB 配置属性</h4><p>需要异步接收消息的 Java EE 应用程序使用 MDB 来实现，MDB 是通过指定多个配置属性来配置的。</p><p>Java EE 的早期版本对于如何配置 MDB 的规定非常模糊。在 EJB 3.1 中，仅定义了以下配置属性：</p><ul><li><code>acknowledgeMode</code>（仅当事务由 bean 管理时使用；可以设置为<code>Auto-acknowledge</code>或<code>Dups-ok-acknowledg</code>e）</li><li><code>messageSelector</code></li><li><code>destinationType</code>（可以设置为<code>javax.jms.Queue</code>或<code>javax.jms.Topic</code>）</li><li><code>subscriptionDurability</code>（仅用于主题；可以设置为<code>Durable</code>或<code>NonDurable</code>）</li></ul><p>但是，EJB 3.1 并未定义应用程序应如何指定 MDB 从哪个队列或主题接收消息。这留给应用程序服务器或资源适配器来定义一种非标准方法来实现。</p><p>EJB 3.1 也没有定义当从主题接收消息并<code>subscriptionDurability</code>设置属性<code>Durable</code>时应如何指定订阅名称和客户端标识符。并且 EJB 3.1 中没有标准方法来指定 MDB 用于创建与 JMS 服务器的连接的连接工厂。</p><p>这些相当令人惊讶的限制都在最新版本的 Java EE 中得到了解决。EJB 3.2（Java EE 7 的一部分）定义了以下附加配置属性：</p><ul><li><code>destinationLookup</code>：管理定义的队列或主题对象的 JNDI 名称，该对象表示 MDB 将从中接收消息的队列或主题</li><li><code>connectionFactoryLookup``ConnectionFactory</code>： MDB 将用来连接到 JMS 提供程序的管理定义对象的 JNDI 名称</li><li><code>clientId</code>：MDB 连接到 JMS 提供程序时使用的客户端标识符</li><li><code>subscriptionName``subscriptionDurability</code>：设置为时使用的持久订阅名称<code>Durable</code></li></ul><p>无论如何，大多数应用服务器都支持<code>clientId</code>，<code>subscriptionName</code>因此将这些定义为标准只是将现有实践形式化。</p><p>当然，始终可以配置 JMS MDB 使用的队列或主题，并且许多（但不是全部）应用服务器都提供了指定连接工厂的方法。但是，这样做的方式是非标准的，并且因应用服务器而异。应用服务器仍然可以继续支持这些非标准机制。但是，您可以确信使用多个应用服务器的应用程序<code>destinationLookup</code>将<code>connectionFactoryLookup</code>与多个应用服务器一起工作。</p><p>清单 9 展示了一个 JMS MDB，它使用来自某个主题的持久订阅的消息并使用新的标准属性：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@MessageDriven</span>(activationConfig <span style=color:#f92672>=</span> { 
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>@ActivationConfigProperty</span>(
</span></span><span style=display:flex><span>      propertyName <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;connectionFactoryLookup&#34;</span>, propertyValue <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;jms/MyConnectionFactory&#34;</span>),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>@ActivationConfigProperty</span>(
</span></span><span style=display:flex><span>      propertyName <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;destinationLookup&#34;</span>, propertyValue <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;jmq/PriceFeed&#34;</span>), 
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>@ActivationConfigProperty</span>(
</span></span><span style=display:flex><span>      propertyName <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;destinationType &#34;</span>, propertyValue <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;javax.jms.Topic &#34;</span>),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>@ActivationConfigProperty</span>(
</span></span><span style=display:flex><span>      propertyName <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;subscriptionDurability &#34;</span>, propertyValue <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Durable&#34;</span>), 
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>@ActivationConfigProperty</span>(
</span></span><span style=display:flex><span>      propertyName <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;subscriptionName&#34;</span>, propertyValue <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;MySub&#34;</span>), 
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>@ActivationConfigProperty</span>(
</span></span><span style=display:flex><span>      propertyName <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;clientId&#34;</span>, propertyValue <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;MyClientId&#34;</span>) }) 
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyMDB</span> <span style=color:#66d9ef>implements</span> MessageListener {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onMessage</span>(Message message) {
</span></span><span style=display:flex><span>      ...
</span></span></code></pre></div><p><strong>清单 9</strong></p><h4 id=结论>结论</h4><p>上述五项特性使 Java 开发人员能够更轻松地进行消息传递。结合第一部分中讨论的易用性特性，它们代表着 JMS 2.0 向前迈出了一大步 — JMS 2.0 将继续蓬勃发展，成为 Java 领域最成功的 API 之一。</p><h4 id=也可以看看>也可以看看</h4><ul><li><a href=https://www.oracle.com/technical-resources/articles/java/jms20.html target=_blank>JMS 2.0 中的新增功能（第一部分）- 易于使用</a></li><li><a href="http://jcp.org/en/jsr/detail?id=343" target=_blank>JSR 343</a></li><li><a href=https://glassfish.java.net/ target=_blank>GlassFish</a></li><li><a href=https://mq.java.net/ target=_blank>Open Message Queue 5.0</a></li></ul><h4 id=关于作者>关于作者</h4><p>Nigel Deakin 是 Oracle 的首席技术人员，曾担任 JSR 343（Java 消息服务 2.0）的规范负责人。除了负责领导 JMS 规范的下一版本之外，他还是 Oracle JMS 开发团队的成员，致力于 Open Message Queue 和 GlassFish 应用服务器。他最近在美国旧金山的 JavaOne 和比利时安特卫普的 Devoxx 上发表过演讲，目前居住在英国剑桥。</p><h4 id=加入对话>加入对话</h4><p><a href=https://www.facebook.com/ilovejava target=_blank>在Facebook</a>、<a href=https://twitter.com/#!/java target=_blank>Twitter</a>和<a href=https://blogs.oracle.com/java/ target=_blank>Oracle Java 博客</a>上加入 Java 社区讨论！</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 000-6 3 3 0 000 6"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/jms/ rel=tag>jms</a></li></ul></div></footer></article></main><div class="authorbox clearfix"><figure class=authorbox__avatar><img alt="ChenSoul avatar" src=/images/favicon.webp class=avatar height=60 width=60 loading=lazy></figure><div class=authorbox__header><span class=authorbox__name>About ChenSoul</span></div><div class=authorbox__description>Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials</div></div><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/posts/2024/07/24/jms20-means-less-code/ rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>[译]JMS 2.0 的十个好处意味着可以减少代码编写量</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/posts/2024/07/24/jms20/ rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>[译]JMS 2.0 中的新增功能（第一部分）- 易于使用</p></a></div></nav></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__links><a class=footer__link href=/tools/>Tools</a> | <a class=footer__link href=/tutorials/>Tutorials</a> | <a class=footer__link href=/about/>About</a></div><div class=footer__copyright>&copy; 2025 ChenSoul.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/chensoul/mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></footer></div><script>"use strict";(function(t){var i=t.querySelector(".menu__btn"),o=t.querySelector(".menu__list");function a(){o.classList.toggle("menu__list--active"),o.classList.toggle("menu__list--transition"),this.classList.toggle("menu__btn--active"),this.setAttribute("aria-expanded",this.getAttribute("aria-expanded")==="true"?"false":"true")}function r(){this.classList.remove("menu__list--transition")}i&&o&&(i.addEventListener("click",a,!1),o.addEventListener("transitionend",r,!1))})(document,window)</script><script defer src="https://cdn.bootcdn.net/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script><script defer src=https://umami.chensoul.cc/random-string.js data-website-id=1e07d36d-bec3-4ba6-9459-876b1ac3bbe7></script></body></html>