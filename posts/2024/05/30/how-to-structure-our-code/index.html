<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>[译]如何组织代码 - ChenSoul Blog</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:url" content="https://blog.chensoul.cc/posts/2024/05/30/how-to-structure-our-code/"><meta property="og:site_name" content="ChenSoul Blog"><meta property="og:title" content="[译]如何组织代码"><meta property="og:description" content="原文链接：How to Structure Code
软件设计最佳实践，逐层发现包、按功能发现包以及六角形架构/端口和适配器。
在这篇博文中，我将探讨如何构建我们的代码并讨论最佳实践，涵盖三种不同的方法：按层打包、按功能打包以及六边形架构/端口和适配器及其优缺点。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-30T00:00:00+00:00"><meta property="article:modified_time" content="2024-05-30T00:00:00+00:00"><meta property="article:tag" content="Ddd"><meta itemprop=name content="[译]如何组织代码"><meta itemprop=description content="原文链接：How to Structure Code
软件设计最佳实践，逐层发现包、按功能发现包以及六角形架构/端口和适配器。
在这篇博文中，我将探讨如何构建我们的代码并讨论最佳实践，涵盖三种不同的方法：按层打包、按功能打包以及六边形架构/端口和适配器及其优缺点。"><meta itemprop=datePublished content="2024-05-30T00:00:00+00:00"><meta itemprop=dateModified content="2024-05-30T00:00:00+00:00"><meta itemprop=wordCount content="256"><meta itemprop=keywords content="Ddd"><meta name=twitter:card content="summary"><meta name=twitter:title content="[译]如何组织代码"><meta name=twitter:description content="原文链接：How to Structure Code
软件设计最佳实践，逐层发现包、按功能发现包以及六角形架构/端口和适配器。
在这篇博文中，我将探讨如何构建我们的代码并讨论最佳实践，涵盖三种不同的方法：按层打包、按功能打包以及六边形架构/端口和适配器及其优缺点。"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="ChenSoul Blog" rel=home><div class="logo__item logo__text"><div class=logo__title>ChenSoul Blog</div><div class=logo__tagline>Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/tools/><span class=menu__text>Tools</span></a></li><li class=menu__item><a class=menu__link href=/tutorials/><span class=menu__text>Tutorials</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>About</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>[译]如何组织代码</h1><div class="post__meta meta"><div class="meta__item-author meta__item"><svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 16 16"><path d="M8 1c2 0 3.5 2 3.5 4.5S10 9 10 9c3 1 4 2 4 6H2c0-4 1-5 4-6 0 0-1.5-1-1.5-3.5S6 1 8 1"/></svg><span class=meta__text>ChenSoul</span></div><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 110 28 1 1 0 010-28m0 3a3 3 0 100 22 3 3 0 000-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class=meta__text datetime=2024-05-30T00:00:00Z>2024-05-30</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/spring-boot/ rel=category>Spring-Boot</a></span></div></div></header><div class="content post__content clearfix"><p>原文链接：<a href=https://medium.com/@minadev/how-to-structure-our-code-b5e7b1c32c21 target=_blank>How to Structure Code</a></p><p><em>软件设计最佳实践，逐层发现包、按功能发现包以及六角形架构/端口和适配器。</em></p><p>在这篇博文中，我将探讨如何构建我们的代码并讨论最佳实践，涵盖三种不同的方法：按层打包、按功能打包以及六边形架构/端口和适配器及其优缺点。</p><p>在探索构建代码的不同方法之前，我们需要了解基本的软件设计原则：</p><ul><li><strong>内聚力</strong>：指模块内各类之间的相互关联程度。</li><li><strong>耦合度</strong>：指不同模块之间的依赖程度。</li></ul><p><img src=/images/how-to-structure-our-code-01-0766764.webp alt=img></p><ul><li><strong>模块化</strong>：指软件系统被划分为独立模块的程度。每个模块都封装了一组特定的功能，并设计为独立工作，同时通过明确定义的接口相互交互。</li><li><strong>抽象</strong>：隐藏实现细节并仅通过接口公开必要的功能。</li><li><strong>关注点分离</strong>：设有不同的部分，每个部分解决一个特定的关注点。</li><li><strong>封装</strong>：将数据和方法捆绑到单个模块或类中以隐藏内部细节。</li></ul><p><strong>让我们仔细看看内聚力和耦合力？</strong></p><p>内聚力描述了<strong>软件的</strong>集中程度。它与单一责任原则密切相关。</p><ul><li><strong>高内聚力</strong>意味着模块内的类紧密相关并具有共同的、明确定义的目的。</li><li><strong>低内聚力</strong>意味着模块内的类之间关系松散，缺乏明确的目的且职责不相关。</li></ul><p>要遵循的最佳实践是实现模块之间的<strong>高内聚和松散耦合</strong>。</p><p><img src=/images/how-to-structure-our-code-02-0766764.webp alt=img></p><p>松耦合被认为是结构良好和设计良好的计算机系统的标志，与高内聚力相结合，可带来较高的可读性和可维护性。</p><p><img src=/images/how-to-structure-our-code-03-0766764.webp alt=img></p><p>现在，让我们探索构建代码的不同方式。首先，我将逐层介绍包，然后逐功能介绍包，并比较两者。之后，我们将探索端口和适配器模式。</p><p><img src=/images/how-to-structure-our-code-04-0766764.webp alt=img></p><h1 id=层封装>层封装</h1><p>它代表一个项目结构，其中类被组织成多个层，每个层负责一组特定的功能。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>src
</span></span><span style=display:flex><span>├── main
</span></span><span style=display:flex><span>│   ├── java
</span></span><span style=display:flex><span>│   │   └── com
</span></span><span style=display:flex><span>│   │       └── app
</span></span><span style=display:flex><span>│   │           ├── service 
</span></span><span style=display:flex><span>│   │           │   └── UserService.java
</span></span><span style=display:flex><span>│   │           │   └── OrderService.java
</span></span><span style=display:flex><span>│   │           │   └── ProductService.java
</span></span><span style=display:flex><span>│   │           ├── domain   
</span></span><span style=display:flex><span>│   │           │   └── User.java
</span></span><span style=display:flex><span>│   │           │   └── Order.java
</span></span><span style=display:flex><span>│   │           │   └── Product.java 
</span></span><span style=display:flex><span>│   │           ├── repository   
</span></span><span style=display:flex><span>│   │           │   └── UserRepository.java
</span></span><span style=display:flex><span>│   │           │   └── OrderRepository.java
</span></span><span style=display:flex><span>│   │           │   └── ProductRepository.java
</span></span><span style=display:flex><span>│   │           ├── controller     
</span></span><span style=display:flex><span>│   │           │   └── UserController.java
</span></span><span style=display:flex><span>│   │           │   └── OrderController.java
</span></span><span style=display:flex><span>│   │           │   └── ProductController.java
</span></span></code></pre></div><p>典型的层次包括：</p><ol><li>表示层：此层负责处理用户交互并向用户呈现信息。它通常包括与用户界面、控制器和视图相关的组件。</li><li>服务层：该层包含业务逻辑并提供表示层所需的数据。</li><li>领域包：此包包含领域实体。</li><li>数据访问层：此层负责处理数据库的数据持久化和检索。</li><li>基础设施包：此包提供支持应用程序运行的服务。它可能包括日志记录、配置、安全和其他跨切关注点的组件。</li></ol><p>以下是使用逐层打包的一些缺点：</p><ul><li>低内聚力：不相关的类被分组到同一个包中。</li><li>高耦合</li><li>封装性差：大多数类都是公共的，因此我们不能将类作为包私有的，因为其他层需要它们。</li><li>模块化程度低：由于每个包都包含与特定层相关的类，因此以后很难将代码分解为微服务。</li><li>可维护性差：由于类分散在各个包中，因此很难找到所需的类。</li><li>它提倡数据库驱动设计而不是领域驱动设计。</li></ul><h1 id=按功能打包>按功能打包</h1><p>它代表一种基于特性或功能而非层来组织代码的结构。在这种方法中，每个包代表一个独特且独立的特性。</p><p>目标是将与特定功能相关的所有组件（例如控制器，服务，存储库和域类）组合到一个包中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>src
</span></span><span style=display:flex><span>├── main
</span></span><span style=display:flex><span>│   ├── java
</span></span><span style=display:flex><span>│   │   └── com
</span></span><span style=display:flex><span>│   │       └── app
</span></span><span style=display:flex><span>│   │           ├── user
</span></span><span style=display:flex><span>│   │           │   ├── UserController.java
</span></span><span style=display:flex><span>│   │           │   ├── UserService.java
</span></span><span style=display:flex><span>│   │           │   └── UserRepository.java
</span></span><span style=display:flex><span>│   │           ├── order
</span></span><span style=display:flex><span>│   │           │   ├── OrderController.java
</span></span><span style=display:flex><span>│   │           │   ├── OrderService.java
</span></span><span style=display:flex><span>│   │           │   └── OrderRepository.java
</span></span><span style=display:flex><span>│   │           ├── product
</span></span><span style=display:flex><span>│   │           │   ├── ProductController.java
</span></span><span style=display:flex><span>│   │           │   ├── ProductService.java
</span></span><span style=display:flex><span>│   │           │   └── ProductRepository.java
</span></span></code></pre></div><p>使用这种结构的一些好处：</p><ul><li>高内聚力</li><li>低耦合</li><li>强封装：允许某些类将其访问修饰符设置为包私有（package-private）而不是公共（public）。</li><li>高模块化：由于每个包都包含与特定功能相关的类，因此以后很容易将代码分解为微服务。</li><li>可维护性：由于功能所需的所有类都在同一个包中，因此减少了在包之间导航的需要。</li><li>促进领域驱动设计</li></ul><h1 id=端口和适配器模式六边形架构>端口和适配器模式（六边形架构）</h1><p>六边形架构，也称为端口和适配器，是 Alistair Cockburn 博士在 2005 年撰写的一篇文章中引入的一种软件架构模式。</p><h2 id=六边形架构>六边形架构</h2><p>创建无需 UI 或数据库即可运行的应用程序，以便您可以针对&mldr;运行自动回归测试。</p><p>阿利斯泰尔·科克伯恩</p><p>该模式通过保持核心业务逻辑独立于外部细节并且不与数据库、用户界面或外部服务等外部依赖项紧密耦合来促进关注点的隔离/分离。</p><p>这使得测试、维护和发展系统变得更加容易。</p><p><img src=/images/how-to-structure-our-code-05.webp alt=img></p><p>在此模式下：</p><ol><li>域/核心：表示应用程序的业务逻辑或域（应用程序的核心）。</li><li>端口：端口是核心定义的允许与外部组件交互的接口。这些接口可以包括服务、存储库或任何外部依赖项的接口。</li><li>适配器：适配器是端口的实现。它们将核心应用程序连接到外部组件，例如数据库、用户界面和外部服务。适配器可以特定于不同的技术或协议。</li><li>主要参与者：系统用户，例如 webhook、UI 请求或测试脚本。</li><li>次要参与者：由应用程序使用，这些服务要么是<em>存储库</em>（例如数据库），要么是<em>接收者</em>（例如消息队列）。</li></ol><p><img src=/images/how-to-structure-our-code-06.gif alt=img></p><p><strong>六边形：</strong> 六边形象征着核心应用程序位于中心，周围环绕着适配器。此形状表示核心与其外部依赖项之间的明确分离。</p><p>顶层包结构应如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>src/main/
</span></span><span style=display:flex><span>  java
</span></span><span style=display:flex><span>    mina
</span></span><span style=display:flex><span>      dev
</span></span><span style=display:flex><span>        &lt;servicename&gt;
</span></span><span style=display:flex><span>          adapters
</span></span><span style=display:flex><span>          config
</span></span><span style=display:flex><span>          core
</span></span><span style=display:flex><span>          &lt;ServiceApplication&gt;.java
</span></span></code></pre></div><p>根包应该只包含以下包：</p><ul><li><code>core</code>包含服务的所有领域逻辑。它可能包含子包。</li><li>端口应该位于核心包中：端口只是核心声明的、供适配器调用或实现的接口。</li><li><code>adapters</code>软件包包含所有适配器实现代码。它可能包含子软件包，用于按单个适配器或按技术组织适配器代码。</li><li><code>config</code>包包含用于将不同组件连接在一起的配置类。</li></ul><p><strong>包依赖规则：</strong></p><ul><li>根包可能依赖于所有其他包。</li><li>软件包<code>config</code>可能依赖于<code>core</code>和<code>adapters</code>。</li><li>可能<code>adapters</code>取决于<code>core</code>但不取决于<code>config</code>。</li><li><code>Core </code>可能不依赖于任何其他包。</li></ul><p>您可以在我的 github 存储库中找到更多详细信息和示例：<a href=https://github.com/minarashidi/transfer-service-hexagonal-architecture/tree/main/src/main/java/com/rashidi/transferservice target=_blank>https：/github.com/minarashidi/transfer-service-hexagonal-architecture/tree/main/src/main/java/com/rashidi/transferservice</a></p><p>我希望这篇文章能帮助您更好地理解不同的代码结构。</p><p>我非常希望听到您的想法和评论。欢迎分享您的见解或提出任何问题。感谢您的阅读！</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 000-6 3 3 0 000 6"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/ddd/ rel=tag>ddd</a></li></ul></div></footer></article></main><div class="authorbox clearfix"><figure class=authorbox__avatar><img alt="ChenSoul avatar" src=/images/favicon.webp class=avatar height=60 width=60></figure><div class=authorbox__header><span class=authorbox__name>About ChenSoul</span></div><div class=authorbox__description>Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials</div></div><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/posts/2024/05/14/redis-install/ rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>Redis安装和部署</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/posts/2024/05/30/building-a-restful-api-with-spring-boot-integrating-ddd-and-hexagonal-architecture/ rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>[译]使用 Spring Boot 构建 RESTful API：集成 DDD 和六边形架构</p></a></div></nav></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__links><a class=footer__link href=/tools/>Tools</a> | <a class=footer__link href=/tutorials/>Tutorials</a> | <a class=footer__link href=/about/>About</a></div><div class=footer__copyright>&copy; 2025 ChenSoul.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script></body></html>