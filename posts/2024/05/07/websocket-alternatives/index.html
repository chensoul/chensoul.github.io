<!doctype html><html class=no-js lang=zh-cn><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>[译]2024年最好的WebSocket替代品 - Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="[译]2024年最好的WebSocket替代品"><meta property="og:description" content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/"><meta property="og:site_name" content="ChenSoul Blog"><meta property="og:image" content><meta itemprop=name content="[译]2024年最好的WebSocket替代品"><meta itemprop=description content="原文链接：https://ably.com/topic/websocket-alternatives
什么是 WebSocket？ 简而言之，WebSocket 是一种实时 Web 技术，可通过持久连接在客户端和服务器之间实现双向、全双工通信。 WebSocket 连接会根据需要保持活动状态（理论上，它可以永远持续），从而允许服务器和客户端以最小的开销随意发送数据。"><meta itemprop=datePublished content="2024-05-07T00:00:00+00:00"><meta itemprop=dateModified content="2024-05-07T00:00:00+00:00"><meta itemprop=wordCount content="436"><meta itemprop=keywords content="Javascript,Backend,Tutorial,Translation"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="[译]2024年最好的WebSocket替代品"><meta name=twitter:description content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps"><meta name=twitter:image content><link rel=preconnect href=//fonts.loli.net crossorigin><link rel=dns-prefetch href=//fonts.loli.net><link rel=stylesheet href="https://fonts.loli.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class="logo logo--mixed"><a class=logo__link href=/ title="ChenSoul Blog" rel=home><div class="logo__item logo__imagebox"><img class=logo__img src=/logo.svg loading=lazy alt="Site logo" width=60 height=60></div><div class="logo__item logo__text"><div class=logo__title>ChenSoul Blog</div><div class=logo__tagline>Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>菜单</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>首页</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>分类</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>标签</span></a></li><li class=menu__item><a class=menu__link href=/index.xml><span class=menu__text>订阅</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>关于</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>[译]2024年最好的WebSocket替代品</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 110 28 1 1 0 010-28m0 3a3 3 0 100 22 3 3 0 000-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class=meta__text datetime=2024-05-07>2024-05-07</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/java/ rel=category>Java</a></span></div><div class="meta__item-tags meta__item"><svg class="meta__icon icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 000-6 3 3 0 000 6"/></svg><span class=meta__text><a class=meta__link href=/tags/javascript/ rel=tag>Javascript</a>, <a class=meta__link href=/tags/backend/ rel=tag>Backend</a>, <a class=meta__link href=/tags/tutorial/ rel=tag>Tutorial</a>, <a class=meta__link href=/tags/translation/ rel=tag>Translation</a></span></div></div></header><div class="content post__content clearfix"><p>原文链接：<a href=https://ably.com/topic/websocket-alternatives target=_blank>https://ably.com/topic/websocket-alternatives</a></p><h2 id=什么是-websocket>什么是 WebSocket？</h2><p>简而言之，WebSocket 是一种实时 Web 技术，可通过持久连接在客户端和服务器之间实现双向、全双工通信。 WebSocket 连接会根据需要保持活动状态（理论上，它可以永远持续），从而允许服务器和客户端以最小的开销随意发送数据。</p><p><img src=/images/websockets.webp alt=img></p><p>了解更多：</p><ul><li><a href=https://ably.com/topic/websockets target=_blank>什么是 WebSocket？</a></li><li><a href=https://ably.com/topic/how-do-websockets-work target=_blank>WebSocket 是如何工作的？</a></li></ul><h2 id=什么时候应该考虑使用-websocket-替代方案>什么时候应该考虑使用 WebSocket 替代方案？</h2><p>对于实时或近实时发送和使用数据至关重要（或至少是理想的）的用例，WebSocket 是一个绝佳的选择。示例包括<a href=https://ably.com/solutions/chat target=_blank>聊天应用程序</a>、<a href=https://ably.com/solutions/multiplayer-collaboration target=_blank>多人协作体验</a>以及<a href=https://ably.com/solutions/data-broadcast target=_blank>广播实时路况更新</a>。</p><p><a href=https://ably.com/topic/what-are-websockets-used-for target=_blank>了解有关 WebSocket 用例的更多信息</a></p><p>然而，很少有一种放之四海而皆准的协议：不同的协议比其他协议更好地服务于不同的目的。例如，如果您的应用程序严重依赖 CRUD 操作，并且用户不需要快速对更改做出反应，那么 HTTP 是比 WebSockets 更好的选择。另一个例子 - 如果您想传输音频和视频数据，WebRTC 是比 WebSockets 更好的选择。</p><p>我们要提到的最后一个例子：如果您只需要将文本（字符串）数据推送到浏览器客户端，并且您从不期望需要双向通信，那么您可以使用服务器发送事件（SSE）之类的东西。与 WebSocket 相比，SSE 的复杂性和要求较低，并且更易于扩展。</p><p><a href=https://ably.com/topic/websockets-pros-cons target=_blank>了解 WebSocket 的优点和缺点</a></p><h2 id=websocket-协议的五种替代方案>WebSocket 协议的五种替代方案</h2><p>现在，我们将研究 WebSocket 协议的五种替代方案 - 您可以使用这些技术来构建实时应用程序，这些技术有些类似。</p><h3 id=服务器发送的事件>服务器发送的事件</h3><p><a href=https://ably.com/topic/server-sent-events target=_blank>服务器发送事件 (SSE)</a>是一种 HTTP 服务器推送技术。这个想法很简单：浏览器客户端可以订阅服务器生成的事件流，并在新事件发生时接收更新。</p><p><img src=/images/server_sent_events_how_it_works.webp alt=img></p><p><strong>服务器发送事件的优点</strong></p><ul><li>内置对重新连接的支持。</li><li>所有现代浏览器都支持。</li><li>轻量级协议。</li></ul><p><strong>服务器发送事件的缺点</strong></p><ul><li>它是单向的；只有服务器可以将数据推送到客户端。</li><li>每个浏览器在同一时间只能有六个并发 SSE 连接。</li><li>仅支持UTF-8文本数据； SSE 无法处理二进制数据。</li></ul><p>对于不需要双向消息传递的场景（例如实时比分更新），SSE 是一个不错的选择。对于需要双向通信的用例，WebSocket 是更好的选择。</p><p><a href=https://ably.com/blog/websockets-vs-sse target=_blank>查看 SSE 与 WebSocket 的比较</a></p><h3 id=长轮询>长轮询</h3><p><a href=https://ably.com/topic/long-polling target=_blank>长轮询</a>是一种客户端拉取技术，它采用 HTTP 请求/响应轮询并使其更加高效。在长轮询中，服务器选择尽可能长时间地保持客户端连接打开，并在新数据可用或达到超时阈值时发送响应。</p><p><img src=/images/http-long-polling.webp alt=img></p><p><strong>长轮询的优点</strong></p><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest target=_blank>长轮询是在XMLHttpRequest</a>的基础上实现的，它几乎受到设备的普遍支持，因此通常不需要实现任何后备。</li><li>在必须处理异常的情况下，或者可以查询服务器以获取新数据但不支持长轮询（更不用说其他更现代的技术标准）时，基本轮询有时仍然具有有限的用途，并且可以使用XMLHttpRequest，或通过简单的 HTML 脚本标记通过 JSONP。</li></ul><p><strong>长轮询的缺点</strong></p><ul><li>与 WebSocket 相比，长轮询在服务器上消耗更多资源。</li><li>长轮询可能会带来延迟开销，因为它需要在服务器和设备之间进行多次跳跃。</li><li>可靠的消息排序可能是一个问题。</li></ul><p>长轮询是 WebSocket 的早期先驱。当谈到构建高性能、低延迟的实时应用程序时，WebSocket 几乎在各个方面都是一个优越的选择。这并不是说长轮询已经过时；而是说长轮询已经过时。在某些环境中，例如带有代理服务器的公司网络会阻止 WebSocket 连接。在这种情况下，长轮询作为 WebSocket 的后备机制非常有用。</p><p><a href=https://ably.com/blog/websockets-vs-long-polling target=_blank>查看轮询与 WebSocket 相比需要多长时间</a></p><h3 id=mqtt>MQTT</h3><p><a href=https://ably.com/topic/mqtt target=_blank>MQTT</a>（消息队列遥测传输）是一种<a href=https://ably.com/topic/pub-sub target=_blank>发布-订阅</a>消息传递协议，其历史可以追溯到 1999 年，当时 IBM 的 Andy Stanley-Clark 和 Cirrus Link 的 Arlen Nipper<a href=http://mqtt.org/2009/07/10th-birthday-party target=_blank>发布了第一个迭代</a>。</p><p>在 MQTT 架构中，我们有：</p><ul><li>发布者（生产者）和订阅者（消费者）。请注意，发布者也可以是订阅者。</li><li>充当中间件 MQTT 服务器的代理，管理发布者和订阅者之间的消息交换。</li></ul><p><img src=/images/mqtt-overview_2x.webp alt=img></p><p><strong>MQTT 优势</strong></p><ul><li>轻量级协议非常适合带宽有限或连接不可预测的网络以及 CPU、内存和电池寿命有限的设备。</li><li>可靠协议，具有三种不同级别的数据传递保证：0（最多传递一次）、1（至少传递一次）和2（恰好传递一次）。</li><li>双向且灵活 - 它提供一对一、一对多和多对多通信。</li></ul><p><strong>MQTT 缺点</strong></p><ul><li>对于发送照片、视频或音频数据来说不是一个好的选择。</li><li>您无法将 MQTT 消息发送到浏览器，因为 Web 浏览器没有内置 MQTT 支持。</li><li>基本 MQTT 协议不使用加密通信。某些 MQTT 代理允许您使用 MQTT over TLS 来增强安全性，但这会导致 CPU 使用率增加，这对于受限设备来说可能是一个问题。</li></ul><p>由于设计轻量，对于许多物联网用例（例如从温度或压力传感器实时收集数据）来说，MQTT 是比 WebSocket 更好的选择。但是，如前所述，MQTT 无法直接向浏览器发送消息。这就是为什么 WebSocket 通常被用作将 MQTT 数据流式传输到浏览器客户端的传输方式（基于 WebSocket 的 MQTT）。</p><p><img src=/images/mqtt-over-websocket-overview.webp alt=img></p><p><a href=https://ably.com/topic/mqtt-vs-websocket target=_blank>查看 MQTT 与 WebSocket 的比较</a></p><h3 id=网络rtc>网络RTC</h3><p><a href=https://ably.com/blog/what-is-webrtc target=_blank>Web 实时通信 (WebRTC)</a>是一个框架，可让您向 Web 和移动应用程序添加实时通信 (RTC) 功能。 WebRTC 允许<em>以点对点方式传输任意数据（视频、语音和通用数据）。</em></p><p><img src=/images/webrtc-logo-vert-retro.webp alt=img></p><p><strong>WebRTC优势</strong></p><ul><li><a href=https://datatracker.ietf.org/doc/html/rfc3711 target=_blank>强大的安全保证，通过 WebRTC 传输的数据在安全实时传输协议 (SRTP)</a>的帮助下进行加密和验证。</li><li>开源且免费使用。</li><li>平台和设备无关； WebRTC 应用程序可以在任何支持 WebRTC 的浏览器上运行，无论操作系统或设备类型如何。</li></ul><p><strong>WebRTC 的缺点</strong></p><ul><li>尽管 WebRTC 是一种点对点技术，您仍然需要管理 Web 服务器并为其付费。为了使两个对等点能够相互“交谈”，您需要使用信令服务器来建立、管理和终止 WebRTC 通信会话。</li><li>在处理视频内容和大量用户时，WebRTC 可能会占用大量 CPU 资源。</li><li>WebRTC 入门很难。有很多概念需要探索和掌握：各种接口、编解码器、网络地址转换 (NAT) 和防火墙、UDP（WebRTC 使用的主要底层通信协议）等等。</li></ul><p>WebRTC 主要设计用于流式传输音频和视频内容（通过 UDP），在这种情况下通常是比 WebSocket 更好的选择。另一方面，当数据完整性（保证排序和交付）至关重要时，WebSocket 是更好的选择，因为您可以从 TCP 的底层可靠性中受益。</p><p>通常，WebRTC 和 WebSocket 是互补技术。 WebRTC 对等点通过称为信令的过程来协调通信。需要注意的是，WebRTC 不提供标准的信令实现，允许开发人员为此目的使用不同的协议。<em>WebSocket 协议通常用作 WebRTC 应用程序的信令机制</em>。</p><p><img src=/images/signaling-overview-webrtc-websockets_2x.webp alt=img></p><p><a href=https://ably.com/topic/webrtc-vs-websocket target=_blank>了解 WebRTC 与 WebSocket 的比较</a></p><h3 id=网络传输>网络传输</h3><p><a href=https://ably.com/blog/can-webtransport-replace-websockets target=_blank>WebTransport</a>是一项新兴的实时技术，通过<a href=https://ably.com/topic/http3 target=_blank>HTTP/3</a>提供客户端-服务器消息传递。 WebTransport 有两个关键概念：</p><ul><li><strong>数据报</strong>。数据报是一个独立的数据包，可以按任何特定顺序到达。专为需要低延迟且尽力而为的数据传输就足够好的用例而设计。</li><li><strong>溪流</strong>。 Streams API 提供可靠、有序的数据传输。请注意，您可以创建单向和双向流。</li></ul><p><strong>网络传输优势</strong></p><ul><li>通过使用 Datagrams API 或通过多个 Streams API 实例，您不必担心队头阻塞。</li><li>建立新连接非常快——这是因为 HTTP/3 在底层使用了 QUIC；众所周知，QUIC 握手比通过 TLS 启动 TCP 更快。</li></ul><p><strong>Web传输的缺点</strong></p><ul><li>WebTransport 仍然是一项新兴技术。截至 2022 年 11 月，<a href=https://w3c.github.io/webtransport/ target=_blank>WebTransport 是 W3C 的草案规范</a>，与其工作方式相关的方面始终有可能发生变化。</li><li><a href=https://caniuse.com/webtransport target=_blank>并非所有浏览器都支持 WebTransport</a>。例如，您无法在 Firefox 和 Safari 中使用 WebTransport。</li></ul><p>与我们在本文中介绍的其他 WebSocket 替代方案（这些都是已经存在一段时间的成熟技术）不同，WebTransport 更像是 WebSocket 的未来潜在替代方案。我们不知道它在未来几年将如何发展，开发人员采用它的可能性有多大，或者它在生产就绪系统中使用时可能存在哪些陷阱。相比之下，WebSocket 已经存在十多年了；它是一种强大、稳定的技术，拥有庞大而活跃的社区，目前使其成为 WebTransport 的卓越替代品。</p><p><a href=https://ably.com/blog/can-webtransport-replace-websockets target=_blank>了解有关 WebTransport 的更多信息</a></p><h2 id=websocket-及其替代方案头对头比较>WebSocket 及其替代方案：头对头比较</h2><p>下表显示了 WebSocket 与我们在本文中介绍的替代实时技术之间的主要区别和相似之处。</p><table><thead><tr><th style=text-align:left><strong>标准</strong></th><th style=text-align:left><strong>WebSockets</strong></th><th style=text-align:left><strong>长轮询</strong></th><th style=text-align:left><strong>上证所</strong></th><th style=text-align:left><strong>MQTT</strong></th><th style=text-align:left><strong>网络RTC</strong></th><th style=text-align:left><strong>网络传输</strong></th></tr></thead><tbody><tr><td style=text-align:left>底层协议</td><td style=text-align:left>传输控制协议</td><td style=text-align:left>传输控制协议</td><td style=text-align:left>传输控制协议</td><td style=text-align:left>传输控制协议</td><td style=text-align:left>UDP、TCP</td><td style=text-align:left>WHO</td></tr><tr><td style=text-align:left>双向？</td><td style=text-align:left>是的</td><td style=text-align:left>不</td><td style=text-align:left>不</td><td style=text-align:left>是的</td><td style=text-align:left>是的</td><td style=text-align:left>是的</td></tr><tr><td style=text-align:left>潜伏</td><td style=text-align:left>低的</td><td style=text-align:left>高的</td><td style=text-align:left>低的</td><td style=text-align:left>低的</td><td style=text-align:left>低的</td><td style=text-align:left>低的</td></tr><tr><td style=text-align:left>带宽</td><td style=text-align:left>低的</td><td style=text-align:left>高的</td><td style=text-align:left>低的</td><td style=text-align:left>低的</td><td style=text-align:left>高的</td><td style=text-align:left>高的</td></tr><tr><td style=text-align:left>浏览器支持</td><td style=text-align:left>广泛支持</td><td style=text-align:left>广泛支持</td><td style=text-align:left>广泛支持</td><td style=text-align:left>浏览器没有内置的 MQTT 支持</td><td style=text-align:left>Internet Explorer 和 Opera Mini 不支持</td><td style=text-align:left>支持有限</td></tr><tr><td style=text-align:left>使用方便</td><td style=text-align:left>缓和</td><td style=text-align:left>简单的</td><td style=text-align:left>简单的</td><td style=text-align:left>缓和</td><td style=text-align:left>难的</td><td style=text-align:left>简单的</td></tr><tr><td style=text-align:left>到期</td><td style=text-align:left>技术成熟</td><td style=text-align:left>技术成熟</td><td style=text-align:left>技术成熟</td><td style=text-align:left>技术成熟</td><td style=text-align:left>技术成熟</td><td style=text-align:left>新兴科技</td></tr><tr><td style=text-align:left>数据的完整性</td><td style=text-align:left>高的</td><td style=text-align:left>缓和</td><td style=text-align:left>高的</td><td style=text-align:left>高的</td><td style=text-align:left>高的</td><td style=text-align:left>高的</td></tr><tr><td style=text-align:left>可扩展性</td><td style=text-align:left>高的</td><td style=text-align:left>缓和</td><td style=text-align:left>高的</td><td style=text-align:left>高的</td><td style=text-align:left>低的</td><td style=text-align:left>高的</td></tr><tr><td style=text-align:left>它是干什么用的？</td><td style=text-align:left>服务器和客户端之间的实时通信。</td><td style=text-align:left>客户端发起的实时更新通信。</td><td style=text-align:left>单向数据流（服务器推送）。</td><td style=text-align:left>用于 IoT 和 M2M 通信的轻量级消息传递协议。</td><td style=text-align:left>用于实时音频和视频流的点对点通信。</td><td style=text-align:left>用于低延迟 Web 通信的多路复用传输协议。</td></tr></tbody></table><h2 id=使用多种协议提供实时体验>使用多种协议提供实时体验</h2><p>我们希望您发现本文对您发现 WebSocket 的潜在替代方案有所帮助。然而，现实情况是，许多生产就绪的实时系统不仅仅使用一种协议，而是多种协议的混合。</p><p>例如，如果您正在开发视频会议解决方案，WebRTC 是在对等点之间发送音频和视频数据的绝佳选择。在这种情况下，WebSocket 补充了 WebRTC，并经常用作WebRTC 对等方的<a href=https://ably.com/blog/solving-the-webrtc-signalling-challenge target=_blank>信令机制</a>。</p><p>另一个例子：由于其轻量级设计，MQTT 是从物联网传感器收集遥测数据的绝佳选择。但是，如果您想使用这些数据来支持可以在浏览器中监控的实时仪表板，则 MQTT 不适合，因为浏览器不支持它。您可以做的就是通过 WebSocket 将数据发送到浏览器。这就是为什么现在许多 MQTT 代理也支持 WebSocket（或基于 WebSocket 的 MQTT）。</p><p>如果您确实决定使用 WebSocket 作为您的用例的主要传输协议，您仍然需要考虑支持后备传输，因为某些环境会阻止 WebSocket 连接（例如，限制性的公司网络）。 SSE 和长轮询通常用作 WebSocket 的后备方案。</p><h2 id=ably在任何规模下都能可靠运行的多协议实时平台>Ably，在任何规模下都能可靠运行的多协议实时平台</h2><p>Ably 是一家实时体验基础设施提供商。我们的 API 和 SDK 可帮助开发人员构建和提供实时体验，而无需担心维护和扩展混乱的实时基础设施。</p><p>Ably 的主要特性和功能：</p><ul><li>具有丰富功能的发布/订阅消息传递，例如消息增量压缩、连续性自动重新连接、用户状态、消息历史记录和消息交互。</li><li>多协议功能。 Ably 协议基于 WebSocket，但我们还支持长轮询作为后备、SSE、MQTT、AMQP、STOMP 和 HTTP/REST。</li><li>全球分布式数据中心网络和边缘加速接入点。</li><li>保证消息排序和传递。</li><li>全球容错和 99.999% 的正常运行时间 SLA。</li><li>&lt; 65 毫秒往返延迟 (P99)。</li><li>动态弹性，因此我们可以快速扩展以处理任何需求（发送到数百万个发布/订阅通道和客户端连接的数十亿条消息）。</li></ul></div></article></main><footer class=post__footer><div class=post-related><h3>相关文章</h3><ul class=post-related-list><li class=post-related-item><a href=/posts/2024/05/07/the-websocket-api-and-protocol-explained/ target=_blank title="[译]WebSocket API和协议说明">[译]WebSocket API和协议说明</a></li><li class=post-related-item><a href=/posts/2024/05/07/websockets-vs-http/ target=_blank title=[译]WebSocket与HTTP：2024年为您的项目选择哪一个>[译]WebSocket与HTTP：2024年为您的项目选择哪一个</a></li><li class=post-related-item><a href=/posts/2024/05/07/http3/ target=_blank title=[译]什么是HTTP/3？>[译]什么是HTTP/3？</a></li><li class=post-related-item><a href=/posts/2024/05/07/socket-io/ target=_blank title=[译]什么是Socket.IO？>[译]什么是Socket.IO？</a></li><li class=post-related-item><a href=/posts/2024/05/07/websockets/ target=_blank title=[译]什么是WebSocket？>[译]什么是WebSocket？</a></li><li class=post-related-item><a href=/posts/2024/05/07/thingsboard-domain/ target=_blank title=ThingsBoard的领域模型>ThingsBoard的领域模型</a></li></ul></div></footer><footer class=post__footer><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 000-6 3 3 0 000 6"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/javascript/ rel=tag>javascript</a></li><li class=tags__item><a class="tags__link btn" href=/tags/backend/ rel=tag>backend</a></li><li class=tags__item><a class="tags__link btn" href=/tags/tutorial/ rel=tag>tutorial</a></li><li class=tags__item><a class="tags__link btn" href=/tags/translation/ rel=tag>translation</a></li></ul></div></footer></footer><nav class="pagination flex"><div class="pagination__item pagination__item--prev"><a class=pagination__link href=/posts/2024/05/07/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs/ rel=prev><p class=pagination__title>«&#8201;上一篇: [译]Apache Kafka、RabbitMQ 与 AWS SNSSQS：哪个消息代理最好？</p></a></div><div class="pagination__item pagination__item--next"><a class=pagination__link href=/posts/2024/05/08/exploring-http2-part-2-overview/ rel=next><p class=pagination__title>&#8201;» 下一篇: [译]探索 http2（第 2 部分）：使用 node-http2 核心和 hapijs</p></a></div></nav><div class="authorbox clearfix"><figure class=authorbox__avatar><img alt="ChenSoul avatar" src=/avatar.jpg class=avatar height=60 width=60 loading=lazy></figure><div class=authorbox__header><span class=authorbox__name>关于 ChenSoul</span></div><div class=authorbox__description>一个来自中国武汉的开发者，主要撰写软件开发和开源方面的文章。浏览我的<a href=%28/posts%29>博客文章</a>，订阅我的 <a href=/index.xml>RSS</a> 源，或了解更多<a href=/about/>关于我</a>的信息。</div></div><p><h3>欢迎留言！</h3></p><div id=remark42></div><script>var remark_config={host:"https://comment.chensoul.cc",site_id:"remark",components:["embed"],url:"https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/",locale:"zh"};!function(e,t){for(s=0;s<e.length;s++){var s,n=t.createElement("script"),o=".js",i=t.head||t.body;"noModule"in n?(n.type="module",o=".mjs"):n.async=!0,n.defer=!0,n.src=remark_config.host+"/web/"+e[s]+o,i.appendChild(n)}}(remark_config.components||["embed"],document)</script></div><aside class="sidebar sidebar--right"><div class="post__toc toc"><div class=toc__title>目录</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#什么是-websocket>什么是 WebSocket？</a></li><li><a href=#什么时候应该考虑使用-websocket-替代方案>什么时候应该考虑使用 WebSocket 替代方案？</a></li><li><a href=#websocket-协议的五种替代方案>WebSocket 协议的五种替代方案</a><ul><li><a href=#服务器发送的事件>服务器发送的事件</a></li><li><a href=#长轮询>长轮询</a></li><li><a href=#mqtt>MQTT</a></li><li><a href=#网络rtc>网络RTC</a></li><li><a href=#网络传输>网络传输</a></li></ul></li><li><a href=#websocket-及其替代方案头对头比较>WebSocket 及其替代方案：头对头比较</a></li><li><a href=#使用多种协议提供实时体验>使用多种协议提供实时体验</a></li><li><a href=#ably在任何规模下都能可靠运行的多协议实时平台>Ably，在任何规模下都能可靠运行的多协议实时平台</a></li></ul></nav></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__links><a class=footer__link href=/>首页</a> | <a class=footer__link href=/categories/>分类</a> | <a class=footer__link href=/tags/>标签</a> | <a class=footer__link href=/index.xml>订阅</a> | <a class=footer__link href=/about/>关于</a></div><div class=footer__copyright>&copy; 2025 ChenSoul.
<span class=footer__copyright-credits>基于 <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> 引擎和 <a href=https://github.com/chensoul/rose-hugo/ rel="nofollow noopener" target=_blank>Rose Hugo</a> 主题</span></div></div><style>.scroll-up a{display:block;height:3.125rem;width:3.125rem;text-align:center;line-height:2.7;border-radius:50px;font-size:1.125rem;color:#fff;opacity:1;transition:all .3s ease 0s;box-shadow:0 0 10px rgb(0 0 0/.2)}.scroll-up a{background:#ee591f}.scroll-up{position:fixed;display:none;bottom:50px;z-index:999}.scroll-up.right{right:60px}</style><div class="scroll-up custom right" style=display:block><a href=#top id=top-link accesskey=g><i class="fa fa-arrow-up"></i></a></div><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script defer src=https://umami.chensoul.cc/random-string.js data-website-id=1e07d36d-bec3-4ba6-9459-876b1ac3bbe7></script></footer></div><script>"use strict";(function(t){var i=t.querySelector(".menu__btn"),o=t.querySelector(".menu__list");function a(){o.classList.toggle("menu__list--active"),o.classList.toggle("menu__list--transition"),this.classList.toggle("menu__btn--active"),this.setAttribute("aria-expanded",this.getAttribute("aria-expanded")==="true"?"false":"true")}function r(){this.classList.remove("menu__list--transition")}i&&o&&(i.addEventListener("click",a,!1),o.addEventListener("transitionend",r,!1))})(document,window)</script></body></html>