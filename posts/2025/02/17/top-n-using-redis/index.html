<!doctype html><html lang=en-US prefix="og: http://ogp.me/ns#"><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="以下是一个基于本地缓存 + Redis ZSet + 定时任务的榜单方案，适用于高并发场景：
方案概述

本地缓存 ：在应用服务器本地缓存榜单数据，减少对 Redis 的访问频率，提高读取速度。
Redis ZSet ：使用 Redis 的有序集合存储榜单数据，利用其高效的排序和范围查询功能。
定时任务 ：定期更新本地缓存和 Redis ZSet 中的榜单数据，确保数据的实时性和准确性。

数据存储架构
全局前 1000 名榜单存储在 Redis 中"><title>如何实现榜单 top N 统计 | ChenSoul</title><link rel=canonical href=https://blog.chensoul.cc/posts/2025/02/17/top-n-using-redis/><link rel=preconnect href=https://fonts.font.im><link rel=preconnect href=https://fonts.loli.net crossorigin><link href="https://fonts.loli.net/css2?family=Roboto+Slab:wght@400;500;700&display=swap" rel=stylesheet><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.chensoul.cc/images/favicon.webp"><meta name=twitter:title content="如何实现榜单 top N 统计"><meta name=twitter:description content="以下是一个基于本地缓存 + Redis ZSet + 定时任务的榜单方案，适用于高并发场景：
方案概述 本地缓存 ：在应用服务器本地缓存榜单数据，减少对 Redis 的访问频率，提高读取速度。 Redis ZSet ：使用 Redis 的有序集合存储榜单数据，利用其高效的排序和范围查询功能。 定时任务 ：定期更新本地缓存和 Redis ZSet 中的榜单数据，确保数据的实时性和准确性。 数据存储架构 全局前 1000 名榜单存储在 Redis 中"><meta name=twitter:creator content="@ichensoul"><meta property="og:locale" content="en_US"><meta property="og:site_name" content="chensoul"><meta property="og:url" content="https://blog.chensoul.cc/posts/2025/02/17/top-n-using-redis/"><meta property="og:site_name" content="ChenSoul"><meta property="og:title" content="如何实现榜单 top N 统计"><meta property="og:description" content="以下是一个基于本地缓存 + Redis ZSet + 定时任务的榜单方案，适用于高并发场景：
方案概述 本地缓存 ：在应用服务器本地缓存榜单数据，减少对 Redis 的访问频率，提高读取速度。 Redis ZSet ：使用 Redis 的有序集合存储榜单数据，利用其高效的排序和范围查询功能。 定时任务 ：定期更新本地缓存和 Redis ZSet 中的榜单数据，确保数据的实时性和准确性。 数据存储架构 全局前 1000 名榜单存储在 Redis 中"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-17T00:00:00+00:00"><meta property="article:modified_time" content="2025-02-17T00:00:00+00:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="Redis"><meta property="og:image" content="https://blog.chensoul.cc/images/favicon.webp"><meta itemprop=name content="如何实现榜单 top N 统计"><meta itemprop=description content="以下是一个基于本地缓存 + Redis ZSet + 定时任务的榜单方案，适用于高并发场景：
方案概述 本地缓存 ：在应用服务器本地缓存榜单数据，减少对 Redis 的访问频率，提高读取速度。 Redis ZSet ：使用 Redis 的有序集合存储榜单数据，利用其高效的排序和范围查询功能。 定时任务 ：定期更新本地缓存和 Redis ZSet 中的榜单数据，确保数据的实时性和准确性。 数据存储架构 全局前 1000 名榜单存储在 Redis 中"><meta itemprop=datePublished content="2025-02-17T00:00:00+00:00"><meta itemprop=dateModified content="2025-02-17T00:00:00+00:00"><meta itemprop=wordCount content="709"><meta itemprop=image content="https://blog.chensoul.cc/images/favicon.webp"><meta itemprop=keywords content="Java,Redis"><link rel=stylesheet href=https://cdnjs.loli.net/ajax/libs/font-awesome/6.4.0/css/all.min.css media=all><link rel=stylesheet href=/main.min.css type=text/css media=all><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"TechArticle","name":"如何实现榜单 top N 统计","headline":"如何实现榜单 top N 统计","inLanguage":"en-US","url":"https://blog.chensoul.cc/posts/2025/02/17/top-n-using-redis/","description":"\u003cp\u003e以下是一个基于本地缓存 + Redis ZSet + 定时任务的榜单方案，适用于高并发场景：\u003c/p\u003e\n\u003ch2 id=\"方案概述\"\u003e方案概述\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e本地缓存\u003c/strong\u003e ：在应用服务器本地缓存榜单数据，减少对 Redis 的访问频率，提高读取速度。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRedis ZSet\u003c/strong\u003e ：使用 Redis 的有序集合存储榜单数据，利用其高效的排序和范围查询功能。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e定时任务\u003c/strong\u003e ：定期更新本地缓存和 Redis ZSet 中的榜单数据，确保数据的实时性和准确性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"数据存储架构\"\u003e数据存储架构\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e全局前 1000 名榜单存储在 Redis 中\u003c/strong\u003e\u003c/p\u003e","wordCount":"709","keywords":["java","redis"],"datePublished":"2025-02-17T00:00:00Z","dateModified":"2025-02-17T00:00:00Z","author":{"@type":"Person","name":"chensoul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chensoul.cc/posts/2025/02/17/top-n-using-redis/"},"publisher":{"@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/posts/2025/02/17/top-n-using-redis/"}},{"@context":"https://schema.org","@type":"Organization","name":"chensoul","url":"https://blog.chensoul.cc/","sameAs":["https://x.com/ichensoul","https://github.com/chensoul","https://www.linkedin.com/in/","https://www.youtube.com/@chensoul","https://t.me/chensouls"]}]}</script><script defer src=https://umami.chensoul.cc/random-string.js data-website-id=4718b57b-c900-4a61-a7af-0fe1fb1d50ce></script></head><body class="home blog post-layout-one-column"><button onclick=topFunction() id=scrollTopBtn title="Go to top">
<i class="fa-solid fa-arrow-up"></i></button><div id=header-top class=header-bar-wrap></div><div id=page class=site><a class="skip-link screen-reader-text" href=#content>Skip to content</a><header id=masthead class="site-header clearfix" role=banner><div class="header-main container clearfix"><div id=logo class="site-branding clearfix"><h1 class=site-title><a href=/ title=ChenSoul rel=home>ChenSoul</a></h1><p class=site-description>Java, Spring Boot, Microservice, Cloud, Architecture and DevOps Tutorials</p></div><div class="header-widgets clearfix"><aside id=search-2 class="header-widget widget_search"><form role=search method=get class=search-form onsubmit="return searchSite(event)"><label><span class=screen-reader-text>Search for:</span>
<input type=search class=search-field placeholder="Enter search keyword" name=query id=query title="Enter search keyword">
</label><button type=submit class=search-submit title=Search> <span class=genericon-search></span>
<span class=screen-reader-text>Search</span></button></form></aside></div></div><div id=main-navigation-wrap class=primary-navigation-wrap><nav id=main-navigation class="primary-navigation navigation container clearfix" role=navigation><ul id=menu-home class=main-navigation-menu><li class="menu-item menu-item-type-custom menu-item-object-custom
current-menu-item current_page_item menu-item-home"><a href=/>Home</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/spring-boot/>Spring Boot</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/architecture/>Architecture</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/microservice/>Microservice</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/categories/kubernetes/>Kubernetes</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category
menu-item-has-children"><a href=/tutorials/>Tutorials</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/spring-boot-tutorials/>Spring Boot Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/microservice-tutorials/>Microservice Tutorials</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category"><a href=/kubernetes-tutorials/>Kubernetes Tutorials</a></li></ul></li><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=https://github.com/chensoul target=_blank>About Me</a></li></ul></nav></div></header><div id=content class="site-content container clearfix"><section id=primary class="content-archive content-area post-content-area"><main id=main class=site-main role=main><article class="post type-post"><div class=post-inner-content><header class=entry-header><h2 class=entry-title><a href=https://blog.chensoul.cc/posts/2025/02/17/top-n-using-redis/ rel=bookmark title="如何实现榜单 top N 统计">如何实现榜单 top N 统计</a></h2><div class=entry-meta><span class=meta-date><time class="entry-date published" datetime=2025-02-17T00:00:00>2025-02-17
</time></span><span class=meta-author><span class="author vcard">chensoul</span>
</span><span class="tagcloud post-tags"><i class="fa fa-tags"></i>&nbsp;
<a class="tag-cloud-link widget__link widget__link--taglist" href=/tags/java/ title=java>java</a>
&nbsp;
<a class="tag-cloud-link widget__link widget__link--taglist" href=/tags/redis/ title=redis>redis</a></span></div></header><div class=entry-content><p>以下是一个基于本地缓存 + Redis ZSet + 定时任务的榜单方案，适用于高并发场景：</p><h2 id=方案概述>方案概述</h2><ol><li><strong>本地缓存</strong> ：在应用服务器本地缓存榜单数据，减少对 Redis 的访问频率，提高读取速度。</li><li><strong>Redis ZSet</strong> ：使用 Redis 的有序集合存储榜单数据，利用其高效的排序和范围查询功能。</li><li><strong>定时任务</strong> ：定期更新本地缓存和 Redis ZSet 中的榜单数据，确保数据的实时性和准确性。</li></ol><h2 id=数据存储架构>数据存储架构</h2><p><strong>全局前 1000 名榜单存储在 Redis 中</strong></p><ul><li><strong>Redis ZSet</strong>：<ul><li>键名：<code>global_ranking_top_1000</code></li><li>ZSet 中的成员是用户 ID，分数是排名依据（如积分、销售额等）。</li><li>定时任务每小时更新一次，覆盖之前的 ZSet 数据。</li></ul></li></ul><p><strong>前 100 名榜单同步到本地缓存</strong></p><ul><li><strong>本地缓存</strong>：<ul><li>每个应用服务器使用内存数据结构（如 <code>ConcurrentHashMap</code>）存储前 100 名榜单。</li><li>键名：<code>local_ranking_top_100</code></li><li>数据来源于 Redis 的 <code>global_ranking_top_1000</code>，每分钟同步一次。</li></ul></li></ul><h2 id=实现步骤>实现步骤</h2><ol><li>定时任务计算全局前 1000 名</li></ol><p><strong>任务频率</strong>：每小时执行一次</p><p><strong>任务逻辑</strong>：</p><ol><li>检索数据库中所有用户的实时数据（如积分、销售额）。</li><li>排序并选出前 1000 名用户。</li><li>将前 1000 名用户写入 Redis 的 <code>global_ranking_top_1000</code> ZSet，覆盖原有数据。</li></ol><p><strong>代码示例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 使用 Spring 定时任务</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Scheduled</span>(cron <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;0 0 * * * ?&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>updateGlobalRanking</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. 从数据库获取所有用户数据</span>
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>User<span style=color:#f92672>&gt;</span> users <span style=color:#f92672>=</span> userRepository.<span style=color:#a6e22e>findAll</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. 排序并选出前 1000 名</span>
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>User<span style=color:#f92672>&gt;</span> top1000 <span style=color:#f92672>=</span> users.<span style=color:#a6e22e>stream</span>()
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>sorted</span>((u1, u2) <span style=color:#f92672>-&gt;</span> Double.<span style=color:#a6e22e>compare</span>(u2.<span style=color:#a6e22e>getScore</span>(), u1.<span style=color:#a6e22e>getScore</span>()))
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>limit</span>(1000)
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>collect</span>(Collectors.<span style=color:#a6e22e>toList</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. 写入 Redis ZSet，覆盖原有数据</span>
</span></span><span style=display:flex><span>    redisTemplate.<span style=color:#a6e22e>delete</span>(<span style=color:#e6db74>&#34;global_ranking_top_1000&#34;</span>); <span style=color:#75715e>// 清空旧数据</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (User user : top1000) {
</span></span><span style=display:flex><span>        redisTemplate.<span style=color:#a6e22e>opsForZSet</span>().<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;global_ranking_top_1000&#34;</span>, user.<span style=color:#a6e22e>getId</span>(), user.<span style=color:#a6e22e>getScore</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>定时同步前 100 名到本地缓存</li></ol><p><strong>任务频率</strong>：每分钟执行一次</p><p><strong>任务逻辑</strong>：</p><ol><li>从 Redis 的 <code>global_ranking_top_1000</code> ZSet 中获取前 100 名用户。</li><li>将前 100 名用户数据写入本地缓存。</li></ol><p><strong>代码示例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 使用 Spring 定时任务</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Scheduled</span>(cron <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;0 * * * * ?&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>updateLocalRankingCache</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. 从 Redis 获取前 100 名</span>
</span></span><span style=display:flex><span>    Set<span style=color:#f92672>&lt;</span>ZSetOperations.<span style=color:#a6e22e>TypedTuple</span><span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span> top100 <span style=color:#f92672>=</span> redisTemplate.<span style=color:#a6e22e>opsForZSet</span>()
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>reverseRangeWithScores</span>(<span style=color:#e6db74>&#34;global_ranking_top_1000&#34;</span>, 0, 99);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. 将数据写入本地缓存</span>
</span></span><span style=display:flex><span>    Map<span style=color:#f92672>&lt;</span>String, Double<span style=color:#f92672>&gt;</span> localCache <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcurrentHashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (ZSetOperations.<span style=color:#a6e22e>TypedTuple</span><span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> tuple : top100) {
</span></span><span style=display:flex><span>        String userId <span style=color:#f92672>=</span> tuple.<span style=color:#a6e22e>getValue</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> score <span style=color:#f92672>=</span> tuple.<span style=color:#a6e22e>getScore</span>();
</span></span><span style=display:flex><span>        localCache.<span style=color:#a6e22e>put</span>(userId, score);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 更新本地缓存</span>
</span></span><span style=display:flex><span>    localRankingCache <span style=color:#f92672>=</span> localCache;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>读取榜单数据</li></ol><p><strong>访问逻辑</strong>：</p><ol><li>优先从本地缓存读取前 100 名榜单。</li><li>如果本地缓存中没有数据（如缓存过期或未初始化），则从 Redis 的 <code>global_ranking_top_1000</code> ZSet 中读取前 100 名。</li></ol><p><strong>代码示例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> Map<span style=color:#f92672>&lt;</span>String, Double<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getTop100Ranking</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. 优先从本地缓存读取</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (localRankingCache <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>localRankingCache.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> localRankingCache;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. 从 Redis 读取</span>
</span></span><span style=display:flex><span>    Set<span style=color:#f92672>&lt;</span>ZSetOperations.<span style=color:#a6e22e>TypedTuple</span><span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span> top100 <span style=color:#f92672>=</span> redisTemplate.<span style=color:#a6e22e>opsForZSet</span>()
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>reverseRangeWithScores</span>(<span style=color:#e6db74>&#34;global_ranking_top_1000&#34;</span>, 0, 99);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Map<span style=color:#f92672>&lt;</span>String, Double<span style=color:#f92672>&gt;</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedHashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (ZSetOperations.<span style=color:#a6e22e>TypedTuple</span><span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> tuple : top100) {
</span></span><span style=display:flex><span>        result.<span style=color:#a6e22e>put</span>(tuple.<span style=color:#a6e22e>getValue</span>(), tuple.<span style=color:#a6e22e>getScore</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>优化后的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Component</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RankingManager</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> RedisTemplate<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> redisTemplate;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> UserService userService;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 本地缓存</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Map<span style=color:#f92672>&lt;</span>String, Map<span style=color:#f92672>&lt;</span>String, Double<span style=color:#f92672>&gt;&gt;</span> localCache <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcurrentHashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Redis ZSet 键名</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String GLOBAL_RANKING_KEY <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;global_ranking_top_1000&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String TEMP_GLOBAL_RANKING_KEY <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;temp_global_ranking_top_1000&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 定时任务：每小时计算全局前1000名</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Scheduled</span>(cron <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;0 0 * * * ?&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>updateGlobalRanking</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 1. 从数据库获取所有用户数据</span>
</span></span><span style=display:flex><span>            List<span style=color:#f92672>&lt;</span>User<span style=color:#f92672>&gt;</span> users <span style=color:#f92672>=</span> userService.<span style=color:#a6e22e>findAll</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 2. 排序并选出前1000名</span>
</span></span><span style=display:flex><span>            List<span style=color:#f92672>&lt;</span>User<span style=color:#f92672>&gt;</span> top1000 <span style=color:#f92672>=</span> users.<span style=color:#a6e22e>stream</span>()
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>sorted</span>((u1, u2) <span style=color:#f92672>-&gt;</span> Double.<span style=color:#a6e22e>compare</span>(u2.<span style=color:#a6e22e>getScore</span>(), u1.<span style=color:#a6e22e>getScore</span>()))
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>limit</span>(1000)
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>collect</span>(Collectors.<span style=color:#a6e22e>toList</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 3. 使用临时键存储数据</span>
</span></span><span style=display:flex><span>            redisTemplate.<span style=color:#a6e22e>delete</span>(TEMP_GLOBAL_RANKING_KEY);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (User user : top1000) {
</span></span><span style=display:flex><span>                redisTemplate.<span style=color:#a6e22e>opsForZSet</span>().<span style=color:#a6e22e>add</span>(TEMP_GLOBAL_RANKING_KEY, user.<span style=color:#a6e22e>getId</span>(), user.<span style=color:#a6e22e>getScore</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 4. 原子性地将临时键重命名为目标键</span>
</span></span><span style=display:flex><span>            redisTemplate.<span style=color:#a6e22e>rename</span>(TEMP_GLOBAL_RANKING_KEY, GLOBAL_RANKING_KEY);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 5. 更新本地缓存</span>
</span></span><span style=display:flex><span>            updateLocalCache(top1000);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Global ranking updated successfully.&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Error updating global ranking: &#34;</span> <span style=color:#f92672>+</span> e.<span style=color:#a6e22e>getMessage</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>updateLocalCache</span>(List<span style=color:#f92672>&lt;</span>User<span style=color:#f92672>&gt;</span> top1000) {
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>String, Double<span style=color:#f92672>&gt;</span> cache <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcurrentHashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (User user : top1000) {
</span></span><span style=display:flex><span>            cache.<span style=color:#a6e22e>put</span>(user.<span style=color:#a6e22e>getId</span>(), user.<span style=color:#a6e22e>getScore</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        localCache.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;global_top_1000&#34;</span>, cache);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 定时任务：每分钟同步前100名到本地缓存</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Scheduled</span>(cron <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;0 * * * * ?&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>updateLocalCacheFromRedis</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 1. 从Redis获取前100名</span>
</span></span><span style=display:flex><span>            Set<span style=color:#f92672>&lt;</span>ZSetOperations.<span style=color:#a6e22e>TypedTuple</span><span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span> top100 <span style=color:#f92672>=</span> redisTemplate.<span style=color:#a6e22e>opsForZSet</span>()
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>reverseRangeWithScores</span>(GLOBAL_RANKING_KEY, 0, 99);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 2. 更新本地缓存</span>
</span></span><span style=display:flex><span>            Map<span style=color:#f92672>&lt;</span>String, Double<span style=color:#f92672>&gt;</span> localTop100 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedHashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (ZSetOperations.<span style=color:#a6e22e>TypedTuple</span><span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> tuple : top100) {
</span></span><span style=display:flex><span>                localTop100.<span style=color:#a6e22e>put</span>(tuple.<span style=color:#a6e22e>getValue</span>(), tuple.<span style=color:#a6e22e>getScore</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            localCache.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;local_top_100&#34;</span>, localTop100);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Local cache updated successfully.&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Error updating local cache: &#34;</span> <span style=color:#f92672>+</span> e.<span style=color:#a6e22e>getMessage</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取榜单数据</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Map<span style=color:#f92672>&lt;</span>String, Double<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getTop100Ranking</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 优先从本地缓存读取</span>
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>String, Double<span style=color:#f92672>&gt;</span> localTop100 <span style=color:#f92672>=</span> localCache.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;local_top_100&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (localTop100 <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>localTop100.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> LinkedHashMap<span style=color:#f92672>&lt;&gt;</span>(localTop100);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 从Redis读取</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            Set<span style=color:#f92672>&lt;</span>ZSetOperations.<span style=color:#a6e22e>TypedTuple</span><span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span> top100 <span style=color:#f92672>=</span> redisTemplate.<span style=color:#a6e22e>opsForZSet</span>()
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>reverseRangeWithScores</span>(GLOBAL_RANKING_KEY, 0, 99);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Map<span style=color:#f92672>&lt;</span>String, Double<span style=color:#f92672>&gt;</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedHashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (ZSetOperations.<span style=color:#a6e22e>TypedTuple</span><span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> tuple : top100) {
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>put</span>(tuple.<span style=color:#a6e22e>getValue</span>(), tuple.<span style=color:#a6e22e>getScore</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Error fetching data from Redis: &#34;</span> <span style=color:#f92672>+</span> e.<span style=color:#a6e22e>getMessage</span>());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Collections.<span style=color:#a6e22e>emptyMap</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>优化效果</p><ol><li><strong>性能</strong>：通过使用临时键和 <code>rename</code> 命令，确保 Redis 数据更新的原子性，减少数据更新时的锁竞争。</li><li><strong>可靠性</strong>：增加异常处理逻辑，确保系统在异常情况下仍能正常运行。</li><li><strong>可维护性</strong>：将功能模块分离，提高代码的可读性和可维护性。</li><li><strong>数据一致性</strong>：确保本地缓存和 Redis ZSet 的数据一致性，避免因网络问题或系统故障导致数据不一致。</li></ol><h2 id=适用场景>适用场景</h2><ol><li>游戏排行榜</li></ol><ul><li><strong>实时战力排行榜</strong>：玩家的战力值实时更新，排行榜需要立即反映变化。通过 Redis ZSet 实时维护战力值，定时任务每小时计算全局前 1000 名，写入 Redis。每分钟同步前 100 名到本地缓存，确保玩家可以快速查询自己的排名。</li><li><strong>每日任务排行榜</strong>：统计玩家每日完成任务的数量或得分，定时任务每小时更新一次，确保排行榜数据的实时性和准确性。</li></ul><ol start=2><li>电商平台</li></ol><ul><li><strong>热销产品榜单</strong>：实时统计产品的销量或浏览量，通过 Redis ZSet 维护热销产品榜单。定时任务每小时更新全局前 1000 名，写入 Redis。每分钟同步前 100 名到本地缓存，确保用户可以快速查看热销产品。</li><li><strong>商家销售额排行榜</strong>：统计商家的销售额，定时任务每小时更新一次，确保排行榜数据的实时性和准确性。</li></ul><ol start=3><li>社交平台</li></ol><ul><li><strong>用户活跃度排行榜</strong>：统计用户的活跃度（如点赞数、评论数、分享数），通过 Redis ZSet 实时维护活跃度排行榜。定时任务每小时更新全局前 1000 名，写入 Redis。每分钟同步前 100 名到本地缓存，确保用户可以快速查看自己的排名。</li><li><strong>话题热度排行榜</strong>：统计话题的热度（如阅读量、参与人数），定时任务每小时更新一次，确保排行榜数据的实时性和准确性。</li></ul><ol start=4><li>内容平台</li></ol><ul><li><strong>文章阅读量排行榜</strong>：统计文章的阅读量，通过 Redis ZSet 实时维护阅读量排行榜。定时任务每小时更新全局前 1000 名，写入 Redis。每分钟同步前 100 名到本地缓存，确保用户可以快速查看热门文章。</li><li><strong>视频播放量排行榜</strong>：统计视频的播放量，定时任务每小时更新一次，确保排行榜数据的实时性和准确性。</li></ul><ol start=5><li>金融平台</li></ol><ul><li><strong>交易额排行榜</strong>：统计用户的交易额，通过 Redis ZSet 实时维护交易额排行榜。定时任务每小时更新全局前 1000 名，写入 Redis。每分钟同步前 100 名到本地缓存，确保用户可以快速查看自己的排名。</li><li><strong>投资收益排行榜</strong>：统计用户的 investment 收益，定时任务每小时更新一次，确保排行榜数据的实时性和准确性。</li></ul><ol start=6><li>教育平台</li></ol><ul><li><strong>学习时长排行榜</strong>：统计学生的学习时长，通过 Redis ZSet 实时维护学习时长排行榜。定时任务每小时更新全局前 1000 名，写入 Redis。每分钟同步前 100 名到本地缓存，确保学生可以快速查看自己的排名。</li><li><strong>课程评分排行榜</strong>：统计课程的评分，定时任务每小时更新一次，确保排行榜数据的实时性和准确性。</li></ul><ol start=7><li>物流平台</li></ol><ul><li><strong>配送效率排行榜</strong>：统计配送员的配送效率（如配送单量、配送时长），通过 Redis ZSet 实时维护配送效率排行榜。定时任务每小时更新全局前 1000 名，写入 Redis。每分钟同步前 100 名到本地缓存，确保配送员可以快速查看自己的排名。</li><li><strong>客户满意度排行榜</strong>：统计客户的满意度评分，定时任务每小时更新一次，确保排行榜数据的实时性和准确性。</li></ul><ol start=8><li>医疗平台</li></ol><ul><li><strong>医生好评排行榜</strong>：统计医生的好评数，通过 Redis ZSet 实时维护好评排行榜。定时任务每小时更新全局前 1000 名，写入 Redis。每分钟同步前 100 名到本地缓存，确保用户可以快速查看医生的排名。</li><li><strong>医院服务排行榜</strong>：统计医院的服务评分，定时任务每小时更新一次，确保排行榜数据的实时性和准确性。</li></ul><ol start=9><li>交通出行平台</li></ol><ul><li><strong>司机服务排行榜</strong>：统计司机的服务评分，通过 Redis ZSet 实时维护服务排行榜。定时任务每小时更新全局前 1000 名，写入 Redis。每分钟同步前 100 名到本地缓存，确保用户可以快速查看司机的排名。</li><li><strong>车辆使用排行榜</strong>：统计车辆的使用频率，定时任务每小时更新一次，确保排行榜数据的实时性和准确性。</li></ul><ol start=10><li>企业内部系统</li></ol><ul><li><strong>员工绩效排行榜</strong>：统计员工的绩效得分，通过 Redis ZSet 实时维护绩效排行榜。定时任务每小时更新全局前 1000 名，写入 Redis。每分钟同步前 100 名到本地缓存，确保员工可以快速查看自己的排名。</li><li><strong>部门贡献排行榜</strong>：统计部门的贡献值，定时任务每小时更新一次，确保排行榜数据的实时性和准确性。</li></ul><h2 id=系统优化><strong>系统优化</strong></h2><h3 id=数据一致性>数据一致性</h3><ul><li><strong>本地缓存与 Redis 数据的一致性</strong>：<ul><li>定时任务每分钟同步前 100 名数据，确保本地缓存数据不超过 1 分钟的延迟。</li><li>如果本地缓存失效或未同步，系统自动回退到 Redis 数据。</li></ul></li></ul><h3 id=redis-性能优化>Redis 性能优化</h3><ul><li><strong>使用 Redis 集群</strong>：如果数据量巨大，可以使用 Redis Cluster 分散读写压力。</li><li><strong>设置过期时间</strong>：为 Redis 中的榜单数据设置过期时间（如 24 小时），避免数据永久占用内存。</li></ul><h3 id=高并发优化>高并发优化</h3><ul><li><strong>本地缓存优先</strong>：99% 的请求从本地缓存获取数据，减少对 Redis 的访问。</li><li><strong>异步更新</strong>：定时任务异步执行，不影响系统响应速度。</li></ul><h2 id=注意事项>注意事项</h2><ul><li><strong>热点数据</strong>：如果榜单数据是系统热点，需要确保本地缓存的容量足够大，避免频繁访问 Redis。</li><li><strong>数据持久化</strong>：Redis 的数据是内存存储，建议定期将榜单数据持久化到数据库或文件中，防止数据丢失。</li><li><strong>监控</strong>：对定时任务和缓存更新逻辑进行监控，确保任务按时执行，数据及时更新。</li></ul></div><div><div style=font-weight:700>Share this post:</div><a class=social-link-item href="https://twitter.com/intent/tweet?text=%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e6%a6%9c%e5%8d%95%20top%20N%20%e7%bb%9f%e8%ae%a1 https%3a%2f%2fblog.chensoul.cc%2fposts%2f2025%2f02%2f17%2ftop-n-using-redis%2f" target=_blank rel="noopener noreferrer" title="Click to share on Twitter"><i class="fa-brands fa-square-twitter fa-2xl" style=color:#55acee></i>
</a><a class=social-link-item href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2025%2f02%2f17%2ftop-n-using-redis%2f&title=%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e6%a6%9c%e5%8d%95%20top%20N%20%e7%bb%9f%e8%ae%a1" target=_blank rel="noopener noreferrer" title="Click to share on LinkedIn"><i class="fa-brands fa-linkedin fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://telegram.me/share/url?text=%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e6%a6%9c%e5%8d%95%20top%20N%20%e7%bb%9f%e8%ae%a1&amp;url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2025%2f02%2f17%2ftop-n-using-redis%2f" target=_blank rel="noopener noreferrer" title="Click to share on telegram"><i class="fa-brands fa-telegram fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://reddit.com/submit?url=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2025%2f02%2f17%2ftop-n-using-redis%2f&title=%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e6%a6%9c%e5%8d%95%20top%20N%20%e7%bb%9f%e8%ae%a1" target=_blank rel="noopener noreferrer" title="Click to share on reddit"><i class="fa-brands fa-reddit fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.chensoul.cc%2fposts%2f2025%2f02%2f17%2ftop-n-using-redis%2f" target=_blank rel="noopener noreferrer" title="Click to share on facebook"><i class="fa-brands fa-facebook fa-2xl" style=color:#007bb5></i>
</a><a class=social-link-item href="https://api.whatsapp.com/send?text=%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e6%a6%9c%e5%8d%95%20top%20N%20%e7%bb%9f%e8%ae%a1%20-%20https%3a%2f%2fblog.chensoul.cc%2fposts%2f2025%2f02%2f17%2ftop-n-using-redis%2f" target=_blank rel="noopener noreferrer" title="Click to share on whatsapp"><i class="fa-brands fa-whatsapp fa-2xl" style=color:#007bb5></i></a></div></div></article><nav class="navigation post-navigation" role=navigation><h2 class=screen-reader-text>Post navigation</h2><div class=nav-links><div class=nav-previous><a href=/posts/2025/03/28/id-generator/ rel=next><span class=post-title>常见分布式 ID 解决方案</span></a></div><div class=nav-next><a href=/posts/2025/02/14/rate-limit/ rel=prev><span class=post-title>什么是限流</span></a></div></div></nav><h2>Related content</h2><ul><li><a href=/posts/2025/06/06/oauth2-client-login-in-thingsboard/>Thingsboard源码中的OAuth2登录实现</a></li><li><a href=/posts/2025/04/30/codes-in-thingsboard/>Thingsboard源码中的代码片段</a></li><li><a href=/posts/2025/03/31/canal-install-test/>Canal原理、安装和测试</a></li><li><a href=/posts/2025/03/28/id-generator/>常见分布式 ID 解决方案</a></li><li><a href=/posts/2025/02/14/rate-limit/>什么是限流</a></li><li><a href=/posts/2025/02/14/retry-for-timeout/>区分偶发性超时和频繁超时的重试策略</a></li><li><a href=/posts/2024/12/03/github-actions-in-thingsboard/>ThingsBoard源码中的Github Actions</a></li><li><a href=/posts/2024/12/03/security-in-thingsboard/>ThingsBoard源码中的Security</a></li><li><a href=/posts/2024/11/14/quarkus-quick-start/>2024-11-14-Quarkus 快速入门</a></li><li><a href=/posts/2024/11/07/junit-5-migration/>[译]从JUnit4迁移到JUnit5：权威指南</a></li></ul></main></section></div><div id=footer class=footer-wrap><footer id=colophon class="site-footer container clearfix" role=contentinfo><div id=footer-text class=site-info><span class=credit-link>Made with 🩷
by <a href=/ target=_blank rel="noopener noreferrer">ChenSoul</a></span></div></footer></div></div><script type=text/javascript src=/main.min.js></script></body></html>