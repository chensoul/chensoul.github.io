<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on ChenSoul</title><link>https://blog.chensoul.cc/categories/java/</link><description>Recent content in Java on ChenSoul</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 31 Mar 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.chensoul.cc/categories/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Canal原理、安装和测试</title><link>https://blog.chensoul.cc/posts/2025/03/31/canal-install-test/</link><pubDate>Mon, 31 Mar 2025 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2025/03/31/canal-install-test/</guid><description>&lt;p>Canal 是阿里巴巴开源的一款分布式增量数据同步工具，主要用于基于 MySQL 数据库的增量日志 Binlog 解析，提供增量数据的订阅和消费。&lt;/p>
&lt;p>Canal github 地址：https://github.com/alibaba/canal，目前最新版本为 &lt;a href="https://github.com/alibaba/canal/releases/tag/canal-1.1.8" target="_blank">1.1.8&lt;/a>，当前的 canal 支持源端 MySQL 版本包括 5.1.x、5.5.x 、5.6.x、5.7.x、8.0.x。&lt;/p></description></item><item><title>常见分布式 ID 解决方案</title><link>https://blog.chensoul.cc/posts/2025/03/28/id-generator/</link><pubDate>Fri, 28 Mar 2025 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2025/03/28/id-generator/</guid><description>&lt;p>分布式 ID 的生成是分布式系统中的一个核心问题，需要确保生成的 ID 全局唯一、性能高效，并且能够适应高并发和大规模的场景。以下是一些常见的分布式 ID 生成方案：&lt;/p>
&lt;ol>
&lt;li>UUID&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;strong>原理&lt;/strong>：UUID（Universally Unique Identifier）是一种通过一系列算法生成的128位数字，通常基于时间戳、计算机硬件标识符、随机数等元素。&lt;/li>
&lt;li>&lt;strong>优点&lt;/strong>：实现简单，无需网络交互，保证全局唯一性。&lt;/li>
&lt;li>&lt;strong>缺点&lt;/strong>：ID 较长（36个字符的字符串形式），可能导致存储和索引效率低下，且通常不能保证顺序性。&lt;/li>
&lt;li>&lt;strong>适用场景&lt;/strong>：适用于对唯一性要求高，但对性能和存储空间要求不敏感的场景。&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>NanoID&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>原理&lt;/strong>：NanoID 是一个轻量级、安全、URL 友好的唯一字符串 ID 生成器。它使用加密安全的随机数生成器，确保生成的 ID 足够随机和安全。&lt;/p></description></item><item><title>如何实现榜单 top N 统计</title><link>https://blog.chensoul.cc/posts/2025/02/17/top-n-using-redis/</link><pubDate>Mon, 17 Feb 2025 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2025/02/17/top-n-using-redis/</guid><description>&lt;p>以下是一个基于本地缓存 + Redis ZSet + 定时任务的榜单方案，适用于高并发场景：&lt;/p>
&lt;h2 id="方案概述">方案概述&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>本地缓存&lt;/strong> ：在应用服务器本地缓存榜单数据，减少对 Redis 的访问频率，提高读取速度。&lt;/li>
&lt;li>&lt;strong>Redis ZSet&lt;/strong> ：使用 Redis 的有序集合存储榜单数据，利用其高效的排序和范围查询功能。&lt;/li>
&lt;li>&lt;strong>定时任务&lt;/strong> ：定期更新本地缓存和 Redis ZSet 中的榜单数据，确保数据的实时性和准确性。&lt;/li>
&lt;/ol>
&lt;h2 id="数据存储架构">数据存储架构&lt;/h2>
&lt;p>&lt;strong>全局前 1000 名榜单存储在 Redis 中&lt;/strong>&lt;/p></description></item><item><title>什么是限流</title><link>https://blog.chensoul.cc/posts/2025/02/14/rate-limit/</link><pubDate>Fri, 14 Feb 2025 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2025/02/14/rate-limit/</guid><description>&lt;h2 id="基本概念">基本概念&lt;/h2>
&lt;p>在互联网领域，限流是指对进入系统的请求数量或频率进行控制的一种机制，以防止系统因流量暴增而过载，从而保障系统的稳定性和可用性。&lt;/p>
&lt;h2 id="限流目的">限流目的&lt;/h2>
&lt;ol>
&lt;li>防止系统过载：控制请求速率，避免突发流量导致系统崩溃。&lt;/li>
&lt;li>资源保护：合理分配系统资源，防止某些请求占用过多资源影响其他请求。&lt;/li>
&lt;li>防止恶意攻击：通过限制请求频率，抵御DDoS等恶意攻击。&lt;/li>
&lt;li>保障服务质量：确保系统能为每个请求提供稳定、可靠的服务。&lt;/li>
&lt;li>削峰填谷：在访问高峰期平滑请求曲线，将超出系统承载能力的请求延后处理或拒绝。&lt;/li>
&lt;li>成本控制：对于按量计费的云服务，限流可以有效控制成本。&lt;/li>
&lt;li>公平竞争：确保不同用户或应用程序之间公平地使用系统资源。&lt;/li>
&lt;/ol>
&lt;h2 id="应用场景">应用场景&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>保护后端服务&lt;/strong> ：在高并发环境下，后端服务可能无法承受大量请求，限流有助于防止服务崩溃。&lt;/li>
&lt;li>&lt;strong>防止 DDoS 攻击&lt;/strong> ：DDoS 攻击通过大量伪造请求涌入系统，造成系统无法响应。限流可以有效缓解这种 DDoS 攻击。&lt;/li>
&lt;li>&lt;strong>优化用户体验&lt;/strong> ：通过控制请求频率，避免单个用户或客户端频繁请求系统，从而提升其他用户的访问体验。&lt;/li>
&lt;li>&lt;strong>流量控制&lt;/strong> ：在某些情况下，系统需要根据当前负载情况动态调整可接受的请求量，避免资源浪费或系统崩溃。&lt;/li>
&lt;/ul>
&lt;h2 id="限流算法">限流算法&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>计数器算法&lt;/strong> ：通过维护一个计数器来限制在特定时间间隔内的请求数量。该算法在固定时间窗口内对请求进行计数，当请求数超过设定阈值时，则进行限流处理。
&lt;ul>
&lt;li>原理：在固定时间窗口内限制请求数量。&lt;/li>
&lt;li>优点：实现起来非常简单，逻辑也很直观，易于理解。而且性能高效，因为计数器的操作速度很快，对系统性能的影响很小，内存占用也低，只需维护一个计数器。&lt;/li>
&lt;li>缺点：
&lt;ul>
&lt;li>&lt;strong>缺乏流量整形机制&lt;/strong>，不能确保请求能够连续、平滑地传递到下游服务。这是因为固定窗口计数器算法的放行速率和流量的涌入速率是相同的，所以在处理不规则或者突发流量时，它的效果就不佳。&lt;/li>
&lt;li>&lt;strong>对突发流量的容忍性也比较差&lt;/strong>。如果设置的时间窗口是10秒，阈值是100个请求，那在前1秒内涌入100个请求后，接下来的9s不会再放行请求。即使系统可能在第5秒已经处于空闲状态，具备处理新请求的能力，也只能等到下一个限流周期才行。相比之下漏桶、令牌桶则灵活的多，更能容忍突发流量。&lt;/li>
&lt;li>&lt;strong>窗口边界容易出现过载问题&lt;/strong>。固定窗口算法将时间划分为固定大小的窗口，这种机制在窗口边界可能引发突发请求流量，导致系统的瞬时负载超过预期。比如假设阈值是100个请求，时间窗口是2秒。在当前窗口的最后1秒可能就有100个请求，而在下一个窗口的前1秒又有100个请求。单看窗口，好像限流策略成功，但如果跨越窗口之间来看，实际上在2秒内通过的请求数量可能达到200个，而不是预期的100个。可以用滑动窗口限流算法来解决这个问题。&lt;/li>
&lt;li>&lt;strong>设置恰当的阈值也很难&lt;/strong>。如果阈值设置得过高，系统可能会允许太多请求在短时间内通过，导致负载过重。而如果设置得过低，系统就会频繁拒绝用户请求，这不仅影响用户体验，还有可能浪费宝贵的系统资源。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>适用场景：
&lt;ul>
&lt;li>对请求数量要求不严格的简单限流场景。&lt;/li>
&lt;li>适合资源受限的系统，如内存或处理能力有限的环境。&lt;/li>
&lt;li>不适用于对突发流量敏感或需要精确控制的场景。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>滑动窗口算法&lt;/strong> ：是一种基于时间窗口的限流策略，核心思想是&lt;strong>动态跟踪最近一段时间内的请求数量&lt;/strong>，以适应不均匀的流量，从而有效避免了固定窗口算法所存在的窗口边界问题，同时保持较低的内存开销。
&lt;ul>
&lt;li>原理：将时间窗口细分，动态滑动，提供更平滑的限流效果。&lt;/li>
&lt;li>优点：解决了固定窗口的窗口边界问题：滑动窗口算法通过持续监控和计算时间段内的请求，减少了由于时间窗口结束而导致的请求突然集中涌入的情况。。&lt;/li>
&lt;li>缺点：
&lt;ul>
&lt;li>&lt;strong>缺乏流量整形机制，无法实现平滑限流&lt;/strong>：滑动窗口算法没有流量整形机制，无法确保请求连续、平滑地传递到下游服务。由于滑动窗口算法放行的速率与流量涌入的速率相同，它无法有效管理不规则或突发的流量。流量整形是指针对突发流量进行管理，通过预设的速率稳定地输出请求，以确保发送到后端系统的流量保持在可接受的范围内，从而避免对后端造成冲击。&lt;/li>
&lt;li>&lt;strong>难以设置恰当的阀值&lt;/strong>：如果设置的阀值过高，系统可能会允许过多的请求在短时间内通过，从而导致负载过重。另一方面，如果阀值设置过低，系统将频繁拒绝用户请求，影响用户体验，并浪费宝贵的系统资源。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>适用场景：
&lt;ul>
&lt;li>对请求数量要求不严格的简单限流场景。&lt;/li>
&lt;li>适合资源受限的系统，如内存或处理能力有限的环境。&lt;/li>
&lt;li>不适用于对突发流量敏感或需要精确控制的场景。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>漏桶算法&lt;/strong> ：是一种经典的限流算法，它的核心思想是将请求放入一个固定容量的“桶”中，桶以固定的速率“漏水”（即处理请求）。如果桶满了，则新的请求会被拒绝或排队等待。
&lt;ul>
&lt;li>原理：请求先进入桶中，然后以固定速率处理，超出桶容量的请求被丢弃。&lt;/li>
&lt;li>优点：
&lt;ul>
&lt;li>简单直观：基于桶的模型，算法相对简单，容易实现。&lt;/li>
&lt;li>平滑限流：能够将突发的高峰流量平滑处理，避免对下游系统的瞬时冲击。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点：
&lt;ul>
&lt;li>&lt;strong>延迟响应请求&lt;/strong>：在高流量情况下，请求必须排队等待，可能导致用户体验下降。&lt;/li>
&lt;li>&lt;strong>难以设置恰当的限流阀值&lt;/strong>：如果设置的限流阀值过高，也就是桶的容量过大，那么排队的请求可能超时或者延迟响应，影响用户体验。如果桶的容量过小，那么系统将频繁拒绝用户请求，影响用户体验。&lt;/li>
&lt;li>&lt;strong>难以设置恰当的输出速率&lt;/strong>： 如果设置的漏水速率过高，可能导致下游服务过载。如果设置的漏水速率过低，漏桶缓存请求增加，漏桶满后会频繁拒绝用户请求，影响用户体验。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>适用场景：
&lt;ul>
&lt;li>API限流：防止短时间内接收到过量请求，保护后端服务。&lt;/li>
&lt;li>网络流量控制：管理带宽，确保数据传输的稳定性。&lt;/li>
&lt;li>任务调度：确保任务在执行时保持平稳的速率。&lt;/li>
&lt;li>高并发请求处理：如高并发的Web应用程序，漏桶算法能够平稳处理大量请求。&lt;/li>
&lt;li>服务高可用：控制访问第三方服务的速度，防止压垮下游。控制服务自身的处理速度，方式过载。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>令牌桶算法&lt;/strong> ：一种基于固定容量桶模型的算法，特点是如果请求进入系统的速率超过令牌的生成速率，或者如果一次进入的请求数量超过桶中的令牌数，则请求被限流。它通过动态限制请求进入系统的速率来实现限流，比如，令牌的生成速率是2个/s，桶的容量是10，那么请求进入系统进入的最大速率是10个/s，平均速率2个/s。
&lt;ul>
&lt;li>原理：令牌桶算法的基本构思是使用一个“桶”，其中存放了“令牌”，每个令牌允许处理一个请求。系统以固定的速率向这个桶中生成令牌，直到达到最大的桶容量。如果桶已满，新生成的令牌将会被丢弃。由于令牌可以在桶中累积，这使得算法在遭遇短时间内的请求高峰时，依旧能够保持一定的处理能力。&lt;/li>
&lt;li>优点：
&lt;ul>
&lt;li>&lt;strong>容忍突发流量&lt;/strong>：令牌桶算法能够在一定程度上应对突发流量，当请求量增加时,桶中的令牌会被快速消耗,但只要有新的令牌不断被添加,系统就能够持续处理请求。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点：
&lt;ul>
&lt;li>&lt;strong>实现复杂&lt;/strong>：令牌桶算法的实现和管理需要占用一定的内存和CPU资源。&lt;/li>
&lt;li>&lt;strong>未实现平滑限流&lt;/strong>：令牌桶算法缺少流量整形机制，如果桶容量设置的不好，高峰流量会对下游系统造成瞬时冲击。&lt;/li>
&lt;li>&lt;strong>难以设置恰当的限流阀值&lt;/strong>：如果设置的限流阀值过高，也就是桶的容量过大，当桶满时，突发流量都被允许通过，会导致下游系统过载。如果桶的容量过小，那么系统将频繁拒绝用户请求，系统资源未被充分利用，同时也影响用户体验。&lt;/li>
&lt;li>&lt;strong>难以设置恰当的填充速率&lt;/strong>： 如果设置的令牌生成速率过高，可能导致下游服务过载。如果设置的令牌生成速率过低，会频繁拒绝用户请求，影响用户体验。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>适用场景：
&lt;ul>
&lt;li>API限流：有效控制API的访问速率，防止系统过载。&lt;/li>
&lt;li>网络流量管理：在网络设备中限制带宽使用，能够容忍网络抖动，保障公平性和服务质量。&lt;/li>
&lt;li>服务高可用：控制访问第三方服务的速度，防止压垮下游。控制服务自身的处理速度，方式过载。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="拒绝策略">拒绝策略&lt;/h2>
&lt;p>当请求超过限流阈值时，系统可以采取不同的拒绝策略：&lt;/p></description></item><item><title>区分偶发性超时和频繁超时的重试策略</title><link>https://blog.chensoul.cc/posts/2025/02/14/retry-for-timeout/</link><pubDate>Fri, 14 Feb 2025 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2025/02/14/retry-for-timeout/</guid><description>&lt;p>在实际项目中，区分偶发性超时和频繁超时的重试策略非常重要。偶发性超时可能是由于网络抖动或临时负载过高引起的，适合立即重试；而频繁超时则可能是系统过载或下游服务不可用，此时应避免重试，以免加剧问题。&lt;/p>
&lt;p>在实际面试的过程中，经常会遇到类似的面试题目，这时候可以这样回答：&lt;/p>
&lt;blockquote>
&lt;p>在处理大量请求时，我们经常会遇到超时的情况。为了合理控制重试行为，避免所谓的“重试风暴”，我设计了一个基于时间窗口的算法。在这个算法中，我们维护了一个滑动窗口，窗口内记录了每个请求的时间戳以及该请求是否超时。每当一个请求超时后，我们会统计窗口内超时的请求数量。如果超时请求的数量超过了设定的阈值，我们就认为当前系统压力较大，不适合进行重试；否则，我们认为可以安全地进行重试。&lt;/p>
&lt;p>然而，随着并发量的增加，普通版的滑动窗口算法暴露出了一些问题。特别是在高并发场景下，窗口内需要维护的请求数量可能非常大，这不仅占用了大量内存，而且在判定是否需要重试时还需要遍历整个窗口，这大大增加了算法的时间复杂度。&lt;/p>
&lt;p>为了解决这个问题，我们进一步设计了进阶版的算法。在这个版本中，我们引入了ring buffer 来优化滑动窗口的实现。具体来说，我们不再以时间为窗口大小，而是使用固定数量的比特位来记录请求的超时信息。每个比特位对应一个请求，用1表示超时，用0表示未超时。当所有比特位都被标记后，我们从头开始再次标记。&lt;/p>
&lt;p>这种设计极大地降低了内存占用，因为无论并发量多高，我们只需要固定数量的比特位来记录请求的超时状态。同时，在判定是否需要重试时，我们只需要统计ring buffer中为1的比特数量，这大大简化了算法的实现并提高了效率。&lt;/p></description></item><item><title>ThingsBoard源码中的Github Actions</title><link>https://blog.chensoul.cc/posts/2024/12/03/github-actions-in-thingsboard/</link><pubDate>Tue, 03 Dec 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/12/03/github-actions-in-thingsboard/</guid><description>&lt;p>ThingsBoard 源码地址：&lt;a href="https://github.com/thingsboard/thingsboard" target="_blank">https://github.com/thingsboard/thingsboard&lt;/a>，其 .github/workflows 目录下面有两个文件：&lt;/p>
&lt;ul>
&lt;li>&lt;code>check-configuration-files.yml&lt;/code>：使用 python 脚本校验 yaml 文件&lt;/li>
&lt;li>&lt;code>license-header-format.yml&lt;/code>：是给文件添加 license 并提交代码到 git 仓库&lt;/li>
&lt;/ul>
&lt;h2 id="check-configuration-filesyml">check-configuration-files.yml&lt;/h2>
&lt;p>check-configuration-files.yml&lt;/p></description></item><item><title>ThingsBoard源码中的Security</title><link>https://blog.chensoul.cc/posts/2024/12/03/security-in-thingsboard/</link><pubDate>Tue, 03 Dec 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/12/03/security-in-thingsboard/</guid><description>&lt;p>ThingsBoard 源码地址：&lt;a href="https://github.com/thingsboard/thingsboard" target="_blank">https://github.com/thingsboard/thingsboard&lt;/a>，启动成功之后，使用系统管理员： &lt;a href="mailto:sysadmin@thingsboard.org">sysadmin@thingsboard.org&lt;/a> / sysadmin 进行登陆。&lt;/p>
&lt;h2 id="设置和安全">设置和安全&lt;/h2>
&lt;p>登陆系统之后，点击左边的设置和安全菜单，进行相应的配置。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>设置 -&amp;gt; 基本设置、发送邮件、通知&lt;/p></description></item><item><title>2024-11-14-Quarkus 快速入门</title><link>https://blog.chensoul.cc/posts/2024/11/14/quarkus-quick-start/</link><pubDate>Thu, 14 Nov 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/11/14/quarkus-quick-start/</guid><description>&lt;h2 id="使用--quarkus-cli-创建项目">使用 Quarkus CLI 创建项目&lt;/h2>
&lt;ol>
&lt;li>使用 sdk 安装&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sdk install quarkus
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>创建应用&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>quarkus create &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> cd code-with-quarkus
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>出现异常：&lt;/p></description></item><item><title>[译]从JUnit4迁移到JUnit5：权威指南</title><link>https://blog.chensoul.cc/posts/2024/11/07/junit-5-migration/</link><pubDate>Thu, 07 Nov 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/11/07/junit-5-migration/</guid><description>&lt;p>在本文中，我们将了解从 JUnit 4 迁移到 JUnit 5 所需的步骤。我们将了解如何运行新版本的现有测试，以及迁移代码需要进行哪些更改。&lt;/p>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>JUnit 5 与之前的版本不同，采用模块化设计。新架构的关键点在于将编写测试、扩展和工具之间的关注点分开。&lt;/p></description></item><item><title>ActiveMQ源码-BrokerService和PersistenceAdapter</title><link>https://blog.chensoul.cc/posts/2024/08/27/activemq-source-code-broker-service/</link><pubDate>Tue, 27 Aug 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/08/27/activemq-source-code-broker-service/</guid><description>&lt;p>activemq-broker 模块 test/java 目录下有个 IDERunner 类：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">IDERunner&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> TRANSPORT_TRACE &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span>args) &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BrokerService brokerService &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BrokerService();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// brokerService.addConnector(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// &amp;#34;tcp://0.0.0.0:61616?trace=&amp;#34; + TRANSPORT_TRACE +&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// &amp;#34;&amp;amp;transport.wireFormat.maxFrameSize=104857600&amp;#34;);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> brokerService.&lt;span style="color:#a6e22e">setPersistent&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> brokerService.&lt;span style="color:#a6e22e">setUseJmx&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> brokerService.&lt;span style="color:#a6e22e">setAdvisorySupport&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> brokerService.&lt;span style="color:#a6e22e">start&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> brokerService.&lt;span style="color:#a6e22e">waitUntilStopped&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注释掉 brokerService 调用 addConnector 方法的三行代码，然后 debug 运行该类的 main 方法。&lt;/p></description></item><item><title>ThingsBoard源码编译和Idea运行</title><link>https://blog.chensoul.cc/posts/2024/08/27/thingsboard-code-source-compile/</link><pubDate>Tue, 27 Aug 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/08/27/thingsboard-code-source-compile/</guid><description>&lt;p>ThingsBoard 源码地址：&lt;a href="https://github.com/thingsboard/thingsboard" target="_blank">https://github.com/thingsboard/thingsboard&lt;/a>，从 &lt;a href="https://github.com/thingsboard/thingsboard/releases/tag/v3.7" target="_blank">3.7&lt;/a> 版本之后，要求 JDK17。官方提供了源码编译的文档：&lt;a href="https://thingsboard.io/docs/user-guide/install/building-from-source/" target="_blank">Building from sources&lt;/a>&lt;/p>
&lt;h2 id="源码编译">源码编译&lt;/h2>
&lt;p>下载代码：&lt;/p></description></item><item><title>ActiveMQ源码本地调试运行</title><link>https://blog.chensoul.cc/posts/2024/08/09/debug-activemq-source-code/</link><pubDate>Fri, 09 Aug 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/08/09/debug-activemq-source-code/</guid><description>&lt;h2 id="源码构建">源码构建&lt;/h2>
&lt;p>1、从 &lt;a href="https://github.com/apache/activemq" target="_blank">https://github.com/apache/activemq&lt;/a> 下载源码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git clone https://github.com/apache/activemq
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>2、切换至 activemq-5.18.x 分支&lt;/p></description></item><item><title>Github Action 发布 Jar 到 Maven 中央仓库</title><link>https://blog.chensoul.cc/posts/2024/08/01/publishing-a-jar-to-maven-repository-with-github-action/</link><pubDate>Thu, 01 Aug 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/08/01/publishing-a-jar-to-maven-repository-with-github-action/</guid><description>&lt;p>作为一名 Java 开发者,将自己的项目发布到 Maven 中央仓库是一个非常重要的步骤。这不仅可以让更多的开发者发现和使用您的项目,也可以提高项目的知名度和影响力。&lt;/p>
&lt;p>在过去,发布 Jar 到 Maven 中央仓库通常需要手动完成一系列繁琐的步骤，比如：申请 JIRA 账号、创建 Sonatype JIRA Issure、上传 Jar 包、签名 Jar 包等。但是随着 Github Action 的出现，这个过程变得更加自动化和简单。&lt;/p></description></item><item><title>[译]JMS 2.0 中的新增功能</title><link>https://blog.chensoul.cc/posts/2024/07/24/what-is-new-in-jms-2-0/</link><pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/24/what-is-new-in-jms-2-0/</guid><description>&lt;p>原文链接：&lt;a href="https://hasithah.medium.com/what-is-new-in-jms-2-0-821266fc1bf0" target="_blank">What is new in JMS 2.0&lt;/a>&lt;/p>
&lt;p>在在软件集成领域，从一个软件组件到另一个软件组件进行通信是一项基本要求。虽然已经出现了许多具有这种能力的技术，但 Java 编程语言为我们提供了一个 API，以促进用 Java 编写的组件之间的消息传递。此 API 的实现将由不同的供应商（JMS 提供商）通过代理软件提供。&lt;/p></description></item><item><title>[译]JMS 2.0 中的新增功能（第一部分）- 易于使用</title><link>https://blog.chensoul.cc/posts/2024/07/24/jms20/</link><pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/24/jms20/</guid><description>&lt;p>原文链接：&lt;a href="https://www.oracle.com/technical-resources/articles/java/jms20.html" target="_blank">https://www.oracle.com/technical-resources/articles/java/jms20.html&lt;/a>&lt;/p>
&lt;p>&lt;em>作者：Nigel Deakin&lt;/em>
出版日期：2013 年 5 月&lt;/p>
&lt;p>&lt;strong>了解新的易用性功能如何使您编写更少的代码行。&lt;/strong>&lt;/p>
&lt;p>本文是两部分系列文章的第一部分，假设读者对 Java 消息服务 (JMS) 1.1 有基本了解，并介绍了 JMS 2.0 中的一些新的易用特性。在&lt;a href="https://www.oracle.com/technical-resources/articles/java/jms2messaging.html" target="_blank">第二部分&lt;/a>中，我们将介绍新的消息传递特性。&lt;/p></description></item><item><title>[译]JMS 2.0 中的新增功能（第二部分）- 新的消息传送功能</title><link>https://blog.chensoul.cc/posts/2024/07/24/jms20/</link><pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/24/jms20/</guid><description>&lt;p>原文链接：&lt;a href="https://www.oracle.com/technical-resources/articles/java/jms2messaging.html" target="_blank">https://www.oracle.com/technical-resources/articles/java/jms2messaging.html&lt;/a>&lt;/p>
&lt;p>&lt;em>作者：Nigel Deakin&lt;/em>
出版日期：2013 年 5 月&lt;/p>
&lt;p>&lt;strong>了解如何利用 JMS 2.0 中的新消息传递功能。&lt;/strong>&lt;/p></description></item><item><title>[译]JMS 2.0 的十个好处意味着可以减少代码编写量</title><link>https://blog.chensoul.cc/posts/2024/07/24/jms20-means-less-code/</link><pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/24/jms20-means-less-code/</guid><description>&lt;p>原文链接：&lt;a href="https://javaee.github.io/jms-spec/pages/JMS20MeansLessCode" target="_blank">Ten ways in which JMS 2.0 means writing less code&lt;/a>&lt;/p></description></item><item><title>[译]JMS 事务的实际应用</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-transactions-in-action/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-transactions-in-action/</guid><description>&lt;p>在本文中，您将了解如何选择性地使用 JMS 事务。在 JMS 中，您可以选择控制一个会话的原子操作。每个会话都支持一系列事务。每个事务将一组生成或使用的消息分组为一个原子工作单元。确保您已经理解了&lt;a href="https://jstobigdata.com/jms/guaranteed-delivery-using-jms-message-acknowledgement/" target="_blank">JMS 中的消息确认&lt;/a>。&lt;/p>
&lt;p>&lt;strong>交易提交时 –&lt;/strong> ( &lt;code>jmsContext.commit()&lt;/code>)&lt;/p></description></item><item><title>[译]JMS 发布-订阅消息模型</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-pub-sub-messaging-model/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-pub-sub-messaging-model/</guid><description>&lt;p>在本文中，您将了解 JMS 发布-订阅 (publish-subscribe) 消息传递模型。正如您在&lt;a href="https://jstobigdata.com/jms/jms-introduction-java-message-service/" target="_blank">JMS 简介文章&lt;/a>中所读到的，在发布/订阅模型中，客户端通过称为主题的中介将消息发送给多个接收者。发送者通常称为发布者，接收者称为订阅者。&lt;/p>
&lt;h2 id="jms-发布订阅消息传递示例">JMS 发布/订阅消息传递示例&lt;/h2>
&lt;p>下面是一个简单的代码示例，演示了发布/订阅消息模型的工作原理。我创建了 2 个主线程，&lt;code>publisher&lt;/code>和&lt;code>subscriber1&lt;/code>。将订阅者 1 克隆到&lt;code>subscriber2&lt;/code>。所以基本上我有一个消息发布者和 2 个消息订阅者。链接至&lt;a href="https://github.com/jstobigdata/jms-parent-app/blob/master/jms-glassfish5/src/main/java/lab03/message/pubsub/SimplePubSubExample.java" target="_blank">GitHub&lt;/a> 。&lt;/p></description></item><item><title>[译]JMS 消息优先级</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-prioritize-messages/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-prioritize-messages/</guid><description>&lt;p>我们将通过示例详细讨论 JMS 消息优先级。每条消息的标头字段代表其优先级。我在消息模型教程&lt;code>JMSPriority&lt;/code>中讨论过消息优先级。&lt;/p>
&lt;p>JMS 有 10 个优先级，从 0 到 9。0 是最低优先级，9 是最高优先级。根据 JMS 标准，优先级为 0-4 的消息为正常优先级，优先级为 5-9 的消息被视为加急优先级。&lt;/p></description></item><item><title>[译]JMS 消息模型</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-message-model/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-message-model/</guid><description>&lt;p>消息是 JMS 的核心，无论是事件还是业务数据。消息由标头、自定义属性和正文组成。这是您将在 JMS 消息模型（JMS 消息剖析）中学习的内容。&lt;/p>
&lt;p>&lt;img src="https://blog.chensoul.cc/images/JMS-message-model-min-1024x536.webp" alt="JMS 消息模型">&lt;/p></description></item><item><title>[译]JMS 消息选择器在过滤消息中的应用</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-message-selectors-in-action-to-filter-messages/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-message-selectors-in-action-to-filter-messages/</guid><description>&lt;p>发送给接收方的消息通常需要根据某些标准进行过滤。JMS 提供消息选择器，允许 JMS 消费者根据消息头指定其感兴趣的消息。在本文中，您将学习使用 JMS 消息选择器来过滤消息。&lt;/p>
&lt;p>这是一篇高级教程，在继续阅读本文之前，请确保您对 JMS 有基本的了解。如果您是 JMS 新手，请查看&lt;a href="https://jstobigdata.com/jms/jms-point-to-point-messaging-in-action/" target="_blank">JMS 点对点消息传递模型文章。&lt;/a>&lt;/p></description></item><item><title>[译]JMS 点对点消息传递的实际应用</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-point-to-point-messaging-in-action/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-point-to-point-messaging-in-action/</guid><description>&lt;p>点对点系统使用队列进行消息传递。客户端将消息发送到特定队列，特定订阅者监听或接收来自该队列的消息。在 JMS 点对点消息传递系统中，队列用于处理单个发送者和单个消费者。确保您已经阅读了有关&lt;a href="https://jstobigdata.com/jms/jms-message-model/" target="_blank">JMS 消息模型&lt;/a>以及&lt;a href="https://jstobigdata.com/jms/send-and-receive-message-in-jms/" target="_blank">如何在 JMS 中发送和接收消息的&lt;/a>先前教程。&lt;/p>
&lt;h2 id="使用队列进行-ptp-消息传送">使用队列进行 PTP 消息传送&lt;/h2>
&lt;p>您现在知道点对点消息传递完全是利用队列。JMS 提供&lt;code>javax.jms.Queue&lt;/code>表示队列对象的功能。我将利用 JMS 2.0 API 来&lt;code>javax.jms.JMSProducer&lt;/code>发送&lt;code>javax.jms.JMSConsumer&lt;/code>和接收消息。&lt;/p></description></item><item><title>[译]JMS介绍 – Java消息服务</title><link>https://blog.chensoul.cc/posts/2024/07/23/jms-introduction-java-message-service/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/jms-introduction-java-message-service/</guid><description>&lt;p>JMS 代表 Java 消息服务，它是 Java 中访问消息中间件服务器的标准。这是一个 JMS 介绍教程，为您提供消息传递和 JMS 的简要概述。您将了解使用 JMS 的优势以及 JMS 中的不同消息传递模型。&lt;/p></description></item><item><title>[译]为 JMS 安装和设置 Glassfish</title><link>https://blog.chensoul.cc/posts/2024/07/23/install-and-setup-glassfish-for-jms/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/install-and-setup-glassfish-for-jms/</guid><description>&lt;p>在本文中，我们将为 JMS 2.0 设置 Glassfish，创建一个 Java 项目并添加必要的依赖项。&lt;/p>
&lt;h2 id="先决条件">先决条件&lt;/h2>
&lt;p>请确保您的系统上安装了以下工具。&lt;/p></description></item><item><title>[译]使用 JMS 消息确认保证传送</title><link>https://blog.chensoul.cc/posts/2024/07/23/guaranteed-delivery-using-jms-message-acknowledgement/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/guaranteed-delivery-using-jms-message-acknowledgement/</guid><description>&lt;p>JMS 通过 JMS 消息确认（确认模式）确保消息传递的可靠性。如果会话已进行事务处理，则该&lt;code>commit()&lt;/code>方法会自动处理消息确认。否则，该方法将处理恢复&lt;code>rollback()&lt;/code>。在本文中，我们将假设会话未进行事务处理。这是一个高级主题，请确保您对 JMS 有基本的了解。如果您是 JMS 新手，可以参考使用 JMS&lt;a href="https://jstobigdata.com/jms/send-and-receive-message-in-jms/" target="_blank">发送和接收消息。&lt;/a>&lt;/p></description></item><item><title>[译]在 JMS 中发送和接收消息</title><link>https://blog.chensoul.cc/posts/2024/07/23/send-and-receive-message-in-jms/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/send-and-receive-message-in-jms/</guid><description>&lt;p>您将了解 JMS 架构，学习如何在 JMS 中发送和接收消息。我将介绍管理对象、JMS 1.1 API 和 JMS 2.0 API。我们还将看到与 JMS 1.1 API 相比，JMS 2.0 API 的使用有多么简单。在继续学习本课程之前，请确保您已完成 JMS 设置。如果您是初学者，请确保您已了解&lt;a href="https://jstobigdata.com/jms/jms-introduction-java-message-service/" target="_blank">JMS 的基础知识&lt;/a>。&lt;/p></description></item><item><title>[译]完整的 JMS 2.0 教程</title><link>https://blog.chensoul.cc/posts/2024/07/23/a-complete-jms-2-0-tutorial/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/23/a-complete-jms-2-0-tutorial/</guid><description>&lt;p>JMS 代表 Java 消息服务，它是 Java 中访问消息中间件服务器的标准。消息传递是在各种应用程序或服务之间交换业务数据的过程。这是&lt;strong>一个完整的 JMS 2.0 教程，&lt;/strong> 其中包含大量代码示例。完整的代码示例可在 GitHub 上找到，请下载并运行示例。本教程使用 Glassfish 开源服务器作为 JMS 提供程序的示例。&lt;/p></description></item><item><title>将 Maven 站点发布到 GitHub Pages</title><link>https://blog.chensoul.cc/posts/2024/07/18/publishing-a-maven-site-to-github-pages/</link><pubDate>Thu, 18 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/07/18/publishing-a-maven-site-to-github-pages/</guid><description>&lt;p>本文源代码：&lt;a href="https://github.com/chensoul/maven-site-github-example/" target="_blank">https://github.com/chensoul/maven-site-github-example/&lt;/a> 。&lt;/p>
&lt;h2 id="创建-java-maven-项目">创建 Java Maven 项目&lt;/h2>
&lt;p>让我们使用 Maven 创建一个简单的 Java 项目&lt;/p></description></item><item><title>All things about OAuth</title><link>https://blog.chensoul.cc/posts/2024/06/06/all-things-about-oauth/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/06/all-things-about-oauth/</guid><description>&lt;p>OAuth 是一种&lt;strong>开放协议&lt;/strong>，允许通过网络、移动和桌面应用程序以&lt;strong>简单&lt;/strong>、&lt;strong>标准的方式进行&lt;/strong>安全授权。&lt;/p>
&lt;h2 id="oauth-2-入门">OAuth 2 入门&lt;/h2>
&lt;p>以下是一些 OAuth 2.0 指南，涵盖了理解和实现客户端和服务器所需的许多主题。&lt;/p></description></item><item><title>JWT</title><link>https://blog.chensoul.cc/posts/2024/06/06/jwt/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/06/jwt/</guid><description>&lt;h2 id="什么是-jwt">什么是 JWT？&lt;/h2>
&lt;p>JWT（JSON Web Token）是一种开放标准(RFC 7519)，用于在网络应用程序之间安全地传输信息。它被设计用于在两方之间传输声明，这些声明可以是身份验证和授权信息，也可以是任何其他类型的信息。&lt;/p>
&lt;p>设计目的：不需要服务器端存储状态，安全地传递非敏感信息。&lt;/p>
&lt;h2 id="jwt-特点">JWT 特点&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>可扩展性&lt;/strong>：可以在 payload 中携带任意的 JSON 数据&lt;/li>
&lt;li>&lt;strong>自包含性&lt;/strong>：所有用户相关信息都在 JWT 中，不需要依赖数据库&lt;/li>
&lt;li>&lt;strong>无状态性&lt;/strong>：服务器不需要保存会话状态，提高了系统的可扩展性&lt;/li>
&lt;li>&lt;strong>跨域支持&lt;/strong>：可以跨域传递，因为是 JSON 格式&lt;/li>
&lt;li>&lt;strong>安全性&lt;/strong>：通过签名确保数据不被篡改&lt;/li>
&lt;/ul>
&lt;h2 id="jwt-组成">JWT 组成&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>eyJraWQiOiJmYTNkZmZjMS0xZmQ3LTRhM2QtYTEyMC1mNjY4OWE4NDM5YjQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJjbGllbnQiLCJhdWQiOiJjbGllbnQiLCJuYmYiOjE3MTc1NDk5NDMsImlzcyI6Imh0dHA6Ly9sb2NhbGhvc3Q6ODA4MCIsImV4cCI6MTcxNzU1MDI0MywiaWF0IjoxNzE3NTQ5OTQzLCJqdGkiOiJiMjU0ZGVhMi1kMWE2LTQxNzEtYjEyYy1lNmYzYzZjMDJkMGQifQ.eRiS0H2E-h5PiDEfJikjoPGH1DCqWVt4VIzLtPoSOaIK6jBIaw0h5m-reZVUyZPNYZG68Ymhey17aZBMveirqCxN-lNcPMIGfuqMptfsD9E6Hfam6bEMgpEAOQsQ6Ruk3vGtdmjnEC2h9ZStoqT5-C6JgArwFLGgX92LXrRYz7-60n0I6EAB07u9kxc6FQKLow90RiyXi2YLur-ttOUQpecf8zHi48zRc-HLLoWAMaNddT-4hg4v0Qts4DultpxZB_Xu7DRc91G_8M6sYFSvFSVFHlcWFgKNLZqUYwepLHX2LxoXdbTLGqV9x__-J8UO0TO3TkpC2BaZAiseYcpYMw
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>JWT 主要有以下三个部分通过 base64 加密组成:&lt;/p></description></item><item><title>OAuth2和OIDC区别</title><link>https://blog.chensoul.cc/posts/2024/06/06/oauth2-oidc/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/06/oauth2-oidc/</guid><description>&lt;h2 id="认证和授权">认证和授权&lt;/h2>
&lt;p>&lt;strong>认证 (Authentication)&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>认证是验证用户、设备或系统身份的过程。&lt;/li>
&lt;li>常见的认证方式包括用户名/密码、生物特征(如指纹、人脸)、单点登录(SSO)等。&lt;/li>
&lt;li>认证确保只有被授权的实体才能访问系统或资源。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>授权 (Authorization)&lt;/strong>：&lt;/p></description></item><item><title>[译]OAuth2.0服务器</title><link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-server/</link><pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-server/</guid><description>&lt;h1 id="背景">背景&lt;/h1>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>&lt;em>作者：&lt;a href="https://aaronparecki.com/" target="_blank">Aaron Parecki&lt;/a>&lt;/em>&lt;/p>
&lt;p>我第一次接触 OAuth 是在 2010 年，当时我正在构建一个 API，我知道我希望第三方开发人员能够在其基础上构建应用程序。当时，OAuth 看起来令人生畏。OAuth 1 的实现只有少数几个，而 OAuth 2.0 仍是一个草稿。一天晚上，我决定坐下来，拿着精酿啤酒和最新草案的纸质副本，从头到尾阅读它，直到我理解它。&lt;/p></description></item><item><title>[译]OAuth2简化版</title><link>https://blog.chensoul.cc/posts/2024/06/05/oauth-2-simplified/</link><pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/05/oauth-2-simplified/</guid><description>&lt;p>这篇文章以简化的格式描述了 OAuth 2.0，以帮助开发人员和服务提供商实现该协议。&lt;/p>
&lt;p>&lt;a href="https://oauth.net/2/" target="_blank">OAuth 2 规范&lt;/a>读起来可能有点混乱，所以我写了这篇文章来帮助以简化的格式描述术语。核心规范将许多决策留给实现者，通常基于实现的安全权衡。这篇文章没有描述成功实施 OAuth 2 所需的所有可能决策，而是做出适用于大多数实现的决策。&lt;/p></description></item><item><title>RFC6749 | OAuth2.0授权框架中文版</title><link>https://blog.chensoul.cc/posts/2024/06/05/oauth2/</link><pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;h3 id="摘要">摘要&lt;/h3>
&lt;p>OAuth2.0 授权框架允许第三方应用获取对 HTTP 服务的有限的访问权限，既可以以资源所有者名义在资源所有者和 HTTP 服务之间进行允许的交互，也可以允许第三方应用以自己的名义进行访问。本规范取代并淘汰 RFC 5849 中描述的 OAuth 1.0 协议。&lt;/p></description></item><item><title>All things about WebSocket</title><link>https://blog.chensoul.cc/posts/2024/05/10/all-things-about-websocket/</link><pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/10/all-things-about-websocket/</guid><description>&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank">Wikipedia：WebSocket&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" target="_blank">WebSocket - Web APIs | MDN&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.pubnub.com/guides/websockets/" target="_blank">PubNub：什么是 WebSocket？&lt;/a>&lt;/p></description></item><item><title>All things about Spring Modulith</title><link>https://blog.chensoul.cc/posts/2024/05/09/all-things-about-spring-modulith/</link><pubDate>Thu, 09 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/09/all-things-about-spring-modulith/</guid><description>&lt;p>VMware 推出了一个实验性的项目&lt;a href="https://spring.io/projects/spring-modulith" target="_blank">Spring Modulith&lt;/a>，以便于通过模块和事件更好地组织 Spring Boot 3 应用。该项目引入了新的类和注解，但并不会生成代码。它的模块没有使用 Java Platform Module System（JPMS），而是映射到了普通的 Java 包。模块有 API，但是 Spring Modulith 鼓励使用 Spring 应用事件作为“主要的交互方式”。这些事件可以自动持久化到事件日志中。Spring Modulith 还简化了模块和事件的测试。&lt;/p></description></item><item><title>[译]探索 http2（第 1 部分）：概述</title><link>https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-1-overview/</link><pubDate>Wed, 08 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-1-overview/</guid><description>&lt;p>原文链接：&lt;a href="https://noobj.medium.com/exploring-http2-part-1-overview-dc3e9b53968f" target="_blank">https://noobj.medium.com/exploring-http2-part-1-overview-dc3e9b53968f&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>让我们来谈谈&lt;/em> &lt;strong>http2 的内容、原因、时间和方式&lt;/strong>&lt;/p>&lt;/blockquote>
&lt;p>完整的代码可以在&lt;a href="https://github.com/noobg1/http1_vs_http2" target="_blank">github&lt;/a>上找到。&lt;/p>
&lt;p>&lt;strong>第 1 部分：概述&lt;/strong>
第 2 部分：&lt;a href="https://medium.com/@noobj/exploring-http2-part-2-with-node-http2-core-and-hapijs-74e3df14249" target="_blank">使用 node-http2 核心和 hapijs 进行探索&lt;/a>&lt;/p></description></item><item><title>[译]探索 http2（第 2 部分）：使用 node-http2 核心和 hapijs</title><link>https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-2-overview/</link><pubDate>Wed, 08 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/08/exploring-http2-part-2-overview/</guid><description>&lt;p>原文链接：&lt;a href="https://noobj.medium.com/exploring-http2-part-2-with-node-http2-core-and-hapijs-74e3df14249" target="_blank">https://noobj.medium.com/exploring-http2-part-2-with-node-http2-core-and-hapijs-74e3df14249&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://blog.chensoul.cc/images/exploring-http2-part-2-overview-01.webp" alt="img">&lt;/p>
&lt;p>来源：&lt;a href="https://www.thewebmaster.com/hosting/2015/dec/14/what-is-http2-and-how-does-it-compare-to-http1-1/" target="_blank">https://www.thewebmaster.com/&lt;/a>&lt;/p>
&lt;p>&lt;strong>先决条件&lt;/strong>：了解 javascript、客户端-服务器架构。&lt;/p>
&lt;p>完整的代码可以在&lt;a href="https://github.com/noobg1/http1_vs_http2" target="_blank">github&lt;/a>上找到。&lt;/p>
&lt;p>第 1 部分：&lt;a href="https://medium.com/@noobj/exploring-http2-part-1-overview-dc3e9b53968f" target="_blank">概述（&lt;em>http2 的原因、内容、时间、方式&lt;/em>）&lt;/a>&lt;strong>第 2 部分：使用 node-http2 核心和 hapijs 进行探索&lt;/strong>&lt;/p></description></item><item><title>[译]比较 Socket.IO 和 HTTP：主要区别和用例</title><link>https://blog.chensoul.cc/posts/2024/05/08/socketio-vs-http/</link><pubDate>Wed, 08 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/08/socketio-vs-http/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/socketio-vs-http" target="_blank">https://ably.com/topic/socketio-vs-http&lt;/a>&lt;/p>
&lt;p>在规划实时应用程序时，您应该仔细考虑要使用哪些技术。本文对&lt;a href="https://ably.com/topic/socketio" target="_blank">Socket.IO&lt;/a>实时库和&lt;a href="https://ably.com/topic/websockets-vs-http#http" target="_blank">HTTP&lt;/a>协议进行了比较。下面您将了解每种解决方案的功能、每种解决方案的优缺点以及何时使用它们。&lt;/p>
&lt;h2 id="什么是socketio">什么是Socket.IO？&lt;/h2>
&lt;p>Socket.IO 是一个创建于 2010 年的库，提供客户端和服务器之间的实时双向通信。它允许管理连接、发送和接收消息等等。这使得 Socket.IO 成为构建消息/聊天应用程序的理想选择。&lt;/p></description></item><item><title>[译]2024年最好的WebSocket替代品</title><link>https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/websocket-alternatives" target="_blank">https://ably.com/topic/websocket-alternatives&lt;/a>&lt;/p>
&lt;h2 id="什么是-websocket">什么是 WebSocket？&lt;/h2>
&lt;p>简而言之，WebSocket 是一种实时 Web 技术，可通过持久连接在客户端和服务器之间实现双向、全双工通信。 WebSocket 连接会根据需要保持活动状态（理论上，它可以永远持续），从而允许服务器和客户端以最小的开销随意发送数据。&lt;/p></description></item><item><title>[译]Apache Kafka、RabbitMQ 与 AWS SNSSQS：哪个消息代理最好？</title><link>https://blog.chensoul.cc/posts/2024/05/07/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs" target="_blank">https://ably.com/topic/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs&lt;/a>&lt;/p>
&lt;p>将消息从一个组件获取到另一个组件是微服务架构中最重要的部分之一。每个服务必须能够与任何其他服务异步、可靠且大规模地通信。&lt;/p>
&lt;p>这就是消息代理的用武之地。消息代理（例如 Apache Kafka、RabbitMQ 和&lt;a href="https://ably.com/topic/aws-sns-vs-sqs" target="_blank">AWS SNS/SQS&lt;/a>）为您提供一个通用接口和一组保证，而不是手动协调可能数千个微服务之间的通信。这简化了集成并更容易推理您的系统。&lt;/p>
&lt;p>然而，比较消息代理可能很棘手，因为每个消息代理都采用不同的方法来完成工作。那么，您如何决定哪个消息代理最适合您的用例？&lt;/p></description></item><item><title>[译]HTTP 的演变 – HTTP2 深入探讨</title><link>https://blog.chensoul.cc/posts/2024/05/07/http2/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/http2/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/http2" target="_blank">https://ably.com/topic/http2&lt;/a>&lt;/p>
&lt;p>可以毫不夸张地说，超文本传输协议 (HTTP) 造就了我们所熟知的互联网。 HTTP 最初是由万维网的发明者蒂姆·伯纳斯·李 (Tim Berners-Lee) 于 1989 年提出的应用程序协议。第一个记录版本 HTTP/0.9 被称为单行协议。鉴于它催生了万维网，它现在可以被描述为有史以来最伟大的俏皮话。&lt;/p></description></item><item><title>[译]Java和WebSockets：构建可靠的实时应用程序</title><link>https://blog.chensoul.cc/posts/2024/05/07/websockets-java/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websockets-java/</guid><description>&lt;p>原文：&lt;a href="https://ably.com/topic/websockets-java" target="_blank">https://ably.com/topic/websockets-java&lt;/a>&lt;/p>
&lt;p>在全球范围内，人们对实时传输数据的需求不断增长，&lt;a href="https://ably.com/topic/websockets" target="_blank">WebSocket&lt;/a>可能是此类用例中最流行的传输协议。在 WebSocket 出现之前，“实时”网络已经存在，但它很难实现，通常速度较慢，并且是通过破解现有的网络技术来实现的，而这些技术并不是为实时应用程序设计的。 WebSocket 协议为真正的实时网络铺平了道路。&lt;/p>
&lt;p>Java是一种流行的编程语言和计算语言。它是 Android 智能手机应用程序的核心编程语言之一，是构建实时系统的可靠选择。 WebSockets 成为 Java 标准版 SDK 的一部分已经有一段时间了。WebSocket 协议最初是在 2013 年作为&lt;a href="https://www.oracle.com/technical-resources/articles/java/jsr356.html" target="_blank">JSR 356&lt;/a>的一部分提出的，目前已作为&lt;a href="https://docs.oracle.com/javaee/7/api/index.html?javax/websocket/package-summary.html" target="_blank">javax.websocket&lt;/a>包的一部分包含在 Java SDK 中。&lt;/p></description></item><item><title>[译]WebSocket API和协议说明</title><link>https://blog.chensoul.cc/posts/2024/05/07/the-websocket-api-and-protocol-explained/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/the-websocket-api-and-protocol-explained/</guid><description>&lt;p>原文地址：&lt;a href="https://ably.com/topic/websockets" target="_blank">https://ably.com/topic/websockets&lt;/a>&lt;/p>
&lt;p>WebSocket 标志着 Web 开发的转折点。 WebSocket 技术旨在以事件为驱动，并针对低延迟进行了优化，已成为许多寻求构建交互式实时数字体验以提供令人愉悦的用户体验的组织和开发人员的首选。本文探讨了与 WebSocket 相关的关键主题：&lt;/p></description></item><item><title>[译]WebSocket与HTTP：2024年为您的项目选择哪一个</title><link>https://blog.chensoul.cc/posts/2024/05/07/websockets-vs-http/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websockets-vs-http/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/websockets-vs-http" target="_blank">https://ably.com/topic/websockets-vs-http&lt;/a>&lt;/p>
&lt;p>当谈到 WebSocket 与 HTTP 时，决定使用哪一种并不总是那么明确。哪一个更好？您的应用程序应该使用哪一款？&lt;/p>
&lt;p>但问题的答案不一定是其中之一 - 开发人员经常根据场景在同一个应用程序中同时使用 WebSocket 和 HTTP。更重要的问题是 - 我如何确定 WebSockets 还是 HTTP 是特定类型通信的正确通信协议？&lt;/p></description></item><item><title>[译]WebSocket与REST</title><link>https://blog.chensoul.cc/posts/2024/05/07/websocket-vs-rest/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websocket-vs-rest/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/websocket-vs-rest" target="_blank">https://ably.com/topic/websocket-vs-rest&lt;/a>&lt;/p>
&lt;p>无论您是将客户端连接到服务器、将微服务相互连接，还是将应用程序的一部分连接到外部服务，在通信方法方面，您几乎都会有多种选择。不过，有两个比较突出：WebSocket 和 REST。&lt;/p>
&lt;p>好消息是，尽管为应用程序选择核心技术是一项严肃的责任，但由于 WebSocket 和 REST 不同的架构选择、性能特征和实现考虑因素，在 WebSocket 和 REST 之间进行选择相对简单。这意味着双方都可以解决对方可能遇到的问题。&lt;/p></description></item><item><title>[译]什么是 HTTP？</title><link>https://blog.chensoul.cc/posts/2024/05/07/http/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/http/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/http/" target="_blank">https://www.pubnub.com/guides/http/&lt;/a>&lt;/p>
&lt;h2 id="http-概述">HTTP 概述&lt;/h2>
&lt;p>HTTP，即超文本传输协议，是互联网通信的基础。它在客户端-服务器模型上运行，其中前端客户端（例如网络浏览器）通过向服务器发送HTTP请求消息来发起请求，例如请求网页（例如搜索引擎）。然后，服务器使用包含所请求资源的 HTTP 响应消息进行响应，如果资源不可用，则使用错误消息进行响应。&lt;/p>
&lt;p>HTTP 是一种无状态协议，这意味着每个请求都是独立的，与之前或将来的请求无关。这允许客户端和服务器之间进行有效的通信。&lt;/p></description></item><item><title>[译]什么是 OAuth？</title><link>https://blog.chensoul.cc/posts/2024/05/07/oauth/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/oauth/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/oauth/" target="_blank">https://www.pubnub.com/guides/oauth/&lt;/a>&lt;/p>
&lt;h2 id="什么是-oauth">什么是 OAuth？&lt;/h2>
&lt;p>&lt;a href="https://oauth.net/" target="_blank">OAuth（开放授权）&lt;/a>是一种开放标准授权框架，允许第三方应用程序访问用户数据，而无需用户共享其登录凭据。它为用户提供了一种安全且标准化的方式，将其在一个网站上的资源的访问权限授予另一个网站或应用程序，而无需暴露其密码。&lt;/p>
&lt;p>简单来说，OAuth 充当最终用户和他们想要授予访问权限的应用程序之间的中间人。用户不会直接向 Web 应用程序提供用户名和密码，而是会被重定向到授权服务器（例如 Google、Facebook 或 Twitter），在那里他们可以安全地验证自己的身份。经过身份验证后，用户可以授予或拒绝对其想要使用的应用程序上的数据的访问权限。&lt;/p></description></item><item><title>[译]什么是HTTP/3？</title><link>https://blog.chensoul.cc/posts/2024/05/07/http3/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/http3/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/http-3/" target="_blank">https://www.pubnub.com/guides/http-3/&lt;/a>&lt;/p>
&lt;h2 id="什么是-http3">什么是 HTTP/3？&lt;/h2>
&lt;p>HTTP/3（或 HTTP-over-QUIC）是超文本传输协议 ( &lt;a href="https://www.pubnub.com/guides/http/" target="_blank">HTTP&lt;/a> ) 的第三个主要版本。它是用于 Web 浏览器和服务器之间通信的应用层协议。 HTTP/3 旨在提高 Web 通信的性能和安全性。&lt;/p></description></item><item><title>[译]什么是HTTP流式传输？</title><link>https://blog.chensoul.cc/posts/2024/05/07/http-streaming/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/http-streaming/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/http-streaming/" target="_blank">https://www.pubnub.com/guides/http-streaming/&lt;/a>&lt;/p>
&lt;h2 id="什么是-http-流式传输">什么是 HTTP 流式传输？&lt;/h2>
&lt;p>HTTP 流，也称为基于 HTTP 的流或 HTTP 实时流，是一种用于通过 Internet 传送实时多媒体内容（例如音频或视频）的技术。该协议允许从服务器到客户端设备的连续数据传输，使用户能够消费媒体内容而无需完整的文件下载。&lt;/p></description></item><item><title>[译]什么是Socket.IO？</title><link>https://blog.chensoul.cc/posts/2024/05/07/socket-io/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/socket-io/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/socket-io/" target="_blank">https://www.pubnub.com/guides/socket-io/&lt;/a>&lt;/p>
&lt;h1 id="什么是socketio">什么是Socket.IO？&lt;/h1>
&lt;p>&lt;a href="https://socket.io/" target="_blank">Socket.IO&lt;/a>是一个开源的跨平台库，它提供客户端和服务器之间基于事件的&lt;a href="https://www.geeksforgeeks.org/transmission-modes-computer-networks/" target="_blank">全双工双向通信&lt;/a>。它基于 WebSocket 协议构建，提供附加功能，例如自动重新连接以及在无法使用 &lt;a href="https://www.pubnub.com/guides/what-are-websockets-and-when-should-you-use-them/" target="_blank">WebSocket时回退到&lt;/a>&lt;a href="https://www.pubnub.com/blog/http-long-polling/" target="_blank">HTTP 长轮询。&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://blog.chensoul.cc/images/Client_Server.webp" alt="img">&lt;/p>
&lt;p>Socket.IO 客户端由客户端和服务器端库组成。虽然最初在服务器上支持&lt;a href="https://www.pubnub.com/blog/nodejs-websocket-programming-examples/" target="_blank">NodeJS ，在客户端支持&lt;/a>&lt;a href="https://www.pubnub.com/guides/javascript/" target="_blank">JavaScript&lt;/a>，但现在它支持各种服务器和客户端技术，包括&lt;a href="https://www.pubnub.com/docs/sdks/java" target="_blank">Java&lt;/a>、&lt;a href="https://www.pubnub.com/docs/sdks/python" target="_blank">Python&lt;/a>、&lt;a href="https://www.pubnub.com/docs/sdks/swift" target="_blank">Swift&lt;/a>和&lt;a href="https://www.pubnub.com/docs/sdks/kotlin" target="_blank">Kotlin&lt;/a>，它们都是官方代码库的一部分，由活跃社区贡献。&lt;/p></description></item><item><title>[译]什么是WebSocket？</title><link>https://blog.chensoul.cc/posts/2024/05/07/websockets/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websockets/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/websockets/" target="_blank">https://www.pubnub.com/guides/websockets/&lt;/a>&lt;/p>
&lt;h2 id="什么是-websocket">什么是 WebSocket？&lt;/h2>
&lt;p>&lt;a href="https://www.pubnub.com/guides/tcp-ip/" target="_blank">WebSocket 是一种通过单个TCP&lt;/a>连接提供全双工通信通道的通信协议。它支持客户端和服务器之间的实时、事件驱动的连接。&lt;/p>
&lt;p>与遵循请求-响应模型的传统 HTTP 软件不同，WebSocket 允许双向（双向）通信。这意味着客户端和服务器可以随时向对方发送数据，而无需持续轮询。&lt;/p></description></item><item><title>[译]什么是长轮询？</title><link>https://blog.chensoul.cc/posts/2024/05/07/long-polling/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/long-polling/</guid><description>&lt;p>原文链接：&lt;a href="https://www.pubnub.com/guides/long-polling/" target="_blank">https://www.pubnub.com/guides/long-polling/&lt;/a>&lt;/p>
&lt;h2 id="什么是长轮询">什么是长轮询？&lt;/h2>
&lt;p>长轮询用于实时 Web 应用程序，以实现客户端和 Web 服务器之间近乎即时的通信。它在实时更新至关重要的聊天和消息应用程序中特别有用。&lt;/p>
&lt;p>在传统的&lt;a href="https://www.pubnub.com/guides/http/" target="_blank">HTTP&lt;/a>通信中，客户端向服务器发送新请求并等待响应。这称为短轮询。然而，在实时场景中，短轮询可能效率不高，因为它需要频繁向服务器请求，导致不必要的网络开销和增加延迟。&lt;/p></description></item><item><title>[译]如何通过 WebSocket 将 Kafka 消息流式传输到面向互联网的客户端</title><link>https://blog.chensoul.cc/posts/2024/05/07/websockets-kafka/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websockets-kafka/</guid><description>&lt;p>原文链接：&lt;a href="https://ably.com/topic/websockets-kafka" target="_blank">https://ably.com/topic/websockets-kafka&lt;/a>&lt;/p>
&lt;p>Apache Kafka 是目前最强大的异步消息传递技术之一。 Kafka 由 Jay Kreps、Jun Rao 和 Neha Narkhede 等团队于 2010 年在 LinkedIn 设计，并于 2011 年初开源。如今，该工具被众多公司（包括科技巨头，例如 Slack、Airbnb 或 Netflix 使用）为其实时数据流管道提供支持。&lt;/p></description></item><item><title>ThingsBoard的领域模型</title><link>https://blog.chensoul.cc/posts/2024/05/07/thingsboard-domain/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/thingsboard-domain/</guid><description>&lt;p>ThingsBoard是一个开源的物联网平台，用于管理和监控物联网设备和数据。它提供了一个可扩展的架构，可以连接各种设备，并实时收集、处理和分析设备生成的数据。&lt;/p>
&lt;h2 id="领域模型">领域模型&lt;/h2>
&lt;p>在ThingsBoard中，领域模型是一个关键概念，用于描述物联网系统中的物理实体、属性和行为。以下是ThingsBoard中的主要领域模型组件：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>租户（Tenant）：租户是ThingsBoard中的顶级组织单位。它代表了一个独立的实体，可以是一个用户、组织或公司。租户拥有和管理自己的设备、客户、规则和仪表板等资源。租户之间的数据和配置是相互隔离的，每个租户都有自己的独立环境。租户由系统管理员创建和管理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>租户配置（TenantProfile）：用于定义租户级别的配置和属性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>客户（Customer）：客户是租户下的子级实体，代表了物联网系统中的用户或组织。一个租户可以包含多个客户，每个客户都有自己的访问权限和角色。客户可以访问和监控租户下的设备和数据。客户可以有自己的设备、规则和仪表板等资源，但这些资源受到租户级别的限制。客户由租户管理员创建和管理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用户（User）：保存用户的基本信息&lt;/p>
&lt;ol>
&lt;li>用户的角色（Authority）：SYS_ADMIN、TENANT_ADMIN、CUSTOMER_USER、REFRESH_TOKEN、PRE_VERIFICATION_TOKEN&lt;/li>
&lt;li>用户凭证（UserCredentials）：保存用户的密码、激活用户 Token、重置密码 Token、密码使用历史&lt;/li>
&lt;li>用户认证设置（UserAuthSettings）：保存用户 2FA 认证设置&lt;/li>
&lt;li>用户设置（UserSettings）：保存用户的设置，包括：通用设置、通知、访问过的仪表盘等等&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>系统设置（AdminSettings）：是用于配置和管理整个系统的全局设置和参数，包括：通用设置、邮件、JWT、连接设置等等。&lt;/p></description></item><item><title>All things about ThingsBoard</title><link>https://blog.chensoul.cc/posts/2024/04/29/all-things-about-thingsboard/</link><pubDate>Mon, 29 Apr 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/04/29/all-things-about-thingsboard/</guid><description>&lt;p>thingsboard 是一款乌克兰团队基于java语言研发的开源物联网框架，开源的是ce版，企业版需要购买授权且无源码。&lt;/p>
&lt;p>官方网站：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Thingsboard 官网：&lt;a href="https://thingsboard.io/" target="_blank">https://thingsboard.io/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Thingsboard社区免费版本：&lt;a href="https://demo.thingsboard.io/" target="_blank">https://demo.thingsboard.io/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Thingsboard 企业付费版本：&lt;a href="https://thingsboard.cloud/" target="_blank">https://thingsboard.cloud/&lt;/a>&lt;/p></description></item><item><title>TBMQ测试和源码分析</title><link>https://blog.chensoul.cc/posts/2024/04/28/thingsboard-tbmq-test/</link><pubDate>Sun, 28 Apr 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/04/28/thingsboard-tbmq-test/</guid><description>&lt;ol>
&lt;li>
&lt;p>启动 TBMQ 程序，浏览器访问 http://localhost:8083，创建一个 Application，Credentials Type 为 BASIC，客户端 ID、用户名和密码均设置为 tbmq_app&lt;/p></description></item><item><title>ThingsBoard TBMQ本地和通过Docker运行</title><link>https://blog.chensoul.cc/posts/2024/04/17/thingsboard-tbmq-local-docker-run/</link><pubDate>Wed, 17 Apr 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/04/17/thingsboard-tbmq-local-docker-run/</guid><description>&lt;h2 id="docker-compose-运行">docker-compose 运行&lt;/h2>
&lt;p>参考：&lt;a href="https://thingsboard.io/docs/mqtt-broker/install/cluster/docker-compose-setup/" target="_blank">https://thingsboard.io/docs/mqtt-broker/install/cluster/docker-compose-setup/&lt;/a>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>下载源代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git clone -b release-1.3.0 https://github.com/thingsboard/tbmq.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd tbmq/docker
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>创建逻辑卷并执行安装程序&lt;/p></description></item><item><title>All things about MicroProfile</title><link>https://blog.chensoul.cc/posts/2023/12/14/all-things-about-microprofile/</link><pubDate>Thu, 14 Dec 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/12/14/all-things-about-microprofile/</guid><description>&lt;p>最近在一些开源项目中看到了 MicroProfile ，于是在网上查阅了相关资料加深对 MicroProfile 的理解，并做了笔记形成此文。&lt;/p>
&lt;h2 id="microprofile">MicroProfile&lt;/h2>
&lt;p>MicroProfile是一个开放的企业级Java微服务框架，旨在简化和标准化基于微服务架构的应用程序开发。它是由Eclipse Foundation主导的一个开源项目，致力于提供轻量级、可移植和可互操作的Java微服务规范和实现。&lt;/p></description></item><item><title>JHipster安装和介绍</title><link>https://blog.chensoul.cc/posts/2023/11/02/jhipster-intro/</link><pubDate>Thu, 02 Nov 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/11/02/jhipster-intro/</guid><description>&lt;p>JHipster 是一个开发平台，可以快速生成，开发和部署现代 Web 应用程序+微服务架构。&lt;/p>
&lt;p>JHipster 或者称 Java Hipster，是一个应用代码产生器，能够创建 Spring Boot/Spring Cloud + React/VueJs/AngularJS 的应用。使用 JHipster，首先你要配置好 Java 、Git 以及 Maven 或者 Gradle 的环境，然后通过 NodeJs 管理工具安装 JHipster 。&lt;/p></description></item><item><title>JSR 166规范</title><link>https://blog.chensoul.cc/posts/2023/05/18/jsr-166/</link><pubDate>Thu, 18 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/18/jsr-166/</guid><description>&lt;h2 id="jsr-介绍">JSR 介绍&lt;/h2>
&lt;p>JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 &lt;a href="http://jcp.org/en/jsr/detail?id=335" target="_blank">JSR 335&lt;/a>，新的日期和时间 API 对应的是 &lt;a href="http://jcp.org/en/jsr/detail?id=310" target="_blank">JSR 310&lt;/a>。&lt;/p></description></item></channel></rss>