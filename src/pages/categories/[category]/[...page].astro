---
import { getCollection } from "astro:content";
import type { GetStaticPathsOptions } from "astro";
import Layout from "@/layouts/Layout.astro";
import Card from "@/components/Card.astro";
import { PostUtils } from "@/utils/postUtils";
import { SITE } from "@/config";

/**
 * 生成分类页的静态路径
 *
 * 处理流程：
 * 1. 获取所有博客文章（包括草稿，由 getSortedPosts 过滤）
 * 2. 使用 getUniqueCategories 提取所有唯一的分类
 *    - 返回分类的 URL 友好名称（slug）
 *    - 返回分类的显示名称（中文）
 * 3. 对每个分类：
 *    a. 筛选属于该分类的文章（文章的 categories 数组包含分类名称）
 *    b. 使用 getSortedPosts 进行排序和过滤
 *    c. 使用 paginate 生成分页路由
 *    d. 将分类显示名称作为 props 传递给组件
 *
 * 为什么使用 flatMap：
 * - paginate 为每个分类返回一个路由数组
 * - flatMap 将所有分类的路由数组展平为一维数组
 * - 最终返回符合 Astro 要求的静态路径格式
 *
 * @param paginate - Astro 提供的分页函数
 * @returns 静态路径数组，每个路径包含 params、props 和分页数据
 */
export async function getStaticPaths({ paginate }: GetStaticPathsOptions) {
  // 获取所有博客文章（不过滤，由后续的 getSortedPosts 处理）
  const posts = await getCollection("blog");

  /**
   * 提取所有唯一的分类
   *
   * 返回结构：
   * - category: 分类的 URL 友好名称（如 "tech", "life"）
   * - categoryName: 分类的显示名称（如 "技术", "生活"）
   */
  const categories = PostUtils.getUniqueCategories(posts);

  /**
   * 为每个分类生成路由
   *
   * flatMap 的作用：
   * - 对每个分类调用 paginate，返回一个路由数组
   * - 将多个分类的路由数组展平为一个总数组
   *
   * 返回格式示例：
   * [
   *   { params: { category: "tech" }, props: { categoryName: "技术" }, ...paginateData },
   *   { params: { category: "life" }, props: { categoryName: "生活" }, ...paginateData },
   *   ...
   * ]
   */
  return categories.flatMap(({ category, categoryName }) => {
    /**
     * 筛选并排序属于该分类的文章
     *
     * 筛选条件：
     * - 文章的 categories 数组包含当前分类的显示名称（categoryName）
     * - 注意：文章中存储的是分类的显示名称，而非 slug
     *
     * 排序规则：
     * - getSortedPosts 会过滤草稿和未到发布时间的文章
     * - 按更新时间（或发布时间）降序排序
     */
    const categoryPosts = PostUtils.sort(
      posts.filter(post => post.data.categories.includes(categoryName))
    );

    /**
     * 为该分类生成分页路由
     *
     * 参数说明：
     * - categoryPosts: 该分类的所有文章
     * - params.category: URL 参数（分类的 slug）
     * - props.categoryName: 传递给组件的分类显示名称
     * - pageSize: 每页的文章数量
     *   - 设置为全部文章数量，实际分页由懒加载处理
     *   - 这样可以确保只生成一个路由，减少构建时间
     */
    return paginate(categoryPosts, {
      params: { category },
      props: { categoryName },
      pageSize: categoryPosts.length,
    });
  });
}

// 从 Astro.props 中解构获取分页数据和分类显示名称
const { page, categoryName } = Astro.props;
---

<Layout title={`${categoryName} | ${SITE.title}`}>
  <p class="mb-4 text-base font-semibold">
    分类：{categoryName}
  </p>
  <ul class="category-posts-list">
    {
      /**
       * 渲染分类文章列表
       *
       * 懒加载逻辑：
       * - 索引小于 SITE.postPerIndex 的文章直接显示
       * - 索引大于等于该值的文章设置 hidden={true}，由懒加载脚本控制显示
       */
      page.data.map((data, i) => (
        <Card
          {...data}
          itemClass="category-post-item"
          hidden={i >= SITE.postPerIndex}
          dateFormat="absolute"
        />
      ))
    }
  </ul>
  {/* 懒加载哨兵元素：用于 IntersectionObserver 检测滚动位置 */}
  <div
    id="category-posts-sentinel"
    data-init={SITE.postPerIndex}
    data-chunk={SITE.postPerPage}
  >
  </div>
</Layout>

<script is:inline src={SITE.lazyListJsUrl || "/lazy-list.js"}></script>
<script is:inline>
  function boot() {
    if (typeof window.setupLazyList !== "function") return;
    window.setupLazyList({
      sentinelId: "category-posts-sentinel",
      itemSelector: ".category-post-item",
    });
  }
  document.addEventListener("DOMContentLoaded", boot);
  window.addEventListener("load", boot);
</script>
