---
title: "Spring AI 提示词模板"
date: 2026-01-01
slug: spring-ai-prompt-template
categories: ["ai"]
tags: ['spring-ai']
---

本文介绍如何在 Spring AI 中使用**提示词模板**：将提示词外部化、参数化，便于维护和复用。

<!--more-->

> **示例代码库**
>
> 您可以在 [GitHub 仓库](https://github.com/chensoul/spring-ai-samples/tree/main/04-prompt-templates) 中找到本文的示例代码。

## 为什么使用提示词模板

- **外部化**：长提示词放在文件或配置中，避免硬编码在 Java 里。
- **参数化**：用占位符（如 `{topic}`、`{count}`、`{tone}`）在运行时填入变量，同一模板可复用于不同请求。
- **角色与风格**：通过系统消息（SystemMessage）固定助手角色与风格，用户消息（UserMessage）只传具体内容。

本示例使用 **DeepSeek** 模型（OpenAI 兼容接口），配置见 `application.properties`。以下 API 均返回 `{"content":"..."}`。

## 1. 系统消息 + 用户消息（无模板）

`/api/chat` 演示「系统消息 + 用户消息」的组成方式：系统消息写死在代码中，用户消息来自请求体。

```java
@PostMapping("/api/chat")
Output chat(@RequestBody @Valid Input input) {
    String systemPrompt = "You are a friendly, helpful assistant. You always respond professionally.";
    SystemMessage systemMessage = new SystemMessage(systemPrompt);
    UserMessage userMessage = new UserMessage(input.prompt());
    Prompt prompt = new Prompt(List.of(systemMessage, userMessage));
    String response = chatClient.prompt(prompt).call().content();
    return new Output(response);
}
```

调用示例：

```bash
curl -s -X POST http://localhost:8080/api/chat \
  -H "Content-Type: application/json" \
  -d '{"prompt":"What is Spring Boot?"}'
```

适合：简单对话、系统角色固定且无需参数化。

## 2. 内联模板：PromptTemplate + 占位符

`/api/suggest-titles` 使用 **PromptTemplate** 在代码中写模板字符串，占位符为 `{topic}` 和 `{count}`，运行时通过 Map 传入变量；`createMessage(vars)` 得到一条消息后交给 ChatClient。

```java
@PostMapping("/api/suggest-titles")
Output suggestTitles(@RequestBody @Valid TitleSuggestionsRequest req) {
    PromptTemplate pt = new PromptTemplate("""
    I would like to give a presentation about the following:

    {topic}

    Give me {count} title suggestions for this topic.

    Make sure the title is relevant to the topic and it should be a single short sentence.
    """);

    Map<String, Object> vars = Map.of("topic", req.topic(), "count", req.count());
    Message message = pt.createMessage(vars);
    String response = chatClient.prompt().messages(message).call().content();

    return new Output(response);
}
```

请求体示例：

```json
{
  "topic": "Spring Boot Tips and Tricks",
  "count": 5
}
```

要点：

- `PromptTemplate` 的字符串中使用 `{name}` 形式的占位符。
- `createMessage(Map.of(...))` 将占位符替换后生成一条 **Message**（默认相当于用户消息），再通过 `chatClient.prompt().messages(message).call().content()` 调用模型。

适合：模板较短、与业务强相关、不需要单独文件时。

## 3. 文件模板：外部文件 + 占位符

`/api/gen-tweet` 将系统提示词放在 **classpath 资源** `prompts/tweet-system-message.st` 中，模板内容里包含占位符 `{tone}`，运行时从请求体传入并渲染。

**模板文件** `src/main/resources/prompts/tweet-system-message.st`：

```text
You are an expert software developer and experienced content creator.
Your job is to generate interesting tweet based on the given input.

* Use a catchy first line to convey the essence of the input.
* Keep it concise and engaging.
* Maintain a {tone} tone.
* Use bullet points to list key features or benefits
* Use emojis where appropriate.
* Include relevant hashtags at the end.

Don't use Markdown syntax. Use plain text format.
```

**Java 中加载并渲染**：

```java
@Value("classpath:/prompts/tweet-system-message.st")
Resource tweetSystemMsgResource;

@PostMapping("/api/gen-tweet")
Output generateTweet(@RequestBody @Valid GenTweetRequest request) throws IOException {
    String templateContent = tweetSystemMsgResource.getContentAsString(UTF_8);
    String tone = request.tone() != null ? request.tone() : "professional";
    String systemPrompt = new PromptTemplate(templateContent)
            .createMessage(Map.of("tone", tone))
            .getText();
    SystemMessage systemMessage = new SystemMessage(systemPrompt);
    UserMessage userMessage = new UserMessage(request.prompt());

    Prompt prompt = new Prompt(List.of(systemMessage, userMessage));
    String response = chatClient.prompt(prompt).call().content();

    return new Output(response);
}

record GenTweetRequest(@NotBlank String prompt, String tone) {}
```

流程简述：

1. 用 `@Value("classpath:/prompts/...")` 注入 `Resource`，`getContentAsString(UTF_8)` 得到模板字符串。
2. `new PromptTemplate(templateContent).createMessage(Map.of("tone", tone))` 得到填充后的 **Message**，`.getContent()` 取出文本。
3. 将该文本作为 **SystemMessage**，用户输入作为 **UserMessage**，组成 `Prompt` 后调用 `chatClient.prompt(prompt).call().content()`。

请求体示例（`tone` 可选，默认 `"professional"`）：

```bash
curl -s -X POST http://localhost:8080/api/gen-tweet \
  -H "Content-Type: application/json" \
  -d '{"prompt":"IntelliJ IDEA 2025.2 is released with Java 25 EA, Maven 4, Spring Debugger plugin.", "tone": "casual"}'
```

适合：长提示词、多语言/多风格、希望与代码分离时。

## 三种方式对比

| 方式           | 示例接口           | 模板位置     | 占位符     | 典型场景               |
|----------------|--------------------|--------------|------------|------------------------|
| 系统+用户消息  | `/api/chat`        | 代码内       | 无         | 简单对话、固定角色     |
| 内联模板       | `/api/suggest-titles` | 代码内字符串 | `{topic}`, `{count}` | 短模板、参数少、逻辑集中 |
| 文件模板       | `/api/gen-tweet`   | classpath 文件 | `{tone}`   | 长提示、多风格、易维护 |

## 配置与运行

本示例使用 **DeepSeek**（OpenAI 兼容 API）。请先在 [DeepSeek 开放平台](https://platform.deepseek.com/) 获取 API Key，并设置环境变量：

```bash
export DEEPSEEK_API_KEY=<your-deepseek-api-key>
```

`application.properties` 示例：

```properties
spring.application.name=04-prompt-templates

spring.ai.openai.base-url=https://api.deepseek.com
spring.ai.openai.api-key=${DEEPSEEK_API_KEY}
spring.ai.openai.chat.options.model=deepseek-reasoner

logging.level.org.springframework.ai.chat.client.advisor=DEBUG
```

启动应用后，按上文 curl 示例依次测试 `/api/chat`、`/api/suggest-titles`、`/api/gen-tweet` 即可验证三种提示词用法。

```bash
# 1. 系统消息 + 用户消息
curl -s -X POST http://localhost:8080/api/chat \
  -H "Content-Type: application/json" \
  -d '{"prompt":"What is Spring Boot?"}'

# 2. 内联模板（标题建议）
curl -s -X POST http://localhost:8080/api/suggest-titles \
  -H "Content-Type: application/json" \
  -d '{"topic":"Spring Boot Tips and Tricks","count":5}'

# 3. 文件模板（生成推文）
curl -s -X POST http://localhost:8080/api/gen-tweet \
  -H "Content-Type: application/json" \
  -d '{"prompt":"IntelliJ IDEA 2025.2 发布，支持 Java 25 EA、Maven 4。","tone":"professional"}'
```

## 总结

- **系统消息 + 用户消息**：用 `SystemMessage` 与 `UserMessage` 组成 `Prompt`，无需模板。
- **内联模板**：`new PromptTemplate("... {var} ...").createMessage(Map.of("var", value))`，得到 `Message` 后交给 `ChatClient`。
- **文件模板**：classpath 资源读成字符串 → `new PromptTemplate(content).createMessage(vars).getContent()` 得到渲染后的系统提示 → 再包成 `SystemMessage` 与用户消息一起调用。

按需选择「无模板 / 内联 / 文件」即可在 Spring AI 中用好提示词模板。

