<!DOCTYPE html>
<html class="no-js" lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ThingsBoard HTTP Transport 实现方式 - Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="ThingsBoard HTTP Transport 实现方式">
	<meta property="og:description" content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps">
	<meta property="og:type" content="article">
	<meta property="og:url" content="https://blog.chensoul.cc/posts/2025/07/02/thingsboard-http-transport/">
	<meta property="og:site_name" content="ChenSoul Blog">
	<meta property="og:image" content="/images/favicon.webp">
	
  <meta itemprop="name" content="ThingsBoard HTTP Transport 实现方式">
  <meta itemprop="description" content="本篇文档系统梳理 ThingsBoard 平台 HTTP 设备接入的整体实现方式，重点详解 HTTP 自动注册（provision）机制的完整调用链、核心模块及消息流转机制，并补充核心注册逻辑代码说明，帮助理解其分层解耦与分布式架构设计。">
  <meta itemprop="datePublished" content="2025-07-02T00:00:00+00:00">
  <meta itemprop="dateModified" content="2025-07-02T00:00:00+00:00">
  <meta itemprop="wordCount" content="1036">
  <meta itemprop="keywords" content="Javascript,Spring-Boot,Kafka,Rabbitmq">
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:title" content="ThingsBoard HTTP Transport 实现方式">
	<meta name="twitter:description" content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps">
	<meta name="twitter:image" content="/images/favicon.webp">

	<link rel="preconnect" href="//fonts.loli.net" crossorigin>
	<link rel="dns-prefetch" href="//fonts.loli.net">
	<link rel="stylesheet" href="https://fonts.loli.net/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css" integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
	<link rel="stylesheet" href="/css/style.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="ChenSoul Blog" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="/logo.svg" loading="lazy" alt="Site logo" width="60" height="60">
				</div><div class="logo__item logo__text">
					<div class="logo__title">ChenSoul Blog</div>
					<div class="logo__tagline">Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">菜单</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/">
				
				<span class="menu__text">首页</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/categories/">
				
				<span class="menu__text">分类</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/tags/">
				
				<span class="menu__text">标签</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/index.xml">
				
				<span class="menu__text">订阅</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">关于</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ThingsBoard HTTP Transport 实现方式</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 1 1 0 28 1 1 0 0 1 0-28m0 3a3 3 0 1 0 0 22 3 3 0 0 0 0-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class="meta__text" datetime="2025-07-02">2025-07-02</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class="meta__text"><a class="meta__link" href="/categories/java/" rel="category">Java</a>
	</span>
</div><div class="meta__item-tags meta__item"><svg class="meta__icon icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg><span class="meta__text"><a class="meta__link" href="/tags/javascript/" rel="tag">Javascript</a>, <a class="meta__link" href="/tags/spring-boot/" rel="tag">Spring-Boot</a>, <a class="meta__link" href="/tags/kafka/" rel="tag">Kafka</a>, <a class="meta__link" href="/tags/rabbitmq/" rel="tag">Rabbitmq</a>
	</span>
</div>
</div>
		</header>
		
		<div class="content post__content clearfix">
			<p>本篇文档系统梳理 ThingsBoard 平台 HTTP 设备接入的整体实现方式，重点详解 HTTP
自动注册（provision）机制的完整调用链、核心模块及消息流转机制，并补充核心注册逻辑代码说明，帮助理解其分层解耦与分布式架构设计。</p>
<h2 id="一测试-http-transport">一、测试 HTTP Transport</h2>
<p>1、本地启动 thingsboard 服务，然后打开 <a href="http://localhost:8080/" target="_blank">http://localhost:8080/</a> 并使用系统管理员： <a href="mailto:sysadmin@thingsboard.org">sysadmin@thingsboard.org</a> / sysadmin 进行登陆</p>
<p>2、在 <a href="http://localhost:8080/tenants" target="_blank">http://localhost:8080/tenants</a> 页面创建测试租户 test，并添加租户管理员：tenant@thingsboard.org / tenant</p>
<p>3、以租户管理员身份登陆，在 <a href="http://localhost:8080/entities/devices" target="_blank">http://localhost:8080/entities/devices</a> 页面创建测试设备 test</p>
<p>4、使用下面命令检查连通性（我使用的是 macos 系统）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl -v -X POST http://localhost:8080/api/v1/p4qGvJp3443cotHE0JfY/telemetry <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>	--header Content-Type:application/json --data <span style="color:#e6db74">&#34;{temperature:25}&#34;</span>
</span></span></code></pre></div><p>输出日志如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Note: Unnecessary use of -X or --request, POST is already inferred.
</span></span><span style="display:flex;"><span>* Uses proxy env variable http_proxy <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;http://127.0.0.1:7890&#39;</span>
</span></span><span style="display:flex;"><span>*   Trying 127.0.0.1:7890...
</span></span><span style="display:flex;"><span>* Connected to 127.0.0.1 <span style="color:#f92672">(</span>127.0.0.1<span style="color:#f92672">)</span> port <span style="color:#ae81ff">7890</span>
</span></span><span style="display:flex;"><span>&gt; POST http://localhost:8080/api/v1/p4qGvJp3443cotHE0JfY/telemetry HTTP/1.1
</span></span><span style="display:flex;"><span>&gt; Host: localhost:8080
</span></span><span style="display:flex;"><span>&gt; User-Agent: curl/8.7.1
</span></span><span style="display:flex;"><span>&gt; Accept: */*
</span></span><span style="display:flex;"><span>&gt; Proxy-Connection: Keep-Alive
</span></span><span style="display:flex;"><span>&gt; Content-Type:application/json
</span></span><span style="display:flex;"><span>&gt; Content-Length: <span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>&gt; 
</span></span><span style="display:flex;"><span>* upload completely sent off: <span style="color:#ae81ff">16</span> bytes
</span></span><span style="display:flex;"><span>&lt; HTTP/1.1 <span style="color:#ae81ff">200</span> 
</span></span><span style="display:flex;"><span>&lt; Content-Length: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>&lt; Cache-Control: no-cache, no-store, max-age<span style="color:#f92672">=</span>0, must-revalidate
</span></span><span style="display:flex;"><span>&lt; Connection: keep-alive
</span></span><span style="display:flex;"><span>&lt; Date: Wed, <span style="color:#ae81ff">02</span> Jul <span style="color:#ae81ff">2025</span> 02:09:04 GMT
</span></span><span style="display:flex;"><span>&lt; Expires: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>&lt; Keep-Alive: timeout<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>&lt; Pragma: no-cache
</span></span><span style="display:flex;"><span>&lt; Proxy-Connection: keep-alive
</span></span><span style="display:flex;"><span>&lt; Vary: Origin
</span></span><span style="display:flex;"><span>&lt; Vary: Access-Control-Request-Method
</span></span><span style="display:flex;"><span>&lt; Vary: Access-Control-Request-Headers
</span></span><span style="display:flex;"><span>&lt; X-Content-Type-Options: nosniff
</span></span><span style="display:flex;"><span>&lt; X-Frame-Options: DENY
</span></span><span style="display:flex;"><span>&lt; X-Xss-Protection: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>&lt; 
</span></span><span style="display:flex;"><span>* Connection <span style="color:#75715e">#0 to host 127.0.0.1 left intact</span>
</span></span></code></pre></div><p>说明调用成功</p>
<p>5、新设备自注册</p>
<p>现在 <a href="http://localhost:8080/profiles/deviceProfiles" target="_blank">http://localhost:8080/profiles/deviceProfiles</a> 编辑 设备预配置，设置 预配置策略 为允许创建新设备，保存后可以看到 provisionDeviceKey 和 provisionDeviceSecret。</p>
<p>然后，运行下面命令注册一个新设备，名称为 test-device-001</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl -X POST http://localhost:8080/api/v1/provision <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -H <span style="color:#e6db74">&#34;Content-Type: application/json&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -d <span style="color:#e6db74">&#39;{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;deviceName&#34;: &#34;test-device-001&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;provisionDeviceKey&#34;: &#34;a22x2lalyyvc65v3vtib&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;provisionDeviceSecret&#34;: &#34;8km4t2qotcg3thmqyvb8&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  }&#39;</span>
</span></span></code></pre></div><p>返回结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">{</span><span style="color:#e6db74">&#34;credentialsValue&#34;</span>:<span style="color:#e6db74">&#34;K7KW5LFwRD4IBTUJ734L&#34;</span>,<span style="color:#e6db74">&#34;credentialsType&#34;</span>:<span style="color:#e6db74">&#34;ACCESS_TOKEN&#34;</span>,<span style="color:#e6db74">&#34;status&#34;</span>:<span style="color:#e6db74">&#34;SUCCESS&#34;</span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>表明注册成功。在 <a href="http://localhost:8080/entities/devices" target="_blank">http://localhost:8080/entities/devices</a> 可以看到新注册的设备。</p>
<p>6、设备声明</p>
<p>a、设备声明（设备端/现场激活）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl -X POST http://localhost:8080/api/v1/K7KW5LFwRD4IBTUJ734L/claim <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span> -H <span style="color:#e6db74">&#34;Content-Type: application/json&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span> -d <span style="color:#e6db74">&#39;{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  &#34;secretKey&#34;: &#34;mySecret&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  &#34;durationMs&#34;: 60000
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> }&#39;</span>
</span></span></code></pre></div><ul>
<li>
<p>设备用自己的 token（如 K7KW5LFwRD4IBTUJ734L）主动向平台发起声明请求。</p>
</li>
<li>
<p>适用于设备现场激活、自动归属等场景。</p>
</li>
</ul>
<p>b、创建客户用户并用其认领设备（平台/客户侧）</p>
<p>获取客户用户 Token</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>TOKEN<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>curl -s -X POST --header <span style="color:#e6db74">&#39;Content-Type: application/json&#39;</span> --header <span style="color:#e6db74">&#39;Accept: application/json&#39;</span> -d <span style="color:#e6db74">&#39;{&#34;username&#34;:&#34;customer@thingsboard.org&#34;, &#34;password&#34;:&#34;customer&#34;}&#39;</span> <span style="color:#e6db74">&#39;http://localhost:8080/api/auth/login&#39;</span>|jq -r .token<span style="color:#e6db74">`</span>
</span></span></code></pre></div><ul>
<li>先用客户用户账号登录，获取 JWT Token。</li>
</ul>
<p>客户用户认领设备</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl -X POST <span style="color:#e6db74">&#34;http://localhost:8080/api/customer/device/test-device-001/claim&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span> -H <span style="color:#e6db74">&#34;Content-Type: application/json&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span> -H <span style="color:#e6db74">&#34;X-Authorization: Bearer </span>$TOKEN<span style="color:#e6db74">&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span> -d <span style="color:#e6db74">&#39;{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  &#34;secretKey&#34;: &#34;mySecret&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> }&#39;</span>
</span></span></code></pre></div><ul>
<li>
<p>用客户用户的 Token，通过平台管理接口认领设备。</p>
</li>
<li>
<p>适用于客户/租户在后台批量认领设备的场景。</p>
</li>
</ul>
<p>c、回收设备（取消认领）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl -X DELETE http://localhost:8080/api/customer/device/test-device-001/claim <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span> -H <span style="color:#e6db74">&#34;Content-Type: application/json&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span> -H <span style="color:#e6db74">&#34;X-Authorization: Bearer </span>$TOKEN<span style="color:#e6db74">&#34;</span> 
</span></span></code></pre></div><ul>
<li>客户用户可通过此接口回收（取消认领）设备，设备将不再归属于该客户。</li>
</ul>
<hr>
<h2 id="二http-transport-实现方式">二、HTTP Transport 实现方式</h2>
<h3 id="1-架构与入口">1. 架构与入口</h3>
<ul>
<li><strong>HTTP Transport</strong> 是 ThingsBoard 支持的多种设备接入协议之一，主要用于设备通过 HTTP 协议与平台交互。</li>
<li>相关代码主要分布在 <code>common/transport/http/</code> 和 <code>transport/http/</code> 目录。</li>
<li>典型部署方式为独立微服务进程，通常通过 Spring Boot 启动。</li>
</ul>
<h3 id="2-核心模块与类">2. 核心模块与类</h3>
<ul>
<li><strong>DeviceApiController</strong>：HTTP 设备接入的主要控制器，负责处理设备侧的 HTTP 请求，典型路径为 <code>/api/v1</code>。</li>
<li><strong>会话管理与设备状态</strong>：HTTP 设备的“在线/离线”状态通过会话和超时机制（如 inactivity timeout）间接判断。</li>
</ul>
<h3 id="3-典型接口说明">3. 典型接口说明</h3>
<ol>
<li>设备自动注册（Provision）</li>
</ol>
<ul>
<li>
<p><strong>接口</strong>：<code>POST /api/v1/provision</code></p>
</li>
<li>
<p><strong>作用</strong>：设备通过预配置的 key/secret 自动注册到平台，获取访问凭证。</p>
</li>
<li>
<p><strong>请求体</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;deviceName&#34;</span>: <span style="color:#e6db74">&#34;test-device-001&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;provisionDeviceKey&#34;</span>: <span style="color:#e6db74">&#34;your_provision_key&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;provisionDeviceSecret&#34;</span>: <span style="color:#e6db74">&#34;your_provision_secret&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<hr>
<ol start="2">
<li>设备声明（Claim）</li>
</ol>
<ul>
<li>
<p><strong>接口</strong>：<code>POST /api/v1/{deviceToken}/claim</code></p>
</li>
<li>
<p><strong>作用</strong>：将设备归属到最终用户或客户名下，实现动态绑定。</p>
</li>
<li>
<p><strong>请求体</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;secretKey&#34;</span>: <span style="color:#e6db74">&#34;your_secret_key&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;durationMs&#34;</span>: <span style="color:#ae81ff">60000</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>设备声明，参考 <a href="https://thingsboard.io/docs/user-guide/claiming-devices/" target="_blank">https://thingsboard.io/docs/user-guide/claiming-devices/</a></p>
<p><strong>1、主要作用与场景</strong></p>
<ul>
<li>动态归属</li>
</ul>
<p>设备在工厂或渠道出厂时，只需预注册到平台，不绑定具体用户。最终用户拿到设备后，通过“声明”接口，将设备归属到自己的账号或客户名下。</p>
<ul>
<li>批量部署与灵活分配</li>
</ul>
<p>厂商可批量生产和注册设备，分发到各地或不同客户，客户收到设备后自主激活，无需平台管理员手动分配。</p>
<ul>
<li>安全激活</li>
</ul>
<p>通过 secretKey（声明密钥）和有效期等机制，确保只有合法用户才能声明设备，防止被恶意抢占。</p>
<ul>
<li>支持租户/多客户场景</li>
</ul>
<p>支持多租户、多客户环境下的设备灵活分配和管理。</p>
<p><strong>典型流程</strong></p>
<ul>
<li>
<p>设备出厂时仅注册到平台，未归属任何客户。</p>
</li>
<li>
<p>设备到达最终用户手中，用户通过 App/前端/接口输入声明密钥（secretKey）等信息，调用 /api/v1/{deviceToken}/claim。</p>
</li>
<li>
<p>平台校验密钥和有效期，声明成功后，将设备归属到当前用户或客户名下。</p>
</li>
<li>
<p>后续该用户/客户可管理、监控该设备。</p>
</li>
</ul></blockquote>
</li>
</ul>
<hr>
<ol start="3">
<li>属性上报</li>
</ol>
<ul>
<li>
<p><strong>接口</strong>：<code>POST /api/v1/{deviceToken}/attributes</code></p>
</li>
<li>
<p><strong>作用</strong>：设备上报静态属性（如固件版本、序列号等）。</p>
</li>
<li>
<p><strong>请求体</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;firmwareVersion&#34;</span>: <span style="color:#e6db74">&#34;1.0.0&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;serialNumber&#34;</span>: <span style="color:#e6db74">&#34;SN123456&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<hr>
<ol start="4">
<li>属性获取</li>
</ol>
<ul>
<li><strong>接口</strong>：<code>GET /api/v1/{deviceToken}/attributes</code></li>
<li><strong>作用</strong>：设备获取平台下发的属性。</li>
<li><strong>参数</strong>：可选 <code>clientKeys</code>、<code>sharedKeys</code> 查询指定属性。</li>
</ul>
<hr>
<ol start="5">
<li>遥测数据上报</li>
</ol>
<ul>
<li>
<p><strong>接口</strong>：<code>POST /api/v1/{deviceToken}/telemetry</code></p>
</li>
<li>
<p><strong>作用</strong>：设备上报时序数据（如温度、湿度等）。</p>
</li>
<li>
<p><strong>请求体</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;temperature&#34;</span>: <span style="color:#ae81ff">23.5</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;humidity&#34;</span>: <span style="color:#ae81ff">60</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<hr>
<ol start="6">
<li>设备固件下载</li>
</ol>
<ul>
<li><strong>接口</strong>：<code>GET /api/v1/{deviceToken}/firmware?title=xxx&amp;version=yyy</code></li>
<li><strong>作用</strong>：设备分片或整体下载平台分配的固件包。</li>
<li><strong>参数</strong>：<code>title</code>（固件名）、<code>version</code>（固件版本）、<code>size</code>（分片大小，可选）、<code>chunk</code>（分片序号，可选）</li>
</ul>
<hr>
<ol start="7">
<li>设备软件包下载</li>
</ol>
<ul>
<li><strong>接口</strong>：<code>GET /api/v1/{deviceToken}/software?title=xxx&amp;version=yyy</code></li>
<li><strong>作用</strong>：设备分片或整体下载平台分配的软件包。</li>
<li><strong>参数</strong>：同上</li>
</ul>
<hr>
<ol start="8">
<li>订阅属性/命令（长轮询，已不推荐）</li>
</ol>
<ul>
<li><strong>接口</strong>：
<ul>
<li>订阅属性：<code>GET /api/v1/{deviceToken}/attributes/updates</code></li>
<li>订阅命令：<code>GET /api/v1/{deviceToken}/rpc</code></li>
</ul>
</li>
<li><strong>作用</strong>：设备通过 HTTP 长轮询方式订阅平台下发的属性或命令（建议用 MQTT/CoAP 替代）。</li>
</ul>
<hr>
<ol start="9">
<li>回复命令</li>
</ol>
<ul>
<li>
<p><strong>接口</strong>：<code>POST /api/v1/{deviceToken}/rpc/{requestId}</code></p>
</li>
<li>
<p><strong>作用</strong>：设备回复平台下发的 RPC 命令。</p>
</li>
<li>
<p><strong>请求体</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;status&#34;</span>: <span style="color:#e6db74">&#34;success&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<hr>
<ol start="10">
<li>发送命令到平台</li>
</ol>
<ul>
<li>
<p><strong>接口</strong>：<code>POST /api/v1/{deviceToken}/rpc</code></p>
</li>
<li>
<p><strong>作用</strong>：设备主动向平台发送 RPC 请求。</p>
</li>
<li>
<p><strong>请求体</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;method&#34;</span>: <span style="color:#e6db74">&#34;reboot&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;params&#34;</span>: {}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<hr>
<h3 id="4-请求认证与安全">4. 请求认证与安全</h3>
<ul>
<li>设备通过 <code>deviceToken</code> 进行身份认证，token 由平台分配。</li>
<li>所有接口均需在 URL 中携带 token，平台校验 token 有效性。</li>
</ul>
<h3 id="5-典型流程举例">5. 典型流程举例</h3>
<ol>
<li>设备首次上线，调用 <code>/api/v1/provision</code>，获取 token。</li>
<li>设备定期调用 <code>/api/v1/{deviceToken}/telemetry</code> 上报数据。</li>
<li>设备定期调用任意接口（如上报属性、数据），保持“在线”状态。</li>
<li>长时间未请求，平台自动判定设备下线。</li>
</ol>
<h3 id="6-测试与调试建议">6. 测试与调试建议</h3>
<ul>
<li>可用 Postman/curl 模拟设备请求，测试各接口功能。</li>
<li>通过 ThingsBoard 前端或 API 查询设备状态，验证上线/下线逻辑。</li>
<li>检查 HTTP Transport 服务日志，排查认证、数据处理等问题。</li>
</ul>
<h3 id="7-设计启示">7. 设计启示</h3>
<ul>
<li>HTTP 设备接入适合低频、无长连接需求的场景。</li>
<li>设备状态管理需结合业务场景合理设置超时时间。</li>
<li>认证机制建议采用 token 或签名，确保安全。</li>
</ul>
<hr>
<h2 id="三设备自动注册">三、设备自动注册</h2>
<h3 id="1-整体流程概述">1. 整体流程概述</h3>
<ol>
<li>设备通过 HTTP POST <code>/api/v1/provision</code> 发起注册请求。</li>
<li>HTTP 控制器解析请求并转发到 Transport Service。</li>
<li>Transport Service 将注册请求通过消息队列发送到 Core Service。</li>
<li>Core Service 消费注册消息，分发到注册业务实现。</li>
<li>注册业务处理（校验、查找/创建设备、生成凭证）。</li>
<li>处理结果通过消息队列回传，最终响应给设备。</li>
</ol>
<h3 id="2-详细调用链">2. 详细调用链</h3>
<ul>
<li><strong>设备侧请求</strong>：<code>POST /api/v1/provision</code>，请求体包含 deviceName、provisionDeviceKey、provisionDeviceSecret。</li>
<li><strong>HTTP 控制器入口</strong>：<code>DeviceApiController.provisionDevice(String json)</code>，解析 JSON，调用
<code>transportContext.getTransportService().process(...)</code>。</li>
<li><strong>Transport Service 层</strong>：如 <code>DefaultTransportApiService</code>，将注册请求消息通过消息队列（如 Kafka/RabbitMQ）发送到 Core
Service。</li>
<li><strong>消息队列与 Core Service</strong>：<code>TbQueueResponseTemplate</code>（实现类：<code>DefaultTbQueueResponseTemplate</code>）持续监听注册等消息，收到消息后调用
<code>DefaultTransportApiService.handle()</code>。</li>
<li><strong>消息类型判断与业务分发</strong>：<code>DefaultTransportApiService.handle(Message msg)</code> 判断消息类型，若为注册请求，则调用
<code>deviceProvisionService.provisionDevice(provisionRequest)</code>。</li>
<li><strong>设备注册业务实现</strong>：<code>DeviceProvisionServiceImpl.provisionDevice(ProvisionRequest provisionRequest)</code>，校验
key/secret，查找/创建设备，生成凭证，返回注册结果。</li>
<li><strong>结果回传</strong>：Core Service 处理完成后，将注册结果通过消息队列回传给 Transport Service，最终通过回调响应给设备。</li>
</ul>
<h3 id="3-调用链时序图">3. 调用链时序图</h3>
<pre class="mermaid">
	sequenceDiagram
    participant Device as 设备
    participant HTTP as DeviceApiController
    participant TS as TransportService
    participant MQ as 消息队列
    participant Core as Core Service
    participant Handler as DefaultTransportApiService
    participant DPS as DeviceProvisionServiceImpl
    Device -&gt;&gt; HTTP: POST /api/v1/provision
    HTTP -&gt;&gt; TS: process(provisionRequest)
    TS -&gt;&gt; MQ: 发送注册消息
    MQ -&gt;&gt; Core: Core Service 消费消息
    Core -&gt;&gt; Handler: handle(msg)
    Handler -&gt;&gt; DPS: provisionDevice(provisionRequest)
    DPS --&gt;&gt; Handler: 返回注册结果
    Handler --&gt;&gt; Core: 返回处理结果
    Core --&gt;&gt; MQ: 发送注册结果
    MQ --&gt;&gt; TS: 回传注册结果
    TS --&gt;&gt; HTTP: 回调 DeviceProvisionCallback
    HTTP --&gt;&gt; Device: 返回注册响应
</pre>
<h3 id="4-核心设计要点">4. 核心设计要点</h3>
<ul>
<li><strong>分层解耦</strong>：HTTP 控制器与业务实现完全解耦，便于扩展和维护。</li>
<li><strong>消息驱动</strong>：通过消息队列实现服务间通信，支持分布式和高可用。</li>
<li><strong>异步回调</strong>：结果通过回调异步返回，提升并发能力。</li>
<li><strong>注册策略灵活</strong>：支持多种注册策略（如自动创建设备、仅允许预注册等）。</li>
</ul>
<h3 id="5-相关核心类">5. 相关核心类</h3>
<ul>
<li><code>DeviceApiController</code>：HTTP 控制器，接收注册请求</li>
<li><code>TransportService</code> / <code>DefaultTransportApiService</code>：传输层服务，消息转发</li>
<li><code>TbQueueResponseTemplate</code> / <code>DefaultTbQueueResponseTemplate</code>：消息队列消费模板</li>
<li><code>TbQueueHandler</code> / <code>DefaultTransportApiService</code>：队列消息分发与处理</li>
<li><code>DeviceProvisionService</code> / <code>DeviceProvisionServiceImpl</code>：注册业务实现</li>
</ul>
<h3 id="6-deviceprovisionserviceimpl-逻辑">6. DeviceProvisionServiceImpl 逻辑</h3>
<p><code>DeviceProvisionServiceImpl</code> 是 ThingsBoard 设备自动注册的核心业务实现类，主要负责校验 key/secret、查找/创建设备、生成凭证、推送事件等。</p>
<ol>
<li>主要方法</li>
</ol>
<ul>
<li>
<p><code>provisionDevice(ProvisionRequest provisionRequest)</code></p>
<ul>
<li>校验请求参数（deviceName、key、secret）</li>
<li>查找目标设备配置（DeviceProfile）</li>
<li>根据注册策略分支处理：
<ul>
<li><strong>ALLOW_CREATE_NEW_DEVICES</strong>：允许自动创建设备，若设备已存在则注册失败，否则创建新设备并生成凭证</li>
<li><strong>CHECK_PRE_PROVISIONED_DEVICES</strong>：仅允许已预注册设备，校验通过后返回凭证，否则注册失败</li>
<li><strong>X509_CERTIFICATE_CHAIN</strong>：不支持该策略，直接抛出异常</li>
</ul>
</li>
<li>处理完成后返回注册结果（凭证、状态）</li>
</ul>
</li>
<li>
<p><code>createDevice(ProvisionRequest, DeviceProfile)</code></p>
<ul>
<li>创建新设备，保存注册状态属性，推送设备创建事件和注册成功事件</li>
<li>返回新设备凭证</li>
</ul>
</li>
<li>
<p><code>processProvision(Device, ProvisionRequest)</code></p>
<ul>
<li>校验设备注册状态，未注册则更新状态并推送注册成功事件，已注册则注册失败</li>
<li>返回设备凭证</li>
</ul>
</li>
<li>
<p><code>notify(Device, ProvisionRequest, TbMsgType, boolean)</code></p>
<ul>
<li>推送注册事件到规则引擎，记录审计日志</li>
</ul>
</li>
</ul>
<ol start="2">
<li>关键点说明</li>
</ol>
<ul>
<li>支持多种注册策略，灵活适配不同业务场景</li>
<li>设备注册事件会推送到规则引擎，便于后续扩展</li>
<li>注册过程有详细的审计日志，便于追踪和排查</li>
</ul>
<h2 id="四设备声明">四、设备声明</h2>
<ul>
<li>设备声明（Claim）用于将平台中已存在的设备动态归属到某个客户或最终用户名下，实现“先注册、后归属”的灵活设备管理。</li>
<li>适用于设备出厂后未绑定用户、现场激活、渠道分发等物联网场景。</li>
</ul>
<h3 id="1-典型业务流程">1. 典型业务流程</h3>
<ol>
<li><strong>设备注册/自动注册</strong>
<ul>
<li>设备通过 <code>/api/v1/provision</code> 或平台后台预注册，成为平台已知设备。</li>
</ul>
</li>
<li><strong>设备声明（Claim）</strong>
<ul>
<li>设备端或客户用户通过声明接口，将设备归属到指定客户名下。</li>
</ul>
</li>
<li><strong>设备回收（Unclaim）</strong>
<ul>
<li>客户用户可主动回收设备，设备归属权解除。</li>
</ul>
</li>
</ol>
<h3 id="2-接口与调用链">2. 接口与调用链</h3>
<h4 id="1-设备端声明现场激活">1. 设备端声明（现场激活）</h4>
<ul>
<li><strong>接口</strong>：<code>POST /api/v1/{deviceToken}/claim</code></li>
<li><strong>调用链</strong>：
<ol>
<li>设备用自身 token 调用接口，提交 secretKey/durationMs</li>
<li>HTTP 控制器（DeviceApiController）校验 token、参数</li>
<li>调用后端 Claim 业务逻辑，校验密钥、有效期</li>
<li>设备归属权转移到当前客户/用户</li>
<li>返回声明结果</li>
</ol>
</li>
</ul>
<h4 id="2-客户用户认领设备平台客户侧">2. 客户用户认领设备（平台/客户侧）</h4>
<ul>
<li><strong>接口</strong>：<code>POST /api/customer/device/{deviceName}/claim</code></li>
<li><strong>调用链</strong>：
<ol>
<li>客户用户登录获取 JWT Token</li>
<li>用 Token 调用接口，提交 secretKey</li>
<li>HTTP 控制器（DeviceController）校验权限、参数</li>
<li>调用后端 Claim 业务逻辑，校验密钥、归属权转移</li>
<li>返回声明结果</li>
</ol>
</li>
</ul>
<h4 id="3-设备回收unclaim">3. 设备回收（Unclaim）</h4>
<ul>
<li><strong>接口</strong>：<code>DELETE /api/customer/device/{deviceName}/claim</code></li>
<li><strong>调用链</strong>：
<ol>
<li>客户用户用 Token 调用接口</li>
<li>HTTP 控制器校验权限、参数</li>
<li>后端业务解除设备归属</li>
<li>返回回收结果</li>
</ol>
</li>
</ul>
<h3 id="3-时序图平台侧认领">3. 时序图（平台侧认领）</h3>
<p>a、设备端声明（现场激活）</p>
<pre class="mermaid">
	sequenceDiagram
    participant Device as 设备
    participant HTTP as DeviceApiController
    participant TS as TransportService
    participant MQ as 消息队列
    participant Core as Core Service
    participant Service as ClaimService
    participant DB as 数据库

    Device-&gt;&gt;HTTP: POST /api/v1/{deviceToken}/claim
    HTTP-&gt;&gt;TS: process(claimRequest)
    TS-&gt;&gt;MQ: 发送声明消息
    MQ-&gt;&gt;Core: Core Service 消费消息
    Core-&gt;&gt;Service: 校验 token、参数、业务处理
    Service-&gt;&gt;DB: 查找设备、保存密钥

    Service--&gt;&gt;Core: 返回结果
    Core--&gt;&gt;MQ: 发送处理结果
    MQ--&gt;&gt;TS: 回传处理结果
    TS--&gt;&gt;HTTP: 回调 DeviceClaimCallback
    HTTP--&gt;&gt;Device: 返回声明响应
</pre>
<p>b、平台侧认领（客户用户认领设备）</p>
<pre class="mermaid">
	sequenceDiagram
    participant User as 客户用户
    participant API as DeviceController
    participant Service as ClaimService
    participant DB as 数据库

    User-&gt;&gt;API: POST /api/customer/device/{deviceName}/claim
    API-&gt;&gt;Service: 校验权限、参数
    Service-&gt;&gt;DB: 查找设备、校验密钥
    Service-&gt;&gt;DB: 更新设备归属
    Service--&gt;&gt;API: 返回结果
    API--&gt;&gt;User: 返回声明响应
</pre>
<h3 id="4-核心实现要点">4. 核心实现要点</h3>
<ul>
<li>支持设备端和平台端两种声明方式，适配多种业务场景</li>
<li>声明过程需校验密钥、有效期，确保安全</li>
<li>设备归属权变更后，平台自动更新设备与客户/用户的关联关系</li>
<li>支持设备回收，便于设备流转和二次分配</li>
</ul>
<h2 id="五总结">五、总结</h2>
<h3 id="1-设备注册同步调用时序图">1. 设备注册同步调用时序图</h3>
<ul>
<li>当前 ThingsBoard 采用消息队列和异步回调，实现前后端解耦和高并发。</li>
<li>若去掉消息队列，HTTP 控制器将直接同步调用后端注册服务，整个流程为同步阻塞式。</li>
</ul>
<p>设备注册（同步调用）时序图如下：</p>
<pre class="mermaid">
	sequenceDiagram
    participant Device as 设备
    participant HTTP as DeviceApiController
    participant Service as DeviceProvisionServiceImpl
    participant DB as 数据库

    Device-&gt;&gt;HTTP: POST /api/v1/provision
    HTTP-&gt;&gt;Service: provisionDevice(provisionRequest)
    Service-&gt;&gt;DB: 查找/创建设备、校验 key/secret
    Service-&gt;&gt;DB: 生成凭证、保存注册状态
    Service--&gt;&gt;HTTP: 返回注册结果
    HTTP--&gt;&gt;Device: 返回注册响应
</pre>
<p>核心变化说明</p>
<ul>
<li>
<p>所有处理均在同一进程/线程内同步完成，HTTP 请求需等待全部业务处理结束后才响应。</p>
</li>
<li>
<p>无消息队列、无异步回调，前后端强耦合。</p>
</li>
<li>
<p>适合小型系统或低并发场景，但不利于横向扩展和高可用。</p>
</li>
</ul>
<h3 id="2-thingsboard-和阿里设备注册校验过程对比">2. ThingsBoard 和阿里设备注册校验过程对比</h3>
<h4 id="1-thingsboard-设备注册校验过程">1. ThingsBoard 设备注册校验过程</h4>
<p><strong>注册方式</strong></p>
<ul>
<li>
<p>自动注册（Provision）：设备通过 /api/v1/provision，提交 deviceName、provisionDeviceKey、provisionDeviceSecret。</p>
</li>
<li>
<p>校验流程：</p>
</li>
</ul>
<ol>
<li>
<p>平台根据 provisionDeviceKey 查找设备配置（Device Profile）。</p>
</li>
<li>
<p>校验 provisionDeviceSecret 是否与 profile 中配置一致。</p>
</li>
<li>
<p>校验通过后，允许注册/创建设备，生成访问凭证（如 access token）。</p>
</li>
<li>
<p>支持多种注册策略（如仅允许预注册、允许自动创建设备等）。</p>
</li>
</ol>
<p><strong>密钥管理</strong></p>
<ul>
<li>
<p>一型一密（类似）：同一 Device Profile 下所有设备共用一组 key/secret。</p>
</li>
<li>
<p>一机一密（可选）：可通过预注册每台设备，分配独立的 secret 供客户用户认领设备（但主流用法是 profile 级别）。</p>
</li>
</ul>
<p><strong>认证机制</strong></p>
<ul>
<li>注册后，设备凭 access token 进行后续通信认证。</li>
</ul>
<h4 id="2-阿里云设备注册校验过程">2. 阿里云设备注册校验过程</h4>
<ul>
<li>
<p>一型一密（动态注册/动态创建设备）</p>
<ul>
<li>
<p>前提：产品（Product）已开启“动态注册”功能，并配置了 ProductKey 和 ProductSecret。</p>
</li>
<li>
<p>流程：</p>
<ul>
<li>
<p>设备端只需知道 ProductKey、ProductSecret 和唯一的 DeviceName。</p>
</li>
<li>
<p>设备首次上线时，调用阿里云的“动态注册”API（如 /auth/register），提交 ProductKey、ProductSecret、DeviceName。</p>
</li>
<li>
<p>平台会自动为该 DeviceName 创建设备，并分配唯一的 DeviceSecret。</p>
</li>
<li>
<p>设备拿到 DeviceSecret 后，后续上线用三元组（ProductKey、DeviceName、DeviceSecret）认证。</p>
</li>
</ul>
</li>
<li>
<p>典型场景：大批量出厂、现场自动激活、无需人工在平台预注册。</p>
</li>
</ul>
</li>
<li>
<p>一机一密（静态注册）</p>
<ul>
<li>
<p>前提：设备需在平台预先注册，分配 DeviceSecret。</p>
</li>
<li>
<p>流程：设备上线时直接用三元组认证，不走动态注册流程。</p>
</li>
<li>
<p>典型场景：适合安全要求高、设备出厂前已知身份的场景。</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-主要区别对比">3. 主要区别对比</h4>
<table>
  <thead>
      <tr>
          <th style="text-align: left">对比项</th>
          <th style="text-align: left">ThingsBoard</th>
          <th style="text-align: left">阿里云 IoT（物联网平台）</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">注册接口</td>
          <td style="text-align: left">/api/v1/provision</td>
          <td style="text-align: left">动态注册 API（/auth/register）</td>
      </tr>
      <tr>
          <td style="text-align: left">密钥管理</td>
          <td style="text-align: left">主要为一型一密（profile 级别）</td>
          <td style="text-align: left">支持一型一密和一机一密</td>
      </tr>
      <tr>
          <td style="text-align: left">动态注册</td>
          <td style="text-align: left">支持，注册后生成 access token</td>
          <td style="text-align: left">支持，注册后生成 DeviceSecret</td>
      </tr>
      <tr>
          <td style="text-align: left">认证方式</td>
          <td style="text-align: left">URL token</td>
          <td style="text-align: left">三元组（ProductKey/DeviceName/DeviceSecret）+ <a href="https://help.aliyun.com/zh/iot/user-guide/establish-connections-over-http" target="_blank">签名</a></td>
      </tr>
      <tr>
          <td style="text-align: left">密钥传递位置</td>
          <td style="text-align: left">URL 路径参数</td>
          <td style="text-align: left">header/body（签名）</td>
      </tr>
      <tr>
          <td style="text-align: left">安全性</td>
          <td style="text-align: left">依赖 HTTPS，token 易被日志等记录，泄露风险较高</td>
          <td style="text-align: left">密钥不直接传输，签名防重放，安全性更高</td>
      </tr>
      <tr>
          <td style="text-align: left">预注册</td>
          <td style="text-align: left">可选，支持预注册和自动创建设备</td>
          <td style="text-align: left">一机一密必须预注册</td>
      </tr>
      <tr>
          <td style="text-align: left">典型场景</td>
          <td style="text-align: left">通用物联网平台</td>
          <td style="text-align: left">大规模设备自动化、工业/消费物联网</td>
      </tr>
  </tbody>
</table>
<p>thingsboard 设备 HTTP 相关接口：</p>
<ol>
<li>设备自动注册（Provision）：<code>POST /api/v1/provision</code></li>
<li>设备声明（Claim）：<code>POST /api/v1/{deviceToken}/claim</code></li>
<li>属性上报：<code>POST /api/v1/{deviceToken}/attributes</code></li>
<li>属性获取：<code>GET /api/v1/{deviceToken}/attributes</code></li>
<li>遥测数据上报：<code>POST /api/v1/{deviceToken}/telemetry</code></li>
<li>设备固件下载：<code>GET /api/v1/{deviceToken}/firmware?title=xxx&amp;version=yyy</code></li>
<li>设备软件包下载：<code>GET /api/v1/{deviceToken}/software?title=xxx&amp;version=yyy</code></li>
<li>订阅属性/命令（长轮询，已不推荐）：<code>GET /api/v1/{deviceToken}/attributes/updates</code>、<code>GET /api/v1/{deviceToken}/rpc</code></li>
<li>回复命令：<code>POST /api/v1/{deviceToken}/rpc/{requestId}</code></li>
<li>发送命令到平台：<code>POST /api/v1/{deviceToken}/rpc</code></li>
</ol>
<p>阿里云设备 http 相关接口：</p>
<ul>
<li>
<p>获取设备的token：/auth</p>
</li>
<li>
<p>设备注册：/auth/register</p>
</li>
<li>
<p>属性上报：/thing/property/post</p>
</li>
<li>
<p>事件上报：/thing/event/post</p>
</li>
<li>
<p>服务响应：/thing/service/xxxx</p>
</li>
<li>
<p>属性获取/设置：/thing/property/get、/thing/property/set</p>
</li>
<li>
<p>设备上线/下线：通过 HTTP2 长连接自动管理</p>
</li>
</ul>
<h4 id="4-总结">4. 总结</h4>
<ul>
<li>
<p>阿里云 IoT 支持两种密钥模式，一型一密适合大批量自动注册，一机一密适合高安全场景。</p>
</li>
<li>
<p>ThingsBoard 主要采用一型一密（profile 级别），也可通过预注册实现一机一密，但不是默认主流用法。</p>
</li>
<li>
<p>阿里云的三元组认证机制更细粒度，每台设备有独立 DeviceSecret，安全性更高，适合大规模和高安全需求。</p>
</li>
<li>
<p>ThingsBoard 注册流程更灵活，支持多种注册策略和认证方式，适合自定义和二次开发。</p>
</li>
</ul>

		</div>


	</article>
</main>
<footer class="post__footer">
	

<div class="post-related">
	<h3>相关文章</h3>
	<ul class="post-related-list">
		
		<li class="post-related-item">
			<a href="/posts/2024/07/23/jms-introduction-java-message-service/" target="_blank" title="[译]JMS介绍 – Java消息服务">[译]JMS介绍 – Java消息服务</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/02/05/til/" target="_blank" title="2024-02-05｜Spring Cloud Config快速入门">2024-02-05｜Spring Cloud Config快速入门</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2023/11/16/system-design-master-template/" target="_blank" title="[译]《Grokking the System Design Interview》系统设计主模板">[译]《Grokking the System Design Interview》系统设计主模板</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2025/06/06/oauth2-client-login-in-thingsboard/" target="_blank" title="Thingsboard源码中的OAuth2登录实现">Thingsboard源码中的OAuth2登录实现</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2025/03/31/canal-install-test/" target="_blank" title="Canal原理、安装和测试">Canal原理、安装和测试</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/05/10/all-things-about-websocket/" target="_blank" title="All things about WebSocket">All things about WebSocket</a>
		</li>
		
	</ul>
</div>

</footer>

<footer class="post__footer">
	<footer class="post__footer">
		
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/javascript/" rel="tag">javascript</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/spring-boot/" rel="tag">spring-boot</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/kafka/" rel="tag">kafka</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/rabbitmq/" rel="tag">rabbitmq</a>
		</li>
	</ul>
</div>
	</footer>
</footer>


<nav class="pagination flex">
	<div class="pagination__item pagination__item--prev">
		<a class="pagination__link" href="/posts/2025/06/06/oauth2-client-login-in-thingsboard/" rel="prev">
			<p class="pagination__title">«&thinsp;上一篇: Thingsboard源码中的OAuth2登录实现</p>
		</a>
	</div>
	<div class="pagination__item pagination__item--next">
		<a class="pagination__link" href="/posts/2025/07/15/ruoyi-ai/" rel="next">
			<p class="pagination__title">&thinsp;» 下一篇: RuoYi AI 源码分析</p>
		</a>
	</div>
</nav>



<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="ChenSoul avatar" src="/avatar.jpg" class="avatar" height="60" width="60" loading="lazy">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">关于 ChenSoul</span>
	</div>
	<div class="authorbox__description">
		一个来自中国武汉的开发者，主要撰写软件开发和开源方面的文章。浏览我的<a href="%28/posts%29">博客文章</a>，订阅我的 <a href="/index.xml">RSS</a> 源，或了解更多<a href="/about/">关于我</a>的信息。
	</div>
</div>




	<p><h3>欢迎留言！</h3></p>
<div id="remark42"></div>
<script>
	var remark_config = {
		host: 'https:\/\/comment.chensoul.cc',
		site_id: 'remark',
		components: ['embed'],
		url: 'https:\/\/blog.chensoul.cc\/posts\/2025\/07\/02\/thingsboard-http-transport\/',
		locale: 'zh'
	};

	!function(e, n) {
		for (var o = 0; o < e.length; o++) {
			var r = n.createElement('script'),
			c = '.js',
			d = n.head || n.body;
			'noModule' in r ? (r.type = 'module', c = '.mjs') : r.async = !0, r.defer = !0, r.src = remark_config.host + '/web/' + e[o] + c, d.appendChild(r)
		}
	}(remark_config.components || ['embed'], document);

</script>



<script defer src="https://cdn.jsdmirror.com/npm/mermaid@11.8.0/dist/mermaid.min.js" integrity="sha256-ozuDfeDhjEI9EXLi0CdigeIiAcaRYi3E5T+VLC9yIB4=" crossorigin="anonymous" async></script>



			</div>
			

<aside class="sidebar sidebar--right">
	<div class="post__toc toc">
		<div class="toc__title">目录</div>
		<div class="toc__menu">
			<nav id="TableOfContents">
  <ul>
    <li><a href="#一测试-http-transport">一、测试 HTTP Transport</a></li>
    <li><a href="#二http-transport-实现方式">二、HTTP Transport 实现方式</a>
      <ul>
        <li><a href="#1-架构与入口">1. 架构与入口</a></li>
        <li><a href="#2-核心模块与类">2. 核心模块与类</a></li>
        <li><a href="#3-典型接口说明">3. 典型接口说明</a></li>
        <li><a href="#4-请求认证与安全">4. 请求认证与安全</a></li>
        <li><a href="#5-典型流程举例">5. 典型流程举例</a></li>
        <li><a href="#6-测试与调试建议">6. 测试与调试建议</a></li>
        <li><a href="#7-设计启示">7. 设计启示</a></li>
      </ul>
    </li>
    <li><a href="#三设备自动注册">三、设备自动注册</a>
      <ul>
        <li><a href="#1-整体流程概述">1. 整体流程概述</a></li>
        <li><a href="#2-详细调用链">2. 详细调用链</a></li>
        <li><a href="#3-调用链时序图">3. 调用链时序图</a></li>
        <li><a href="#4-核心设计要点">4. 核心设计要点</a></li>
        <li><a href="#5-相关核心类">5. 相关核心类</a></li>
        <li><a href="#6-deviceprovisionserviceimpl-逻辑">6. DeviceProvisionServiceImpl 逻辑</a></li>
      </ul>
    </li>
    <li><a href="#四设备声明">四、设备声明</a>
      <ul>
        <li><a href="#1-典型业务流程">1. 典型业务流程</a></li>
        <li><a href="#2-接口与调用链">2. 接口与调用链</a></li>
        <li><a href="#3-时序图平台侧认领">3. 时序图（平台侧认领）</a></li>
        <li><a href="#4-核心实现要点">4. 核心实现要点</a></li>
      </ul>
    </li>
    <li><a href="#五总结">五、总结</a>
      <ul>
        <li><a href="#1-设备注册同步调用时序图">1. 设备注册同步调用时序图</a></li>
        <li><a href="#2-thingsboard-和阿里设备注册校验过程对比">2. ThingsBoard 和阿里设备注册校验过程对比</a></li>
      </ul>
    </li>
  </ul>
</nav>
		</div>
	</div>
</aside>

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
<div class="footer__links">
	<a class="footer__link" href="/">首页</a> | <a class="footer__link" href="/categories/">分类</a> | <a class="footer__link" href="/tags/">标签</a> | <a class="footer__link" href="/index.xml">订阅</a> | <a class="footer__link" href="/about/">关于</a>
</div>
		<div class="footer__copyright">
			&copy; 2025 ChenSoul.
			<span class="footer__copyright-credits">基于 <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> 引擎和 <a href="https://github.com/chensoul/rose-hugo/" rel="nofollow noopener" target="_blank">Rose Hugo</a> 主题</span>
		</div>
	</div>

	






<style>
	.scroll-up a {
		display: block;
		height: 3.125rem;
		width: 3.125rem;
		text-align: center;
		line-height: 2.7;
		border-radius: 50px;
		font-size: 1.125rem;
		color: #fff;
		opacity: 1;
		transition: all 0.3s ease 0s;
		box-shadow: 0 0 10px rgb(0 0 0 / 20%);
	}
	.scroll-up a {
		background: #ee591f;
	}
	.scroll-up {
		position: fixed;
		display: none;
		bottom: 50px;
		z-index: 999;
	}
	.scroll-up.right {
		right: 60px;
	}
</style>

<div class="scroll-up custom right" style="display: block;"><a href="#top" id="top-link" accesskey="g"><i
	class="fa fa-arrow-up"></i></a></div>

<script>
	var mybutton = document.getElementById("top-link");
	window.onscroll = function () {
		if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
			mybutton.style.visibility = "visible";
			mybutton.style.opacity = "1";
		} else {
			mybutton.style.visibility = "hidden";
			mybutton.style.opacity = "0";
		}
	};
</script>


    <script defer src="https://umami.chensoul.cc/random-string.js" data-website-id="1e07d36d-bec3-4ba6-9459-876b1ac3bbe7"></script>
</footer>


	</div>

	<script>
		'use strict';
		(function iifeMenu(document, window, undefined) {
			var menuBtn = document.querySelector('.menu__btn');
			var	menu = document.querySelector('.menu__list');
			function toggleMenu() {
				menu.classList.toggle('menu__list--active');
				menu.classList.toggle('menu__list--transition');
				this.classList.toggle('menu__btn--active');
				this.setAttribute(
					'aria-expanded',
					this.getAttribute('aria-expanded') === 'true' ? 'false' : 'true'
				);
			}
			function removeMenuTransition() {
				this.classList.remove('menu__list--transition');
			}
			if (menuBtn && menu) {
				menuBtn.addEventListener('click', toggleMenu, false);
				menu.addEventListener('transitionend', removeMenuTransition, false);
			}
		}(document, window));
	</script>
</body>
</html>