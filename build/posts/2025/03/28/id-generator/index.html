<!DOCTYPE html>
<html class="no-js" lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>常见分布式 ID 解决方案 - Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="常见分布式 ID 解决方案">
	<meta property="og:description" content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps">
	<meta property="og:type" content="article">
	<meta property="og:url" content="https://blog.chensoul.cc/posts/2025/03/28/id-generator/">
	<meta property="og:site_name" content="ChenSoul Blog">
	<meta property="og:image" content="">
	
  <meta itemprop="name" content="常见分布式 ID 解决方案">
  <meta itemprop="description" content="分布式 ID 的生成是分布式系统中的一个核心问题，需要确保生成的 ID 全局唯一、性能高效，并且能够适应高并发和大规模的场景。以下是一些常见的分布式 ID 生成方案：">
  <meta itemprop="datePublished" content="2025-03-28T00:00:00+00:00">
  <meta itemprop="dateModified" content="2025-03-28T00:00:00+00:00">
  <meta itemprop="wordCount" content="307">
  <meta itemprop="keywords" content="Mysql,Mongodb,Redis,Backend">
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:title" content="常见分布式 ID 解决方案">
	<meta name="twitter:description" content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps">
	<meta name="twitter:image" content="">

	<link rel="preconnect" href="//fonts.loli.net" crossorigin>
	<link rel="dns-prefetch" href="//fonts.loli.net">
	<link rel="stylesheet" href="https://fonts.loli.net/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css" integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
	<link rel="stylesheet" href="/css/style.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="ChenSoul Blog" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="/logo.svg" loading="lazy" alt="Site logo" width="60" height="60">
				</div><div class="logo__item logo__text">
					<div class="logo__title">ChenSoul Blog</div>
					<div class="logo__tagline">Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">菜单</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/">
				
				<span class="menu__text">首页</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/categories/">
				
				<span class="menu__text">分类</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/tags/">
				
				<span class="menu__text">标签</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/index.xml">
				
				<span class="menu__text">订阅</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">关于</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">常见分布式 ID 解决方案</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 1 1 0 28 1 1 0 0 1 0-28m0 3a3 3 0 1 0 0 22 3 3 0 0 0 0-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class="meta__text" datetime="2025-03-28">2025-03-28</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class="meta__text"><a class="meta__link" href="/categories/java/" rel="category">Java</a>
	</span>
</div><div class="meta__item-tags meta__item"><svg class="meta__icon icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg><span class="meta__text"><a class="meta__link" href="/tags/mysql/" rel="tag">Mysql</a>, <a class="meta__link" href="/tags/mongodb/" rel="tag">Mongodb</a>, <a class="meta__link" href="/tags/redis/" rel="tag">Redis</a>, <a class="meta__link" href="/tags/backend/" rel="tag">Backend</a>
	</span>
</div>
</div>
		</header>
		
		<div class="content post__content clearfix">
			<p>分布式 ID 的生成是分布式系统中的一个核心问题，需要确保生成的 ID 全局唯一、性能高效，并且能够适应高并发和大规模的场景。以下是一些常见的分布式 ID 生成方案：</p>
<ol>
<li>UUID</li>
</ol>
<ul>
<li><strong>原理</strong>：UUID（Universally Unique Identifier）是一种通过一系列算法生成的128位数字，通常基于时间戳、计算机硬件标识符、随机数等元素。</li>
<li><strong>优点</strong>：实现简单，无需网络交互，保证全局唯一性。</li>
<li><strong>缺点</strong>：ID 较长（36个字符的字符串形式），可能导致存储和索引效率低下，且通常不能保证顺序性。</li>
<li><strong>适用场景</strong>：适用于对唯一性要求高，但对性能和存储空间要求不敏感的场景。</li>
</ul>
<ol start="2">
<li>NanoID</li>
</ol>
<ul>
<li>
<p><strong>原理</strong>：NanoID 是一个轻量级、安全、URL 友好的唯一字符串 ID 生成器。它使用加密安全的随机数生成器，确保生成的 ID 足够随机和安全。</p>
<ul>
<li>在 Java 中实现 NanoID，可以使用 <a href="https://github.com/aventrix/jnanoid/" target="_blank">jnanoid</a> 库。</li>
</ul>
</li>
<li>
<p><strong>优点</strong>：</p>
<ul>
<li>
<p><strong>短小精悍</strong>：生成的 ID 默认长度为 21 个字符，减少了存储空间的占用，提升了传输效率。</p>
</li>
<li>
<p><strong>安全性高</strong>：使用硬件随机数生成机制，借助 <code>crypto module</code> 和 <code>Web Crypto API</code>，确保生成的 ID 足够安全。</p>
</li>
<li>
<p><strong>URL 友好</strong>：生成的 ID 只包含 URL 安全的字符，方便在 URL 中使用。</p>
</li>
<li>
<p><strong>性能优越</strong>：生成 ID 的速度非常快，比 UUID 快了约 60%。</p>
</li>
<li>
<p><strong>高度可定制</strong>：支持自定义 ID 的字母表和长度，灵活适配不同项目需求。</p>
</li>
</ul>
</li>
<li>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>非人类可读</strong>：ID 不是连续的，可能使调试变得更加困难。</li>
</ul>
</li>
<li>
<p><strong>适用场景</strong>：</p>
<ul>
<li>
<p><strong>Web 应用程序</strong>：在 Web 开发中，NanoID 可以缩短 URL 长度，提升用户体验。</p>
</li>
<li>
<p><strong>短链服务</strong>：生成短小精悍的短链 ID，便于分享和记忆。</p>
</li>
<li>
<p><strong>分布式系统</strong>：在分布式环境中，用于节点间的消息标记。</p>
</li>
<li>
<p><strong>API 令牌</strong>：安全地生成短期有效的 API 访问令牌。</p>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>数据库自增 ID</li>
</ol>
<ul>
<li><strong>原理</strong>：基于数据库的 <code>auto_increment</code> 自增 ID 可以生成分布式 ID。通过批量获取 ID 号段，减少对数据库的依赖。
<ul>
<li>如果使用多个数据库，则将增长 ID 错开。</li>
</ul>
</li>
<li><strong>优点</strong>：实现简单，ID 单调自增，数值类型查询速度快。</li>
<li><strong>缺点</strong>：在高并发场景下，单点数据库会成为性能瓶颈，且存在单点故障风险。</li>
<li><strong>适用场景</strong>：适用于对 ID 顺序性有要求，且并发量不高的场景。</li>
</ul>
<ol start="4">
<li>Redis 生成 ID</li>
</ol>
<ul>
<li><strong>原理</strong>：通过 Redis 的原子性 INCR 和 INCRBY 命令生成唯一的递增数值。</li>
<li><strong>优点</strong>：Redis 的高性能保证了即使在高负载下也能快速生成 ID。</li>
<li><strong>缺点</strong>：高度依赖网络，且需要额外的基础设施管理和维护。</li>
<li><strong>适用场景</strong>：适用于需要高并发生成 ID 的场景。</li>
</ul>
<ol start="5">
<li>Snowflake 算法</li>
</ol>
<ul>
<li><strong>原理</strong>：Snowflake 是 Twitter 开源的一种分布式 ID 生成算法，生成的是一个 64 位的长整型数字。通过组合时间戳、数据中心 ID、机器 ID 和序列号来确保 ID 的全局唯一性和趋势递增。
<ul>
<li>Mybatis-plus 可以使用 DefaultIdentifierGenerator 传入当前机器 IP 生成 workId 和 dataCenterId，但没有解决时钟回拨的问题。</li>
</ul>
</li>
<li><strong>优点</strong>：不依赖数据库，适合分布式环境，生成 ID 的性能高。</li>
<li><strong>缺点</strong>：<strong>强依赖机器时钟，如果机器时钟发生回拨，可能导致重复 ID</strong>。</li>
<li><strong>适用场景</strong>：适用于需要全局唯一、递增 ID 的高并发分布式系统。</li>
</ul>
<ol start="6">
<li>Leaf</li>
</ol>
<ul>
<li><strong>原理</strong>：Leaf 是美团开源的分布式 ID 生成系统，提供了两种生成 ID 的方式：Leaf-segment 号段模式和 Leaf-snowflake 雪花算法。
<ul>
<li><strong>Leaf-segment 号段模式</strong>：服务启动时从数据库获取一段 ID 号段并缓存到内存，之后直接从内存中分配 ID；当号段快用完时，异步从数据库获取新的号段，同时使用双 buffer 确保业务不受阻塞。</li>
</ul>
</li>
<li><strong>优点</strong>：高性能、高可用、接入简单。</li>
<li><strong>缺点</strong>：依赖第三方组件如 ZooKeeper、MySQL。</li>
<li><strong>适用场景</strong>：适用于需要高可用性和高性能的分布式系统。</li>
</ul>
<ol start="7">
<li>UidGenerator</li>
</ol>
<ul>
<li><strong>原理</strong>：UidGenerator 是百度开源的基于 Snowflake 算法的分布式 ID 生成器，克服了雪花算法的并发限制。
<ul>
<li>通过预生成一批唯一ID并缓存到RingBuffer中，避免了每次生成ID时对系统时钟的依赖，从而有效解决了雪花算法的时钟回拨问题。</li>
<li>克服了雪花算法的并发限制
<ul>
<li><strong>借用未来时间</strong>：当当前秒内的 sequence 达到最大值时，UidGenerator 会借用未来的时间来生成新的 ID，从而突破了每秒生成 ID 数量的限制。</li>
<li><strong>使用 RingBuffer 缓存 ID</strong>：UidGenerator 采用 RingBuffer 来缓存已生成的 UID，通过并行化 UID 的生产和消费，提高了 ID 生成的效率。</li>
<li><strong>避免硬件级“伪共享”问题</strong>：通过对 CacheLine 补齐，避免了由 RingBuffer 带来的硬件级“伪共享”问题，进一步提升了性能</li>
</ul>
</li>
</ul>
</li>
<li><strong>优点</strong>：单个实例的 QPS 能超过 6000000。</li>
<li><strong>缺点</strong>：需要依赖 MySQL 来分配 WorkerId。</li>
<li><strong>适用场景</strong>：适用于高并发、高性能要求的分布式系统。</li>
</ul>
<ol start="8">
<li>TinyID</li>
</ol>
<ul>
<li><strong>原理</strong>：TinyID 是滴滴基于美团 Leaf 的号段模式基础上升级而来，支持数据库多主节点模式，并提供了 tinyid-client 客户端的接入方式。</li>
<li><strong>优点</strong>：支持多主节点模式，接入方便。</li>
<li><strong>缺点</strong>：依赖数据库。</li>
<li><strong>适用场景</strong>：适用于需要高可用性和扩展性的分布式系统。</li>
</ul>
<ol start="9">
<li>CosId</li>
</ol>
<ul>
<li><strong>原理</strong>：CosId 提供了通用、灵活、高性能的分布式 ID 生成器，包括 SnowflakeId、SegmentId 和 SegmentChainId 等多种生成方式。
<ul>
<li>SnowflakeId：
<ul>
<li>当发生时钟回拨时会使用<code>ClockBackwardsSynchronizer</code>主动等待时钟同步来重新生成ID。</li>
</ul>
</li>
<li>SegmentId：号段模式
<ul>
<li>SegmentId 每次从号段分发器获取一段连续的 ID 号段，并将其缓存到内存中，以减少对号段分发器的网络 IO 请求，从而提升性能。</li>
<li>当内存中的号段即将耗尽时，需要同步地从号段分发器获取新的号段，这可能导致业务流程的短暂阻塞。</li>
</ul>
</li>
<li>SegmentChainId：号段链模式
<ul>
<li>SegmentChainId 是 SegmentId 的增强版，通过 PrefetchWorker 提前获取新的号段，并维护一个安全距离，并支持基于饥饿状态的动态扩容/收缩安全距离。</li>
<li>性能可达到近似 AtomicLong 的 TPS 性能</li>
</ul>
</li>
</ul>
</li>
<li><strong>优点</strong>：高性能，支持多种存储后端（如 Redis、Jdbc、Zookeeper、MongoDB 等）。</li>
<li><strong>缺点</strong>：需要根据具体存储后端进行配置和管理。</li>
<li><strong>适用场景</strong>：适用于需要高性能、高可用性的分布式系统。</li>
</ul>
<p>总结比较</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">方案</th>
          <th style="text-align: left">优点</th>
          <th style="text-align: left">缺点</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">UUID</td>
          <td style="text-align: left">代码实现简单、没有网络开销，性能好</td>
          <td style="text-align: left">占用空间大、无序</td>
      </tr>
      <tr>
          <td style="text-align: left">数据库自增 ID</td>
          <td style="text-align: left">实现简单、ID 自增有序</td>
          <td style="text-align: left">并发性能受限、单点故障风险</td>
      </tr>
      <tr>
          <td style="text-align: left">Redis INCR</td>
          <td style="text-align: left">性能优于数据库、ID 有序</td>
          <td style="text-align: left">单点问题带来的数据一致性等问题</td>
      </tr>
      <tr>
          <td style="text-align: left">Snowflake 算法</td>
          <td style="text-align: left">不依赖数据库等第三方系统，性能高</td>
          <td style="text-align: left">时钟回拨可能导致重复 ID</td>
      </tr>
      <tr>
          <td style="text-align: left">NanoID</td>
          <td style="text-align: left">短小精悍、安全性高、生成速度快、URL友好</td>
          <td style="text-align: left">非人类可读、不连续</td>
      </tr>
      <tr>
          <td style="text-align: left">Leaf</td>
          <td style="text-align: left">高性能、高可用、接入简单</td>
          <td style="text-align: left">依赖第三方组件如 ZooKeeper、MySQL</td>
      </tr>
      <tr>
          <td style="text-align: left">UidGenerator</td>
          <td style="text-align: left">单个实例的 QPS 能超过 6000000</td>
          <td style="text-align: left">需要依赖 MySQL 来分配 WorkerId</td>
      </tr>
      <tr>
          <td style="text-align: left">TinyID</td>
          <td style="text-align: left">支持多主节点模式，接入方便</td>
          <td style="text-align: left">依赖数据库</td>
      </tr>
      <tr>
          <td style="text-align: left">CosId</td>
          <td style="text-align: left">高性能，支持多种存储后端</td>
          <td style="text-align: left">可以解决Snowflake 算法时钟回拨问题；需要根据具体存储后端进行配置和管理</td>
      </tr>
  </tbody>
</table>
<p>根据实际需求选择合适的分布式 ID 生成方案，可以更好地满足系统的性能、可用性和扩展性要求。NanoID 凭借其超轻量级、安全性强、生成快速紧凑、兼容性佳以及高度可定制等诸多优势，在众多 ID 生成工具中脱颖而出，为开发者们提供了一种高效、可靠的解决方案。</p>

		</div>


	</article>
</main>
<footer class="post__footer">
	

<div class="post-related">
	<h3>相关文章</h3>
	<ul class="post-related-list">
		
		<li class="post-related-item">
			<a href="/posts/2023/12/05/distributed-id-generator/" target="_blank" title="如何设计一个分布式ID生成器保证ID按时间有序？">如何设计一个分布式ID生成器保证ID按时间有序？</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2025/02/17/top-n-using-redis/" target="_blank" title="如何实现榜单 top N 统计">如何实现榜单 top N 统计</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2025/02/14/rate-limit/" target="_blank" title="什么是限流">什么是限流</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/08/01/publishing-a-jar-to-maven-repository-with-github-action/" target="_blank" title="Github Action 发布 Jar 到 Maven 中央仓库">Github Action 发布 Jar 到 Maven 中央仓库</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/04/17/thingsboard-tbmq-local-docker-run/" target="_blank" title="ThingsBoard TBMQ本地和通过Docker运行">ThingsBoard TBMQ本地和通过Docker运行</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/02/01/til/" target="_blank" title="2024-02-01｜使用 Spring Initializr 创建项目">2024-02-01｜使用 Spring Initializr 创建项目</a>
		</li>
		
	</ul>
</div>

</footer>

<footer class="post__footer">
	<footer class="post__footer">
		
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/mysql/" rel="tag">mysql</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/mongodb/" rel="tag">mongodb</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/redis/" rel="tag">redis</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/backend/" rel="tag">backend</a>
		</li>
	</ul>
</div>
	</footer>
</footer>


<nav class="pagination flex">
	<div class="pagination__item pagination__item--prev">
		<a class="pagination__link" href="/posts/2025/02/17/top-n-using-redis/" rel="prev">
			<p class="pagination__title">«&thinsp;上一篇: 如何实现榜单 top N 统计</p>
		</a>
	</div>
	<div class="pagination__item pagination__item--next">
		<a class="pagination__link" href="/posts/2025/03/31/canal-install-test/" rel="next">
			<p class="pagination__title">&thinsp;» 下一篇: Canal原理、安装和测试</p>
		</a>
	</div>
</nav>



<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="ChenSoul avatar" src="/avatar.jpg" class="avatar" height="60" width="60" loading="lazy">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">关于 ChenSoul</span>
	</div>
	<div class="authorbox__description">
		一个来自中国武汉的开发者，主要撰写软件开发和开源方面的文章。浏览我的<a href="%28/posts%29">博客文章</a>，订阅我的 <a href="/index.xml">RSS</a> 源，或了解更多<a href="/about/">关于我</a>的信息。
	</div>
</div>




	<p><h3>欢迎留言！</h3></p>
<div id="remark42"></div>
<script>
	var remark_config = {
		host: 'https:\/\/comment.chensoul.cc',
		site_id: 'remark',
		components: ['embed'],
		url: 'https:\/\/blog.chensoul.cc\/posts\/2025\/03\/28\/id-generator\/',
		locale: 'zh'
	};

	!function(e, n) {
		for (var o = 0; o < e.length; o++) {
			var r = n.createElement('script'),
			c = '.js',
			d = n.head || n.body;
			'noModule' in r ? (r.type = 'module', c = '.mjs') : r.async = !0, r.defer = !0, r.src = remark_config.host + '/web/' + e[o] + c, d.appendChild(r)
		}
	}(remark_config.components || ['embed'], document);

</script>





			</div>
			


		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
<div class="footer__links">
	<a class="footer__link" href="/">首页</a> | <a class="footer__link" href="/categories/">分类</a> | <a class="footer__link" href="/tags/">标签</a> | <a class="footer__link" href="/index.xml">订阅</a> | <a class="footer__link" href="/about/">关于</a>
</div>
		<div class="footer__copyright">
			&copy; 2025 ChenSoul.
			<span class="footer__copyright-credits">基于 <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> 引擎和 <a href="https://github.com/chensoul/rose-hugo/" rel="nofollow noopener" target="_blank">Rose Hugo</a> 主题</span>
		</div>
	</div>

	






<style>
	.scroll-up a {
		display: block;
		height: 3.125rem;
		width: 3.125rem;
		text-align: center;
		line-height: 2.7;
		border-radius: 50px;
		font-size: 1.125rem;
		color: #fff;
		opacity: 1;
		transition: all 0.3s ease 0s;
		box-shadow: 0 0 10px rgb(0 0 0 / 20%);
	}
	.scroll-up a {
		background: #ee591f;
	}
	.scroll-up {
		position: fixed;
		display: none;
		bottom: 50px;
		z-index: 999;
	}
	.scroll-up.right {
		right: 60px;
	}
</style>

<div class="scroll-up custom right" style="display: block;"><a href="#top" id="top-link" accesskey="g"><i
	class="fa fa-arrow-up"></i></a></div>

<script>
	var mybutton = document.getElementById("top-link");
	window.onscroll = function () {
		if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
			mybutton.style.visibility = "visible";
			mybutton.style.opacity = "1";
		} else {
			mybutton.style.visibility = "hidden";
			mybutton.style.opacity = "0";
		}
	};
</script>


    <script defer src="https://umami.chensoul.cc/random-string.js" data-website-id="1e07d36d-bec3-4ba6-9459-876b1ac3bbe7"></script>
</footer>


	</div>

	<script>
		'use strict';
		(function iifeMenu(document, window, undefined) {
			var menuBtn = document.querySelector('.menu__btn');
			var	menu = document.querySelector('.menu__list');
			function toggleMenu() {
				menu.classList.toggle('menu__list--active');
				menu.classList.toggle('menu__list--transition');
				this.classList.toggle('menu__btn--active');
				this.setAttribute(
					'aria-expanded',
					this.getAttribute('aria-expanded') === 'true' ? 'false' : 'true'
				);
			}
			function removeMenuTransition() {
				this.classList.remove('menu__list--transition');
			}
			if (menuBtn && menu) {
				menuBtn.addEventListener('click', toggleMenu, false);
				menu.addEventListener('transitionend', removeMenuTransition, false);
			}
		}(document, window));
	</script>
</body>
</html>