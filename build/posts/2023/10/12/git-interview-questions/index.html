<!DOCTYPE html>
<html class="no-js" lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[译]DevOps 和测试人员的 Git 面试问题 - Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="[译]DevOps 和测试人员的 Git 面试问题">
	<meta property="og:description" content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps">
	<meta property="og:type" content="article">
	<meta property="og:url" content="https://blog.chensoul.cc/posts/2023/10/12/git-interview-questions/">
	<meta property="og:site_name" content="ChenSoul Blog">
	<meta property="og:image" content="">
	
  <meta itemprop="name" content="[译]DevOps 和测试人员的 Git 面试问题">
  <meta itemprop="description" content="欢迎来到 Git 面试准备指南，我们将在这里向初学者和经验丰富的专业人士讨论最常见的 Git 面试问题。无论您是准备参加 DevOps 或测试面试，还是希望提高 Git 技能，此资源都可以通过深入研究一些与 Git 基本概念和实践相关的最常见面试问题来帮助您。">
  <meta itemprop="datePublished" content="2023-10-12T00:00:00+00:00">
  <meta itemprop="dateModified" content="2023-10-12T00:00:00+00:00">
  <meta itemprop="wordCount" content="1106">
  <meta itemprop="keywords" content="Java,Javascript,Spring-Boot,Backend">
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:title" content="[译]DevOps 和测试人员的 Git 面试问题">
	<meta name="twitter:description" content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps">
	<meta name="twitter:image" content="">

	<link rel="preconnect" href="//fonts.loli.net" crossorigin>
	<link rel="dns-prefetch" href="//fonts.loli.net">
	<link rel="stylesheet" href="https://fonts.loli.net/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css" integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
	<link rel="stylesheet" href="/css/style.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="ChenSoul Blog" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="/logo.svg" loading="lazy" alt="Site logo" width="60" height="60">
				</div><div class="logo__item logo__text">
					<div class="logo__title">ChenSoul Blog</div>
					<div class="logo__tagline">Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">菜单</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/">
				
				<span class="menu__text">首页</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/categories/">
				
				<span class="menu__text">分类</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/tags/">
				
				<span class="menu__text">标签</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/index.xml">
				
				<span class="menu__text">订阅</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">关于</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[译]DevOps 和测试人员的 Git 面试问题</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 1 1 0 28 1 1 0 0 1 0-28m0 3a3 3 0 1 0 0 22 3 3 0 0 0 0-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class="meta__text" datetime="2023-10-12">2023-10-12</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class="meta__text"><a class="meta__link" href="/categories/devops/" rel="category">Devops</a>
	</span>
</div><div class="meta__item-tags meta__item"><svg class="meta__icon icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg><span class="meta__text"><a class="meta__link" href="/tags/java/" rel="tag">Java</a>, <a class="meta__link" href="/tags/javascript/" rel="tag">Javascript</a>, <a class="meta__link" href="/tags/spring-boot/" rel="tag">Spring-Boot</a>, <a class="meta__link" href="/tags/backend/" rel="tag">Backend</a>
	</span>
</div>
</div>
		</header>
		
		<div class="content post__content clearfix">
			<p>欢迎来到 Git 面试准备指南，我们将在这里向初学者和经验丰富的专业人士讨论最常见的 Git 面试问题。无论您是准备参加 DevOps 或测试面试，还是希望提高 Git 技能，此资源都可以通过深入研究一些与 Git 基本概念和实践相关的最常见面试问题来帮助您。</p>
<p>我们将涵盖所有重要主题，例如分支、存储库管理、处理合并冲突和协作工作流程。通过探索这些问题，您将更深入地了解 Git 的版本控制系统，并更好地应对开发项目中的现实挑战。</p>
<h2 id="1什么是版本控制系统">1.什么是版本控制系统？</h2>
<p><a href="https://www.atlassian.com/git/tutorials/what-is-version-control" target="_blank">版本控制系统</a> (VCS) 是一种帮助跟踪和管理文件和代码随时间变化的软件。它允许多人协作处理一个项目，跟踪修订，并在需要时轻松恢复到以前的版本。</p>
<p>版本控制系统主要分为三种类型：</p>
<ul>
<li>本地版本控制系统 (LVCS)：在 LVCS 中，版本控制数据库存储在本地计算机上。更改和修订在位于用户计算机上的本地存储库中进行跟踪。但此类系统缺乏协作功能，不利于团队开发。</li>
</ul>
<p><img src="../../../static/images/git-interview-questions-01.webp" alt="img"></p>
<ul>
<li>集中版本控制系统 (CVCS)：在 CVCS 中，版本控制数据库存储在中央服务器上。用户可以从服务器检出文件、进行更改并将其提交回服务器。这允许多个用户在同一项目上进行协作，并提供对存储库的集中控制。然而，CVCS 的一个缺点是，如果中央服务器出现故障，协作者将无法执行某些操作，直到服务器恢复为止。</li>
</ul>
<p><img src="../../../static/images/git-interview-questions-02.webp" alt="img"></p>
<ul>
<li>分布式版本控制系统 (DVCS)：在 DVCS 中，每个用户都有一个包含整个版本历史记录的本地存储库。这意味着每个用户都拥有项目存储库的完整副本，包括所有分支和修订。用户可以在本地存储库上独立工作，并与其他存储库同步更改。 DVCS 为分布式和分散式工作流程提供更好的支持，允许用户离线工作并更有效地协作。</li>
</ul>
<p><img src="../../../static/images/git-interview-questions-03.webp" alt="img"></p>
<h2 id="2-git-中的-origin-是什么">2. Git 中的 Origin 是什么？</h2>
<p>在 Git 中，“origin”是指我们从中克隆的远程存储库。当我们从远程服务器克隆存储库时，Git 会自动创建一个名为“origin”的远程引用，该引用指向原始远程存储库。</p>
<p>默认情况下，当我们克隆存储库时，Git 会设置“来源”并将其与我们克隆的原始存储库关联起来。我们可以通过运行命令“git remote -v”来验证这一点。此命令显示与本地存储库关联的远程存储库列表及其 URL。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git remote -v
</span></span><span style="display:flex;"><span>origin https://github.com/lokeshgupta1981/Spring-Boot3-Demos.git <span style="color:#f92672">(</span>fetch<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>origin https://github.com/lokeshgupta1981/Spring-Boot3-Demos.git <span style="color:#f92672">(</span>push<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>请注意，“origin”只是一个未硬编码的别名，可以使用以下命令提示符进行更改：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git remote rename origin newName
</span></span></code></pre></div><h2 id="3我们如何在-git-中配置全局用户名和电子邮件">3.我们如何在 Git 中配置全局用户名和电子邮件？</h2>
<p>设置全局一致的用户名和电子邮件地址非常重要，因为 Git 使用此信息将提交与正确的作者关联起来。它有助于识别每个提交的人员，并允许在项目内进行适当的协作和归属。</p>
<p>要在 Git 中配置全局用户名和电子邮件，我们可以使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git config --global user.name <span style="color:#e6db74">&#34;MyName&#34;</span>
</span></span><span style="display:flex;"><span>git config --global user.email <span style="color:#e6db74">&#34;myname@gmail.com&#34;</span>
</span></span></code></pre></div><p>这些命令将全局设置用户名和电子邮件，这意味着它们将用于您计算机上的所有 Git 存储库，除非在存储库级别覆盖。</p>
<p>您可以通过运行以下命令来验证更改。这些命令将分别显示配置的用户名和电子邮件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git config --global user.name   <span style="color:#75715e"># Prints &#39;lokeshgupta1981&#39;</span>
</span></span><span style="display:flex;"><span>git config --global user.email    <span style="color:#75715e"># Prints &#39;howtodoinjava@gmail.com&#39;</span>
</span></span></code></pre></div><h2 id="4-git-中的暂存区是什么意思">4. Git 中的“暂存区”是什么意思？</h2>
<p>Git 中的“暂存区域”也称为“索引”，是一个中间区域，在将文件提交到 Git 存储库之前，在此区域准备对文件的更改。</p>
<p>当我们对项目文件进行更改时，Git 提供了一个两步过程来提交这些更改。暂存区域充当工作目录（进行修改的位置）和存储库（存储提交的位置 =&gt; .git 文件夹）之间的桥梁。</p>
<p><img src="../../../static/images/git-interview-questions-04.webp" alt="img"></p>
<p>通过使用暂存区，我们可以将不相关的更改分离到多个提交中，或者有选择地包含特定修改而排除其他修改。它提供了一个在变更成为项目历史的一部分之前审查和完善我们的变更的机会。</p>
<h2 id="5-git-中的分叉分支和克隆之间的区别">5. Git 中的分叉、分支和克隆之间的区别？</h2>
<p>分叉、分支和克隆都是 Git 操作，在版本控制工作流程中具有不同的用途。在深入研究之前，让我们先对它们进行比较。</p>
<p>以下是 Git 中分叉、分支和克隆的表格比较：</p>
<table>
  <thead>
      <tr>
          <th>特征</th>
          <th>分叉</th>
          <th>分枝</th>
          <th>克隆</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>目的</td>
          <td>在您的 GitHub 帐户上创建远程存储库的副本。</td>
          <td>在 Git 存储库中创建单独的开发线。</td>
          <td>在您的计算机上创建 Git 存储库的本地副本。</td>
      </tr>
      <tr>
          <td>所有权</td>
          <td>创建一个由您拥有的完全独立的存储库。</td>
          <td>在同一存储库中，分支归原始存储库所有。</td>
          <td>本地副本；所有权没有变化。</td>
      </tr>
      <tr>
          <td>起源</td>
          <td>源自远程存储库，通常位于 GitHub 上。</td>
          <td>源自现有的本地或远程存储库。</td>
          <td>源自现有的远程或本地存储库。</td>
      </tr>
      <tr>
          <td>改变可见性</td>
          <td>在创建拉取请求之前，在分叉中所做的更改独立于原始存储库。</td>
          <td>在分支中所做的更改将被隔离，直到您将它们合并回主分支。</td>
          <td>在将更改推送到远程存储库之前，更改都是本地的。</td>
      </tr>
      <tr>
          <td>用例</td>
          <td>通常用于为开源项目做出贡献或创建单独的副本供个人使用。</td>
          <td>用于协作环境中的功能开发、错误修复和隔离更改。</td>
          <td>用于处理存储库的本地副本，通常用于个人开发。</td>
      </tr>
  </tbody>
</table>
<h3 id="分叉">分叉</h3>
<p>分叉是一个与远程存储库相关的概念，特别是在 GitHub、GitLab 和 Bitbucket 等平台上。分叉在我们自己的帐户中创建原始存储库的副本。</p>
<p>要在 GitHub（或类似平台）上分叉存储库，通常在存储库页面上有一个“分叉”按钮。单击此按钮将在您的 GitHub 帐户中创建原始存储库的分支。</p>
<p>当我们想要为开源项目做出贡献或创建我们自己的独立项目版本时，通常会使用分叉。分叉存储库与原始存储库分开，允许我们进行更改、实验和提交拉取请求，而不会影响原始项目。</p>
<h3 id="分枝">分枝</h3>
<p>分支允许在存储库中创建单独的开发线。它使我们能够彼此独立地处理不同的功能、错误修复或实验。</p>
<p>要在 Git 中创建分支，我们使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git branch &lt;branch_name&gt;
</span></span></code></pre></div><p>通过创建分支，我们实质上创建了一个新的时间线，我们可以在不影响主分支（通常称为“master”或“main”）的情况下进行更改。一旦我们对分支中所做的更改感到满意，我们就可以将分支合并回主分支以合并更改。</p>
<p>分支是协作开发的强大工具，使多个开发人员能够同时处理不同的任务，同时保持干净且有组织的提交历史记录。</p>
<h3 id="克隆">克隆</h3>
<p>克隆创建远程存储库的本地副本。当我们克隆存储库时，我们会将整个项目的历史记录、文件和分支下载到本地计算机。</p>
<p>要将远程存储库克隆到本地计算机，我们使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git clone &lt;repository_url&gt;
</span></span></code></pre></div><p>克隆在本地存储库和远程存储库之间建立连接，使我们能够获取更新、推送更改以及与其他人协作。当我们想要开始使用现有存储库时，通常会进行克隆。</p>
<h2 id="6-什么是-git-stash">6. 什么是 Git Stash？</h2>
<p>在 Git 中，“存储”功能允许我们临时保存对工作目录所做的更改，而无需提交它们。它提供了一种存储我们的修改并切换到不同分支或应用其他操作的方法，而无需提交不完整或实验性更改。</p>
<p>存储存储在本地，不会推送到远程存储库，这使得它们适合个人工作流程组织和实验。</p>
<p><code>git stash</code> 命令用于创建和管理存储。以下是与 Git stash 相关的一些常见用例和命令：</p>
<h3 id="creating-a-stash">Creating a stash</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git stash save <span style="color:#e6db74">&#34;Stash message&#34;</span>
</span></span></code></pre></div><p>此命令将我们的修改保存在新的存储中，并带有描述存储的可选消息。 Git 将从我们的工作目录中恢复更改，使其保持干净。</p>
<h3 id="viewing-stashes">Viewing stashes</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git stash list
</span></span></code></pre></div><p>此命令显示您已创建的存储的列表，以及它们的存储引用和消息。</p>
<h3 id="applying-a-stash">Applying a stash</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git stash apply stash@<span style="color:#f92672">{</span>n<span style="color:#f92672">}</span> / n in <span style="color:#f92672">[</span>0.....P<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>此命令将特定存储中的更改应用到当前分支。 <code>stash@{n}</code> 指的是列表中的存储引用。默认情况下，它适用于最新的存储。</p>
<h3 id="applying-and-removing-a-stash">Applying and removing a stash</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git stash pop stash@<span style="color:#f92672">{</span>n<span style="color:#f92672">}</span>
</span></span></code></pre></div><p>此命令应用特定存储中的更改，并一步将其从存储列表中删除。它相当于应用存储然后使用 <code>git stash drop</code> 将其删除。</p>
<h3 id="applying-a-stash-to-a-different-branch">Applying a stash to a different branch</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git stash branch branch-name stash@<span style="color:#f92672">{</span>n<span style="color:#f92672">}</span>
</span></span></code></pre></div><p>此命令创建一个新分支 ( <code>new-branch-name</code> ) 并将特定存储中的更改应用到该分支。这是切换到新分支并一步应用隐藏的更改的便捷方法。</p>
<h3 id="discarding-a-stash">Discarding a stash</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git stash drop stash@<span style="color:#f92672">{</span>n<span style="color:#f92672">}</span>
</span></span></code></pre></div><p>此命令从存储列表中删除特定存储，而不应用其更改。</p>
<p>当我们正在处理某件事但需要切换到不同的任务或分支时，Git stash 非常有用。它允许我们暂时保存更改、切换上下文，然后返回到保存的状态以继续我们上次中断的地方。</p>
<h2 id="7-git-fetch-和-git-pull-有什么区别">7. ‘git fetch’ 和 ‘git pull’ 有什么区别？</h2>
<p><code>git fetch</code> 和 <code>git pull</code> 都用于从远程存储库获取更改并将其合并到本地存储库中。然而，它们在处理获取的更改和更新本地分支的方式上有所不同。</p>
<p>以下是 <code>git fetch</code> 和 <code>git pull</code> 之间的主要区别：</p>
<h3 id="git-fetch-git-获取">git fetch git 获取</h3>
<ul>
<li>从远程存储库检索最新更改，包括新分支、提交和标签，而不自动将它们合并到当前分支中。</li>
<li>更新远程跟踪分支（例如 <code>origin/master</code> ）以反映远程存储库的状态。</li>
<li>不修改您的本地分支或工作目录。</li>
<li>允许我们在手动合并之前检查和审查获取的更改，从而提供决定如何集成更改的机会。</li>
</ul>
<p>要从远程存储库获取最新更改，我们使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git fetch origin
</span></span></code></pre></div><h3 id="git-pull">git pull</h3>
<ul>
<li>执行 <code>git fetch</code> ，然后将获取的更改自动合并到当前分支中。</li>
<li>更新远程跟踪分支和本地分支，合并获取的更改。</li>
<li>如果当前分支有本地修改， <code>git pull</code> 会尝试自动合并更改。如果存在冲突，则需要手动解决。</li>
<li>自动更新您的工作目录以反映合并的更改。</li>
</ul>
<p>要从远程存储库中提取最新更改，我们使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git pull
</span></span></code></pre></div><p><code>git fetch</code> 和 <code>git pull</code> 之间的选择取决于我们的工作流程以及我们想要对集成更改进行控制的级别。</p>
<ul>
<li>如果我们想在合并之前查看更改并对集成过程有更多的控制， <code>git fetch</code> 是合适的。</li>
<li>如果我们更喜欢更自动化的方法并且对自动合并更改有信心， <code>git pull</code> 可能会更方便。</li>
</ul>
<h2 id="8-解释一下-git-checkoutrebase-和-merge">8. 解释一下 Git checkout、rebase 和 merge？</h2>
<p>这是 Git 中的三个重要命令，用于管理分支并将更改从一个分支合并到另一个分支。</p>
<table>
  <thead>
      <tr>
          <th>git 命令</th>
          <th>目的</th>
          <th>常见用例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>checkout</td>
          <td>切换到不同的分支或提交，使其成为当前工作分支/提交。</td>
          <td>– 分支的创建和切换 - 检查特定提交以进行检查或测试</td>
      </tr>
      <tr>
          <td>rebase</td>
          <td>将更改从一个分支重新应用到另一分支。通常用于维护线性提交历史记录。</td>
          <td>– 将功能分支集成到主分支中 – 维护干净、线性的提交历史记录</td>
      </tr>
      <tr>
          <td>merge</td>
          <td>将一个分支的更改合并到另一个分支。保留提交，创建合并提交。</td>
          <td>– 将功能分支集成到主分支中 – 合并多个贡献者的更改</td>
      </tr>
  </tbody>
</table>
<p>让我们逐一解释一下：</p>
<h3 id="git-checkout">git checkout</h3>
<p><code>git checkout</code> 用于在项目的不同分支或版本之间切换。</p>
<p>要切换到另一个分支，我们使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git checkout &lt;branch-name&gt;
</span></span></code></pre></div><ul>
<li>当您运行 <code>git checkout &lt;branch-name&gt;</code> 时，它会更新您的工作目录以匹配指定分支的内容。</li>
<li>您还可以使用 <code>git checkout</code> 切换到特定的提交或标记，从而允许您查看历史记录中特定状态的项目。</li>
<li>此外， <code>git checkout -b &lt;new-branch-name&gt;</code> 创建一个新分支并在单个命令中切换到它。</li>
</ul>
<h3 id="git-rebase">git rebase</h3>
<p><code>git rebase</code> 用于将一个分支的更改集成到另一个分支，通常用于将功能分支的更改合并到主分支中。</p>
<p>假设我们有两个分支：源分支（我们称之为“feature”）和目标分支（通常是“master”或“main”）。 “feature”分支包含一些更改，我们希望将这些更改合并到“master”分支中。但是，我们不想执行标准合并，因为我们想维护线性提交历史记录。</p>
<p>首先，您需要确保您位于目标分支（git checkout master）。在这种情况下，它将是 master，然后，启动 rebase 命令，指定要 rebase 到当前分支（目标分支）的源分支。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git rebase feature
</span></span></code></pre></div><ul>
<li>当您运行 <code>git rebase &lt;target-branch&gt;</code> 时，Git 会识别当前分支和目标分支的共同祖先，然后将当前分支的提交重新应用到目标分支之上。</li>
<li>Rebase 通过按顺序放置提交来允许线性历史记录，使其看起来好像更改是直接在目标分支之上进行的。</li>
<li>这可以帮助维护干净的提交历史记录，特别是在处理长期存在的功能分支时。</li>
</ul>
<h3 id="git-merge">git merge</h3>
<p><code>git merge</code> 将不同分支的更改合并到当前分支中。</p>
<p>要将分支的更改合并到目标分支，我们使用以下命令（在 git checkout 之后）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git merge &lt;source-branch&gt;
</span></span></code></pre></div><ul>
<li>当您运行 <code>git merge &lt;source-branch&gt;</code> 时，Git 会创建一个新的提交，将源分支中的更改合并到当前分支中。</li>
<li>合并提交保留了两个分支的历史记录，包括它们分歧的点。</li>
<li>默认情况下，如果可能，Git 会执行“快进”合并，这意味着它将当前分支指针向前移动到源分支的提交，而不创建额外的合并提交。</li>
<li>但是，如果由于不同的更改而无法进行快进合并，Git 会执行“递归”或“非快进”合并，创建一个新的合并提交。</li>
</ul>
<h2 id="9-gitcherry-pick命令的用途是什么">9. “gitcherry-pick”命令的用途是什么？</h2>
<p>“gitcherry-pick”命令用于将特定提交从一个分支应用到另一个分支。它允许我们选择单独的提交并将它们应用到不同的分支，将它们的更改合并到目标分支中。</p>
<p>以下是我们如何使用 <code>git cherry-pick</code> 命令：</p>
<ul>
<li>识别提交：确定要应用于另一个分支的提交。您可以找到提交哈希或使用其他 Git 命令（例如 <code>git log</code> 或 <code>gitk</code> ）来可视化提交历史记录。</li>
<li>切换到目标分支：确保您位于要应用所选提交的分支上。您可以使用 <code>git checkout</code> 切换到目标分支。</li>
<li>运行 <code>git cherry-pick</code> ：执行 <code>git cherry-pick</code> 命令，后跟要应用的提交的提交哈希值。例如：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git cherry-pick &lt;commit-hash&gt;
</span></span></code></pre></div><p>需要注意的是， <code>git cherry-pick</code> 会复制选定的提交并将它们作为新提交应用到目标分支上。这意味着新提交将具有不同的提交哈希值，因为它们是单独的副本，而不是原始提交的直接传输。</p>
<h2 id="10-解释-git-重置和恢复">10. 解释 Git 重置和恢复</h2>
<p>在 Git 中，重置和恢复是撤消更改的两种不同方法。它们用于纠正错误、撤消提交或将存储库恢复到以前的状态。</p>
<table>
  <thead>
      <tr>
          <th>Action</th>
          <th>Git Reset</th>
          <th>Git Revert</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>目的</td>
          <td>将 HEAD 和分支指针移动到指定的提交。</td>
          <td>创建一个新的提交来撤消特定提交所做的更改。</td>
      </tr>
      <tr>
          <td>常见用例</td>
          <td>– 在推送到远程存储库之前在本地撤消提交 – 重组提交历史 – 从暂存区删除更改</td>
          <td>– 安全撤消提交而不更改提交历史记录 – 协作代码修正</td>
      </tr>
  </tbody>
</table>
<h3 id="git-reset">git reset</h3>
<p><code>git reset</code> 将当前分支指针移动到特定提交，从而有效地将分支重置为该提交。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#Let&#39;s say we have a commit history like this: A - B - C - D (master)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#To Perform a hard reset to move the branch pointer to commit B, discarding changes in C and D.</span>
</span></span><span style="display:flex;"><span>git reset --hard B
</span></span></code></pre></div><p>复位命令有三种模式：软复位、混合复位和硬复位。</p>
<ul>
<li>软重置 ( <code>git reset --soft</code> ) 将分支指针移动到指定的提交，同时保持暂存区域和工作目录中的更改不变。它允许您“撤消”提交并根据先前的状态进行其他修改。</li>
<li>混合重置（默认行为， <code>git reset --mixed</code> ）将分支指针移动到指定的提交，重置暂存区域，但保留工作目录中的更改。它“取消暂存”更改，允许您在提交之前修改并再次暂存它们。</li>
<li>硬重置 ( <code>git reset --hard</code> ) 将分支指针移动到指定的提交，丢弃暂存区域和工作目录中的任何更改。它完全删除更改，将分支和整个存储库恢复到指定提交的状态。</li>
</ul>
<h3 id="git-revert">git revert</h3>
<p><code>git revert</code> 创建一个新的提交，撤消先前提交中所做的更改。它提供了一种安全的方式来撤消提交而不更改提交历史记录。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git revert C  <span style="color:#75715e"># This command will Create a new commit that undoes the changes in commit C.</span>
</span></span></code></pre></div><p><code>git revert</code> 创建新的提交来反转指定提交引入的更改，而不是修改或删除现有提交。每个恢复提交都专门用于撤消特定提交的更改，确保提交历史记录保持完整。</p>
<h2 id="11gitignore文件的用途是什么">11.“.gitignore”文件的用途是什么？</h2>
<p><code>.gitignore</code> 文件指定不应提交到存储库的有意未跟踪的文件和目录。它允许我们定义 Git 在跟踪更改和暂存文件时应忽略的文件和目录名称模式。</p>
<p>使用“.gitignore”文件的一些常见用例和好处包括：</p>
<ul>
<li>忽略构建工件，例如编译的二进制文件、目标文件、日志文件或临时文件。</li>
<li>忽略单独管理的依赖项或库。在存储库中包含这些依赖项是不必要的，并且可能会导致存储库臃肿。</li>
<li>忽略包含 API 密钥、数据库凭据或特定于环境的设置等敏感信息的配置文件。</li>
<li>忽略与其他团队成员无关的个人开发环境文件，例如项目设置、编辑器备份文件或缓存文件。</li>
</ul>
<p>以下是包含 3 个条目的 <code>.gitignore</code> 文件的示例：</p>
<pre tabindex="0"><code># Ignore build artifacts
*.exe
*.o
*.log

# Ignore dependency directories
/node_modules
/vendor

# Ignore sensitive configuration files
config.ini
secrets.json
</code></pre><h2 id="12-git-reflog-和-log-有什么区别">12. Git reflog 和 log 有什么区别？</h2>
<p><code>git log</code> 主要用于查看特定分支或提交的提交历史记录，而 <code>git reflog</code> 更专注于跟踪整个存储库中的引用移动，这使得它对于恢复和提交特别有用。调试目的。</p>
<table>
  <thead>
      <tr>
          <th>方面</th>
          <th><code>git log</code></th>
          <th><code>git reflog</code></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>目的</td>
          <td>显示分支的提交历史记录。</td>
          <td>显示存储库的参考日志。</td>
      </tr>
      <tr>
          <td>常见用例</td>
          <td>– 回顾项目历史 –检查提交消息和随时间所做的更改。</td>
          <td>–恢复丢失的提交或分支 – 调试和了解存储库中的更改。</td>
      </tr>
  </tbody>
</table>
<h3 id="git-log">git log</h3>
<p><code>git log</code> 命令提供存储库中按时间顺序提交的列表，显示提交哈希、作者、日期和提交消息等详细信息。默认情况下，它显示当前分支的提交历史记录，从最近的提交开始并按时间倒退。各种选项和标志允许自定义，例如按作者、日期范围或分支进行过滤。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># To see the commit history for the current branch</span>
</span></span><span style="display:flex;"><span>git log
</span></span></code></pre></div><p>要以紧凑的一行格式显示提交历史记录，我们使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git log --oneline
</span></span></code></pre></div><p><img src="../../../static/images/git-interview-questions-05.webp" alt="img"></p>
<h3 id="git-reflog">git reflog</h3>
<p>另一方面， <code>git reflog</code> 给出了引用（分支或标签）更新和修改提交指针的其他操作的详细日志。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># To view the reflog for the repository</span>
</span></span><span style="display:flex;"><span>git reflog
</span></span></code></pre></div><p><img src="../../../static/images/git-interview-questions-06.webp" alt="img"></p>
<p>与 <code>git log</code> 不同，引用日志记录影响提交历史记录的分支移动和操作，即使不创建新的提交也是如此。它是恢复丢失的提交或可能被意外删除或移动的分支的宝贵工具，在发生错误或不可预见的事件时充当安全网。</p>
<h2 id="13git-bisect命令的用途是什么">13.“git bisect”命令的用途是什么？</h2>
<p><code>git bisect</code> 命令通过提交历史记录执行二分搜索，以识别引入错误或导致回归的特定提交。它通过有效地缩小要调查的提交范围，有助于隔离和查明负责特定问题的提交。</p>
<p>以下是 <code>git bisect</code> 工作原理的概述：</p>
<ul>
<li>识别已知的好的和坏的提交：首先识别项目历史记录中的两个提交：一个代表已知的良好状态（不存在错误或问题的提交），另一个代表已知的坏状态（不存在 bug 或问题的提交）存在错误或问题）。</li>
<li>开始二等分过程：使用 <code>git bisect start</code> 开始二等分过程。使用 <code>git bisect good &lt;commit&gt;</code> 指定已知良好状态的提交哈希，使用 <code>git bisect bad &lt;commit&gt;</code> 指定已知不良状态的提交哈希。 Git 将在已知的好状态和坏状态之间创建一系列提交。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git bisect start
</span></span><span style="display:flex;"><span>git bisect good &lt;good_commit_hash&gt;
</span></span><span style="display:flex;"><span>git bisect bad &lt;bad_commit_hash&gt;
</span></span></code></pre></div><h2 id="14-我们如何在-git-中将多个提交压缩为单个提交">14. 我们如何在 Git 中将多个提交压缩为单个提交？</h2>
<p>为了在 Git 中将多个提交压缩为单个提交，我们可以使用交互式变基功能。确保我们位于包含我们想要压缩的提交的分支上。</p>
<p>运行以下命令启动交互式变基：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git rebase -i HEAD~n
</span></span></code></pre></div><p>将 <code>n</code> 替换为我们想要压缩的提交数。例如，如果我们想压缩最后 3 次提交，请使用 <code>HEAD~3</code> 。</p>
<p>将打开一个交互式文本编辑器，显示我们在上一步中指定的提交列表。每个提交前面都会有“pick”一词。</p>
<p><img src="../../../static/images/git-interview-questions-07.webp" alt="img"></p>
<p>要压缩提交，请将除第一个提交之外的所有提交的“pick”更改为“squash”（或“s”）。将第一个提交保留为“pick”，因为它将是生成的提交消息。如果需要，您还可以通过移动文本编辑器中的行来重新排列提交的顺序。</p>
<p><img src="../../../static/images/git-interview-questions-08.webp" alt="img"></p>
<ul>
<li>保存并退出文本编辑器。</li>
<li>将打开另一个文本编辑器，允许您修改提交消息。您可以合并压缩提交的提交消息或写入新消息。根据需要编辑消息，保存并退出编辑器。</li>
<li>Git 将执行变基，将提交压缩为单个提交。</li>
<li>如果变基成功，您将看到一条消息，表明变基已完成。</li>
<li>如果存在任何冲突，Git 将停止 rebase 过程并允许我们解决它们。解决冲突后，使用 <code>git rebase --continue</code> 继续变基过程。</li>
<li>如有必要，将更改推送到远程存储库。</li>
</ul>
<p>警告：压缩提交时要小心，因为它会重写历史。如果提交已经被推送到共享存储库并且其他人已经基于这些提交进行了工作，通常不建议压缩它们，因为这可能会导致其他团队成员发生冲突。</p>
<h2 id="15如何判断某个分支是否已经合并到-master-中">15、如何判断某个分支是否已经合并到 Master 中？</h2>
<p>要识别某个分支是否已合并到 Git 中的 <code>master</code> 分支中，我们可以运行以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git checkout master
</span></span></code></pre></div><p>然后运行以下命令，将 <code>&lt;branch_name&gt;</code> 替换为我们要检查的分支名称：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git branch --merged &lt;branch_name&gt;
</span></span></code></pre></div><ul>
<li>如果分支已合并到 <code>master</code> 中，它将出现在运行此命令后显示的分支列表中。</li>
<li>如果分支尚未合并到 <code>master</code> 中，它将不会出现在合并分支列表中。</li>
</ul>
<p>或者，我们可以使用以下命令来查看合并分支的简明视图：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git branch --merged
</span></span></code></pre></div><p>此命令将列出已合并到当前分支的所有分支，在本例中为 <code>master</code> 。</p>
<h2 id="16-什么是-git-存储库如何初始化-git-存储库">16. 什么是 Git 存储库？如何初始化 Git 存储库？</h2>
<p>Git 存储库是 Git 跟踪和管理一组文件和目录更改的存储位置。它包含对文件所做的所有更改的完整历史记录，使我们能够跟踪和恢复更改、与其他人协作以及维护项目的不同版本。</p>
<p>要初始化目录中的 Git 存储库，我们可以使用 <code>git init</code> 命令。我们是这样做的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cd /path/to/your/local-repo-path
</span></span><span style="display:flex;"><span>git init
</span></span></code></pre></div><p>此命令在当前目录中初始化一个空的 Git 存储库。 Git 创建一个隐藏的 <code>.git</code> 目录，其中存储所有存储库数据，包括提交历史记录和配置。</p>
<h2 id="17-如何显示版本库的当前状态包括修改的文件和分支信息">17. 如何显示版本库的当前状态，包括修改的文件和分支信息？</h2>
<p>要显示存储库的当前状态，包括修改的文件和分支信息，我们可以使用 <code>git status</code> 命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git status
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Sample Output</span>
</span></span><span style="display:flex;"><span>Changes not staged <span style="color:#66d9ef">for</span> commit:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add &lt;file&gt;...&#34;</span> to update what will be committed<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore &lt;file&gt;...&#34;</span> to discard changes in working directory<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        modified:   spring-boot-actuator-example/pom.xml
</span></span><span style="display:flex;"><span>        modified:   spring-boot-actuator-example/src/main/java/com/howtodoinjava/demo/SimpleRestController.java
</span></span><span style="display:flex;"><span>        modified:   spring-boot-actuator-example/src/main/resources/application.properties
</span></span><span style="display:flex;"><span>        modified:   spring-webflux-demo/src/test/java/com/howtodoinjava/demo/EmployeeControllerTest.java
</span></span><span style="display:flex;"><span>no changes added to commit <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add&#34;</span> and/or <span style="color:#e6db74">&#34;git commit -a&#34;</span><span style="color:#f92672">)</span>
</span></span></code></pre></div><p>此命令将显示我们的存储库当前状态的摘要。它将向我们显示以下信息：</p>
<ul>
<li>我们当前所在的分支。</li>
<li>未跟踪的文件（Git 当前未跟踪的文件）。</li>
<li>已修改的文件（已修改但未暂存的文件）。</li>
<li>暂存文件（已修改并暂存以供下一次提交的文件）。</li>
<li>分支状态（例如，“您的分支已更新为‘origin/master’”）。</li>
</ul>
<h2 id="18-如何连接本地仓库到远程仓库">18. 如何连接本地仓库到远程仓库？</h2>
<p>要将本地存储库连接到远程存储库，我们需要将远程 URL 添加到本地 Git 存储库。此远程 URL 指向我们要存储和同步代码的远程存储库的位置（例如，在 GitHub、GitLab 或 Bitbucket 上）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git remote add origin &lt;remote_url&gt;
</span></span></code></pre></div><p>此命令添加一个名为“origin”的远程（如果愿意，我们可以选择不同的名称）并将其与指定的远程 URL 关联。</p>
<h2 id="19-如何列出已有的分行如何创建新分支">19. 如何列出已有的分行？如何创建新分支？</h2>
<p>要列出现有分支，我们可以使用“gitbranch”命令。它显示存储库中所有分支的列表，并突出显示当前分支。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git branch
</span></span></code></pre></div><p>要创建新分支，我们可以使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git branch &lt;branch-name&gt;
</span></span></code></pre></div><h2 id="20-如何切换到特定分支">20. 如何切换到特定分支？</h2>
<p>我们可以使用以下命令切换到特定分支：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span> git checkout &lt;branch-name&gt;
</span></span></code></pre></div><h2 id="21-如何将不同分支的更改合并到当前分支">21. 如何将不同分支的更改合并到当前分支？</h2>
<p>确保我们位于要合并更改的分支（例如 main 分支）后，使用 merge 命令将指定分支的更改合并到当前分支。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git checkout &lt; main-branch &gt;
</span></span><span style="display:flex;"><span>git merge &lt;branch-name&gt;
</span></span></code></pre></div><h2 id="22如何删除-git-中的分支">22.如何删除 Git 中的分支？</h2>
<p>要删除分支，我们可以传递 <code>-d</code> 标志。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span> git branch -d &lt;branch-name&gt;
</span></span></code></pre></div><h2 id="23-如何将文件添加到暂存区">23. 如何将文件添加到暂存区？</h2>
<p>要将文件添加到暂存区，我们使用 git add 命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git add &lt;file&gt;
</span></span></code></pre></div><p>为了轻松地将所有文件添加到暂存区域，我们可以使用“.”。而不是特定的文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git add .
</span></span></code></pre></div><h2 id="24-如何使用描述性消息在暂存区提交更改">24. 如何使用描述性消息在暂存区提交更改？</h2>
<p>将文件添加到暂存区域后，我们可以使用以下命令提交更改：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git commit -m <span style="color:#e6db74">&#34;message&#34;</span>.
</span></span></code></pre></div><p>将“消息”替换为总结更改的描述性消息。</p>
<h2 id="25-如何将提交的更改推送到远程存储库">25. 如何将提交的更改推送到远程存储库？</h2>
<p>要将提交的更改推送到远程存储库，我们使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git push &lt;remote-name&gt; &lt;branch-name&gt;
</span></span></code></pre></div><h2 id="26-如何撤消-git-中的最后一次提交">26. 如何撤消 Git 中的最后一次提交？</h2>
<p>要撤消最后一次提交，同时将更改保留为未提交的修改，我们可以使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git reset HEAD~1
</span></span></code></pre></div><p>这会将 HEAD 指针向后移动一次提交。更改仍将在您的工作目录中，允许我们修改它们或进行新的提交。</p>
<h2 id="27-什么是合并冲突如何解决">27. 什么是合并冲突，如何解决？</h2>
<p>当 Git 由于同一行代码上的修改冲突而无法自动合并来自不同分支的更改时，就会发生合并冲突。</p>
<p>要解决合并冲突，我们需要手动编辑冲突文件，以选择所需的更改。解决冲突后，我们可以添加并提交更改以完成合并。</p>
<h2 id="28-如何从远程存储库中提取更改">28. 如何从远程存储库中提取更改？</h2>
<p>要从 Git 中的远程存储库提取更改，我们可以使用 <code>git pull</code> 命令。 <code>git pull</code> 命令从远程存储库获取最新更改并将它们合并到我们的本地分支中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git pull origin &lt;branch-name&gt;
</span></span></code></pre></div><p>例如，如果我们想从 <code>master</code> 分支中提取更改，我们可以使用 <code>git pull origin master</code> 。如果我们克隆存储库，默认远程名称通常为 <code>origin</code> ，但如果您自定义它，它可能会有所不同。</p>
<p>如果有任何冲突，Git 会通知我们，我们需要手动解决冲突。如果合并成功，我们的本地分支将使用远程存储库中的最新更改进行更新。</p>
<p>在拉取更改之前，建议提交或存储本地更改以避免冲突。如果您有未提交的更改，Git 可能会拒绝拉取，直到您提交或存储它们。</p>
<h2 id="29-如何显示两次提交之间的差异">29. 如何显示两次提交之间的差异？</h2>
<p>要显示两个 Git 提交之间的差异，可以使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span> git diff &lt;commit1&gt; &lt;commit2&gt;
</span></span></code></pre></div><h2 id="30-如何在-git-中恢复提交">30. 如何在 Git 中恢复提交？</h2>
<p>要恢复提交并创建一个撤消更改的新提交，我们可以使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span> git revert &lt;commit-hash&gt;
</span></span></code></pre></div><p>将 替换为您要恢复的提交哈希。 Git 将创建一个新的提交来撤消在指定提交中所做的更改。</p>
<h2 id="31如何查看-git-中的提交历史记录">31.如何查看 Git 中的提交历史记录？</h2>
<p>Git 中的每个分支都维护自己的提交历史记录。要访问和查看与特定分支关联的提交，我们可以使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span> git log branch-name
</span></span></code></pre></div><p>以下是使用“git log”的不同场景：</p>
<ul>
<li>不指定分支名称：“git log”显示当前签出的分支的提交历史记录。如果没有签出分支，它会显示整个存储库的提交历史记录。</li>
<li>使用特定分支名称：“git log ”显示指定分支的提交历史记录，包括其父分支共享的任何提交。</li>
</ul>
<h2 id="32-如何取消暂存文件">32. 如何取消暂存文件？</h2>
<p>要在 Git 中取消暂存文件，我们可以使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git reset HEAD -- path/to/file
</span></span></code></pre></div><p>与递归使用“git add”类似，您可以按目录取消暂存文件或执行批量取消暂存操作。要立即取消所有内容，请从存储库的根目录运行以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git reset HEAD -- .
</span></span></code></pre></div><h2 id="33-如何从远程存储库中删除文件">33. 如何从远程存储库中删除文件？</h2>
<p>要从远程存储库中删除文件，可以使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span> git rm &lt;file&gt;
</span></span></code></pre></div><p>这将从工作目录和 Git 存储库中删除该文件。删除文件后，您需要提交并推送更改以更新远程存储库。</p>
<h2 id="结论">结论</h2>
<p>总之，这份关于常见 Git 面试问题和答案的综合指南对 Git 版本控制系统中的基本概念和实践进行了彻底的探索。</p>
<p>通过深入研究存储库管理、分支、合并、解决冲突和协作工作流程等主题，您可以对 Git 的关键方面有深入的了解。</p>
<p>快乐学习！</p>
<p>原文链接：<a href="https://howtodoinjava.com/interview-questions/git-interview-questions/" target="_blank">Git Interview Questions for DevOps and Testers </a></p>

		</div>


	</article>
</main>
<footer class="post__footer">
	

<div class="post-related">
	<h3>相关文章</h3>
	<ul class="post-related-list">
		
		<li class="post-related-item">
			<a href="/posts/2023/10/12/spring-security-interview-questions/" target="_blank" title="[译]Spring Security 面试问题">[译]Spring Security 面试问题</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2023/09/19/spring-security-jwt/" target="_blank" title="[译]如何使用Spring Security和JWT保护您的REST API">[译]如何使用Spring Security和JWT保护您的REST API</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2023/08/25/exception-handling-for-rest-with-spring/" target="_blank" title="[译]使用Spring进行REST的错误处理">[译]使用Spring进行REST的错误处理</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2023/08/16/spring-security-with-jwt/" target="_blank" title="[译]Spring Security - JWT">[译]Spring Security - JWT</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2023/08/16/spring-security-form-login-with-database/" target="_blank" title="[译]Spring Security - 使用数据库表单登录">[译]Spring Security - 使用数据库表单登录</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2023/08/16/spring-security-form-login-remember-me-and-logout/" target="_blank" title="[译]Spring Security - 表单登录、记住我和注销">[译]Spring Security - 表单登录、记住我和注销</a>
		</li>
		
	</ul>
</div>

</footer>

<footer class="post__footer">
	<footer class="post__footer">
		
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/java/" rel="tag">java</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/javascript/" rel="tag">javascript</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/spring-boot/" rel="tag">spring-boot</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/backend/" rel="tag">backend</a>
		</li>
	</ul>
</div>
	</footer>
</footer>


<nav class="pagination flex">
	<div class="pagination__item pagination__item--prev">
		<a class="pagination__link" href="/posts/2023/10/12/spring-security-interview-questions/" rel="prev">
			<p class="pagination__title">«&thinsp;上一篇: [译]Spring Security 面试问题</p>
		</a>
	</div>
	<div class="pagination__item pagination__item--next">
		<a class="pagination__link" href="/posts/2023/10/13/new-features-in-spring-boot-3-and-spring-6/" rel="next">
			<p class="pagination__title">&thinsp;» 下一篇: [译]Spring Boot3和Spring6中的新特性</p>
		</a>
	</div>
</nav>



<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="ChenSoul avatar" src="/avatar.jpg" class="avatar" height="60" width="60" loading="lazy">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">关于 ChenSoul</span>
	</div>
	<div class="authorbox__description">
		一个来自中国武汉的开发者，主要撰写软件开发和开源方面的文章。浏览我的<a href="%28/posts%29">博客文章</a>，订阅我的 <a href="/index.xml">RSS</a> 源，或了解更多<a href="/about/">关于我</a>的信息。
	</div>
</div>




	<p><h3>欢迎留言！</h3></p>
<div id="remark42"></div>
<script>
	var remark_config = {
		host: 'https:\/\/comment.chensoul.cc',
		site_id: 'remark',
		components: ['embed'],
		url: 'https:\/\/blog.chensoul.cc\/posts\/2023\/10\/12\/git-interview-questions\/',
		locale: 'zh'
	};

	!function(e, n) {
		for (var o = 0; o < e.length; o++) {
			var r = n.createElement('script'),
			c = '.js',
			d = n.head || n.body;
			'noModule' in r ? (r.type = 'module', c = '.mjs') : r.async = !0, r.defer = !0, r.src = remark_config.host + '/web/' + e[o] + c, d.appendChild(r)
		}
	}(remark_config.components || ['embed'], document);

</script>





			</div>
			

<aside class="sidebar sidebar--right">
	<div class="post__toc toc">
		<div class="toc__title">目录</div>
		<div class="toc__menu">
			<nav id="TableOfContents">
  <ul>
    <li><a href="#1什么是版本控制系统">1.什么是版本控制系统？</a></li>
    <li><a href="#2-git-中的-origin-是什么">2. Git 中的 Origin 是什么？</a></li>
    <li><a href="#3我们如何在-git-中配置全局用户名和电子邮件">3.我们如何在 Git 中配置全局用户名和电子邮件？</a></li>
    <li><a href="#4-git-中的暂存区是什么意思">4. Git 中的“暂存区”是什么意思？</a></li>
    <li><a href="#5-git-中的分叉分支和克隆之间的区别">5. Git 中的分叉、分支和克隆之间的区别？</a>
      <ul>
        <li><a href="#分叉">分叉</a></li>
        <li><a href="#分枝">分枝</a></li>
        <li><a href="#克隆">克隆</a></li>
      </ul>
    </li>
    <li><a href="#6-什么是-git-stash">6. 什么是 Git Stash？</a>
      <ul>
        <li><a href="#creating-a-stash">Creating a stash</a></li>
        <li><a href="#viewing-stashes">Viewing stashes</a></li>
        <li><a href="#applying-a-stash">Applying a stash</a></li>
        <li><a href="#applying-and-removing-a-stash">Applying and removing a stash</a></li>
        <li><a href="#applying-a-stash-to-a-different-branch">Applying a stash to a different branch</a></li>
        <li><a href="#discarding-a-stash">Discarding a stash</a></li>
      </ul>
    </li>
    <li><a href="#7-git-fetch-和-git-pull-有什么区别">7. ‘git fetch’ 和 ‘git pull’ 有什么区别？</a>
      <ul>
        <li><a href="#git-fetch-git-获取">git fetch git 获取</a></li>
        <li><a href="#git-pull">git pull</a></li>
      </ul>
    </li>
    <li><a href="#8-解释一下-git-checkoutrebase-和-merge">8. 解释一下 Git checkout、rebase 和 merge？</a>
      <ul>
        <li><a href="#git-checkout">git checkout</a></li>
        <li><a href="#git-rebase">git rebase</a></li>
        <li><a href="#git-merge">git merge</a></li>
      </ul>
    </li>
    <li><a href="#9-gitcherry-pick命令的用途是什么">9. “gitcherry-pick”命令的用途是什么？</a></li>
    <li><a href="#10-解释-git-重置和恢复">10. 解释 Git 重置和恢复</a>
      <ul>
        <li><a href="#git-reset">git reset</a></li>
        <li><a href="#git-revert">git revert</a></li>
      </ul>
    </li>
    <li><a href="#11gitignore文件的用途是什么">11.“.gitignore”文件的用途是什么？</a></li>
    <li><a href="#12-git-reflog-和-log-有什么区别">12. Git reflog 和 log 有什么区别？</a>
      <ul>
        <li><a href="#git-log">git log</a></li>
        <li><a href="#git-reflog">git reflog</a></li>
      </ul>
    </li>
    <li><a href="#13git-bisect命令的用途是什么">13.“git bisect”命令的用途是什么？</a></li>
    <li><a href="#14-我们如何在-git-中将多个提交压缩为单个提交">14. 我们如何在 Git 中将多个提交压缩为单个提交？</a></li>
    <li><a href="#15如何判断某个分支是否已经合并到-master-中">15、如何判断某个分支是否已经合并到 Master 中？</a></li>
    <li><a href="#16-什么是-git-存储库如何初始化-git-存储库">16. 什么是 Git 存储库？如何初始化 Git 存储库？</a></li>
    <li><a href="#17-如何显示版本库的当前状态包括修改的文件和分支信息">17. 如何显示版本库的当前状态，包括修改的文件和分支信息？</a></li>
    <li><a href="#18-如何连接本地仓库到远程仓库">18. 如何连接本地仓库到远程仓库？</a></li>
    <li><a href="#19-如何列出已有的分行如何创建新分支">19. 如何列出已有的分行？如何创建新分支？</a></li>
    <li><a href="#20-如何切换到特定分支">20. 如何切换到特定分支？</a></li>
    <li><a href="#21-如何将不同分支的更改合并到当前分支">21. 如何将不同分支的更改合并到当前分支？</a></li>
    <li><a href="#22如何删除-git-中的分支">22.如何删除 Git 中的分支？</a></li>
    <li><a href="#23-如何将文件添加到暂存区">23. 如何将文件添加到暂存区？</a></li>
    <li><a href="#24-如何使用描述性消息在暂存区提交更改">24. 如何使用描述性消息在暂存区提交更改？</a></li>
    <li><a href="#25-如何将提交的更改推送到远程存储库">25. 如何将提交的更改推送到远程存储库？</a></li>
    <li><a href="#26-如何撤消-git-中的最后一次提交">26. 如何撤消 Git 中的最后一次提交？</a></li>
    <li><a href="#27-什么是合并冲突如何解决">27. 什么是合并冲突，如何解决？</a></li>
    <li><a href="#28-如何从远程存储库中提取更改">28. 如何从远程存储库中提取更改？</a></li>
    <li><a href="#29-如何显示两次提交之间的差异">29. 如何显示两次提交之间的差异？</a></li>
    <li><a href="#30-如何在-git-中恢复提交">30. 如何在 Git 中恢复提交？</a></li>
    <li><a href="#31如何查看-git-中的提交历史记录">31.如何查看 Git 中的提交历史记录？</a></li>
    <li><a href="#32-如何取消暂存文件">32. 如何取消暂存文件？</a></li>
    <li><a href="#33-如何从远程存储库中删除文件">33. 如何从远程存储库中删除文件？</a></li>
    <li><a href="#结论">结论</a></li>
  </ul>
</nav>
		</div>
	</div>
</aside>

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
<div class="footer__links">
	<a class="footer__link" href="/">首页</a> | <a class="footer__link" href="/categories/">分类</a> | <a class="footer__link" href="/tags/">标签</a> | <a class="footer__link" href="/index.xml">订阅</a> | <a class="footer__link" href="/about/">关于</a>
</div>
		<div class="footer__copyright">
			&copy; 2025 ChenSoul.
			<span class="footer__copyright-credits">基于 <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> 引擎和 <a href="https://github.com/chensoul/rose-hugo/" rel="nofollow noopener" target="_blank">Rose Hugo</a> 主题</span>
		</div>
	</div>

	






<style>
	.scroll-up a {
		display: block;
		height: 3.125rem;
		width: 3.125rem;
		text-align: center;
		line-height: 2.7;
		border-radius: 50px;
		font-size: 1.125rem;
		color: #fff;
		opacity: 1;
		transition: all 0.3s ease 0s;
		box-shadow: 0 0 10px rgb(0 0 0 / 20%);
	}
	.scroll-up a {
		background: #ee591f;
	}
	.scroll-up {
		position: fixed;
		display: none;
		bottom: 50px;
		z-index: 999;
	}
	.scroll-up.right {
		right: 60px;
	}
</style>

<div class="scroll-up custom right" style="display: block;"><a href="#top" id="top-link" accesskey="g"><i
	class="fa fa-arrow-up"></i></a></div>

<script>
	var mybutton = document.getElementById("top-link");
	window.onscroll = function () {
		if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
			mybutton.style.visibility = "visible";
			mybutton.style.opacity = "1";
		} else {
			mybutton.style.visibility = "hidden";
			mybutton.style.opacity = "0";
		}
	};
</script>


    <script defer src="https://umami.chensoul.cc/random-string.js" data-website-id="1e07d36d-bec3-4ba6-9459-876b1ac3bbe7"></script>
</footer>


	</div>

	<script>
		'use strict';
		(function iifeMenu(document, window, undefined) {
			var menuBtn = document.querySelector('.menu__btn');
			var	menu = document.querySelector('.menu__list');
			function toggleMenu() {
				menu.classList.toggle('menu__list--active');
				menu.classList.toggle('menu__list--transition');
				this.classList.toggle('menu__btn--active');
				this.setAttribute(
					'aria-expanded',
					this.getAttribute('aria-expanded') === 'true' ? 'false' : 'true'
				);
			}
			function removeMenuTransition() {
				this.classList.remove('menu__list--transition');
			}
			if (menuBtn && menu) {
				menuBtn.addEventListener('click', toggleMenu, false);
				menu.addEventListener('transitionend', removeMenuTransition, false);
			}
		}(document, window));
	</script>
</body>
</html>