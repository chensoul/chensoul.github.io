<!DOCTYPE html>
<html class="no-js" lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[译]深入了解Spring事务管理：@Transactional - Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="[译]深入了解Spring事务管理：@Transactional">
	<meta property="og:description" content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps">
	<meta property="og:type" content="article">
	<meta property="og:url" content="https://blog.chensoul.cc/posts/2023/08/16/spring-transaction-management-transactional-in-depth/">
	<meta property="og:site_name" content="ChenSoul Blog">
	<meta property="og:image" content="">
	
  <meta itemprop="name" content="[译]深入了解Spring事务管理：@Transactional">
  <meta itemprop="description" content="您可以使用本指南来简单实用地了解 Spring 使用 @Transactional 注释进行事务管理的工作原理。">
  <meta itemprop="datePublished" content="2023-08-16T00:00:00+00:00">
  <meta itemprop="dateModified" content="2023-08-16T00:00:00+00:00">
  <meta itemprop="wordCount" content="1292">
  <meta itemprop="keywords" content="Mysql,Java,Javascript,Backend">
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:title" content="[译]深入了解Spring事务管理：@Transactional">
	<meta name="twitter:description" content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps">
	<meta name="twitter:image" content="">

	<link rel="preconnect" href="//fonts.loli.net" crossorigin>
	<link rel="dns-prefetch" href="//fonts.loli.net">
	<link rel="stylesheet" href="https://fonts.loli.net/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css" integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
	<link rel="stylesheet" href="/css/style.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="ChenSoul Blog" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="/logo.svg" loading="lazy" alt="Site logo" width="60" height="60">
				</div><div class="logo__item logo__text">
					<div class="logo__title">ChenSoul Blog</div>
					<div class="logo__tagline">Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">菜单</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/">
				
				<span class="menu__text">首页</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/categories/">
				
				<span class="menu__text">分类</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/tags/">
				
				<span class="menu__text">标签</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/index.xml">
				
				<span class="menu__text">订阅</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">关于</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[译]深入了解Spring事务管理：@Transactional</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 1 1 0 28 1 1 0 0 1 0-28m0 3a3 3 0 1 0 0 22 3 3 0 0 0 0-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class="meta__text" datetime="2023-08-16">2023-08-16</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class="meta__text"><a class="meta__link" href="/categories/spring-boot/" rel="category">Spring-Boot</a>
	</span>
</div><div class="meta__item-tags meta__item"><svg class="meta__icon icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg><span class="meta__text"><a class="meta__link" href="/tags/mysql/" rel="tag">Mysql</a>, <a class="meta__link" href="/tags/java/" rel="tag">Java</a>, <a class="meta__link" href="/tags/javascript/" rel="tag">Javascript</a>, <a class="meta__link" href="/tags/backend/" rel="tag">Backend</a>
	</span>
</div>
</div>
		</header>
		
		<div class="content post__content clearfix">
			<p>您可以使用本指南来简单实用地了解 Spring 使用 @Transactional 注释进行事务管理的工作原理。</p>
<p>唯一的先决条件？您需要对 ACID 有一个粗略的了解，即什么是数据库事务以及为什么使用它们。此外，这里不讨论分布式事务或反应式事务，但就 Spring 而言，一般原则仍然适用。</p>
<h2 id="介绍">介绍</h2>
<p>在本指南中，您将了解 Spring 核心事务抽象框架的主要支柱（这是一个令人困惑的术语，不是吗？） - 用大量代码示例进行描述：</p>
<ul>
<li><code>@Transactional</code> （声明式事务管理）与编程式事务管理。</li>
<li>物理事务与逻辑事务。</li>
<li>Spring <code>@Transactional</code> 与 JPA/Hibernate 集成。</li>
<li>Spring <code>@Transactional</code> 与 Spring Boot 或 Spring MVC 集成。</li>
<li>回滚、代理、常见陷阱等等。</li>
</ul>
<p>与 Spring 官方文档相反，本指南不会直接深入探讨 Spring-first 主题，从而让您感到困惑。</p>
<p>相反，您将以非常规的方式学习 Spring 事务管理：从头开始，一步一步。这意味着，从普通的老式 JDBC 事务管理开始。</p>
<p>Why? 为什么？</p>
<p>因为 Spring 所做的一切都是基于这些 JDBC 基础知识。如果您掌握了这些基础知识，稍后您将可以使用 Spring 的 @Transactional 注释节省大量时间。</p>
<h2 id="普通-jdbc-事务管理的工作原理">普通 JDBC 事务管理的工作原理</h2>
<p>如果您在不完全了解 JDBC 事务的情况下考虑跳过本节：请不要这样做。</p>
<h3 id="如何启动提交或回滚-jdbc-事务">如何启动、提交或回滚 JDBC 事务</h3>
<p>第一个重要的收获是：无论您使用 Spring 的 @Transactional 注释、普通 Hibernate、jOOQ 还是任何其他数据库库，都没有关系。</p>
<p>最后，它们都执行相同的操作来打开和关闭（我们称之为“管理”）数据库事务。普通的 JDBC 事务管理代码如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.sql.Connection;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Connection connection <span style="color:#f92672">=</span> dataSource.<span style="color:#a6e22e">getConnection</span>(); <span style="color:#75715e">// (1)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> (connection) {
</span></span><span style="display:flex;"><span>    connection.<span style="color:#a6e22e">setAutoCommit</span>(<span style="color:#66d9ef">false</span>); <span style="color:#75715e">// (2)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// execute some SQL statements...</span>
</span></span><span style="display:flex;"><span>    connection.<span style="color:#a6e22e">commit</span>(); <span style="color:#75715e">// (3)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">catch</span> (SQLException e) {
</span></span><span style="display:flex;"><span>    connection.<span style="color:#a6e22e">rollback</span>(); <span style="color:#75715e">// (4)</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>您需要连接到数据库才能启动事务。 DriverManager.getConnection（url，user，password）也可以工作，尽管在大多数企业应用程序中，您将配置一个数据源并从中获取连接。</li>
<li>这是在 Java 中“启动”数据库事务的唯一方法，尽管这个名字听起来有点不对劲。 setAutoCommit(true) 确保每个 SQL 语句自动包装在自己的事务中，而 setAutoCommit(false) 则相反：您是事务的主人，您需要开始调用 <code>*commit*</code> 标志在连接打开的整个时间内都有效，这意味着您只需调用该方法一次，而不是重复。</li>
<li>让我们提交我们的交易&hellip;​</li>
<li>或者，如果出现异常，则回滚我们的更改。</li>
</ol>
<p>是的，这 4 行（过于简单化的）是当你使用 @Transactional 注释时 Spring 所做的一切。在下一章中，您将了解其工作原理。但在我们开始之前，您还需要学习一些知识。</p>
<p>（聪明人的一个快速说明：像 HikariCP 这样的连接池库可能会根据配置自动为您切换自动提交模式。但这是一个高级主题。）</p>
<h3 id="如何使用-jdbc-隔离级别和保存点">如何使用 JDBC 隔离级别和保存点</h3>
<p>如果您已经使用过 Spring 的 @Transactional 注释，您可能遇到过类似的情况：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Transactional</span>(propagation<span style="color:#f92672">=</span>TransactionDefinition.<span style="color:#a6e22e">NESTED</span>,
</span></span><span style="display:flex;"><span>               isolation<span style="color:#f92672">=</span>TransactionDefinition.<span style="color:#a6e22e">ISOLATION_READ_UNCOMMITTED</span>)
</span></span></code></pre></div><p>稍后我们将更详细地介绍嵌套 Spring 事务和隔离级别，但再次了解这些参数都可以归结为以下基本 JDBC 代码会有所帮助：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.sql.Connection;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// isolation=TransactionDefinition.ISOLATION_READ_UNCOMMITTED</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>connection.<span style="color:#a6e22e">setTransactionIsolation</span>(Connection.<span style="color:#a6e22e">TRANSACTION_READ_UNCOMMITTED</span>); <span style="color:#75715e">// (1)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// propagation=TransactionDefinition.NESTED</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Savepoint savePoint <span style="color:#f92672">=</span> connection.<span style="color:#a6e22e">setSavepoint</span>(); <span style="color:#75715e">// (2)</span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>connection.<span style="color:#a6e22e">rollback</span>(savePoint);
</span></span></code></pre></div><ol>
<li>这就是 Spring 在数据库连接上设置隔离级别的方式。不完全是火箭科学，是吗？</li>
<li>Spring 中的嵌套事务只是 JDBC/数据库保存点。例如，如果您不知道什么是保存点，请查看本<a href="https://docs.oracle.com/javase/tutorial/jdbc/basics/transactions.html" target="_blank">教程</a>。请注意，保存点支持取决于您的 JDBC 驱动程序/数据库。</li>
</ol>
<h2 id="spring-或-spring-boot-的事务管理如何工作">Spring 或 Spring Boot 的事务管理如何工作</h2>
<p>现在您已经对 JDBC 事务有了很好的了解，让我们看看简单的、核心的 Spring 是如何管理事务的。这里的所有内容都一一适用于 Spring Boot 和 Spring MVC，稍后会详细介绍。</p>
<p>Spring 的事务管理或其（名称相当令人困惑的）事务抽象框架实际上是什么？</p>
<p>请记住，事务管理简单地说就是：Spring 如何启动、提交或回滚 JDBC 事务？这听起来是不是很熟悉？</p>
<p>问题是：使用普通 JDBC，您只有一种方法 (setAutocommit(false)) 来管理事务，而 Spring 为您提供了许多不同的、更方便的方法来实现相同的目的。</p>
<h3 id="如何使用-spring-的程序化事务管理">如何使用 Spring 的程序化事务管理？</h3>
<p>在 Spring 中定义事务的第一种但很少使用的方法是通过编程方式：通过 TransactionTemplate 或直接通过 PlatformTransactionManager。从代码角度来看，它看起来像这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Service</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserService</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Autowired</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> TransactionTemplate template;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Long <span style="color:#a6e22e">registerUser</span>(User user) {
</span></span><span style="display:flex;"><span>        Long id <span style="color:#f92672">=</span> template.<span style="color:#a6e22e">execute</span>(status <span style="color:#f92672">-&gt;</span>  {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// execute some SQL that e.g.</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// inserts the user into the db and returns the autogenerated id</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> id;
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>与普通 JDBC 示例相比：</p>
<ul>
<li>您不必自己搞乱打开或关闭数据库连接（try-finally）。相反，您使用事务回调。</li>
<li>您也不必捕获 SQLException，因为 Spring 会为您将这些异常转换为运行时异常。</li>
<li>并且您可以更好地融入 Spring 生态系统。 TransactionTemplate 将在内部使用 TransactionManager，它将使用数据源。所有这些都是您必须在 Spring 上下文配置中指定的 bean，但以后不必再担心。</li>
</ul>
<p>虽然这算是一个小小的改进，但程序化事务管理并不是 Spring 事务框架的主要功能。相反，这都是关于声明式事务管理的。让我们看看那是什么。</p>
<h3 id="如何使用-spring-的-xml-声明式事务管理">如何使用 Spring 的 XML 声明式事务管理？</h3>
<p>过去，当 XML 配置成为 Spring 项目的标准时，您可以直接在 XML 中配置事务。除了一些遗留的企业项目之外，您将不再在野外找到这种方法，因为它已被更简单的 @Transactional 注释所取代。</p>
<p>我们不会在本指南中详细介绍 XML 配置，但您可以使用此示例作为深入研究的起点 - 如果需要的话（直接取自 Spring 官方文档）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#75715e">&lt;!-- the transactional advice (what &#39;happens&#39;; see the &lt;aop:advisor/&gt; bean below) --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;tx:advice</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;txAdvice&#34;</span> <span style="color:#a6e22e">transaction-manager=</span><span style="color:#e6db74">&#34;txManager&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">&lt;!-- the transactional semantics... --&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;tx:attributes&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">&lt;!-- all methods starting with &#39;get&#39; are read-only --&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;tx:method</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;get*&#34;</span> <span style="color:#a6e22e">read-only=</span><span style="color:#e6db74">&#34;true&#34;</span><span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">&lt;!-- other methods use the default transaction settings (see below) --&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;tx:method</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;*&#34;</span><span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;/tx:attributes&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;/tx:advice&gt;</span>
</span></span></code></pre></div><p>您使用上面的 XML 块指定 AOP 建议（面向方面 ​​ 的编程），然后可以将其应用到 UserService bean，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;aop:config&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;aop:pointcut</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;userServiceOperation&#34;</span> <span style="color:#a6e22e">expression=</span><span style="color:#e6db74">&#34;execution(* x.y.service.UserService.*(..))&#34;</span><span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;aop:advisor</span> <span style="color:#a6e22e">advice-ref=</span><span style="color:#e6db74">&#34;txAdvice&#34;</span> <span style="color:#a6e22e">pointcut-ref=</span><span style="color:#e6db74">&#34;userServiceOperation&#34;</span><span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/aop:config&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;userService&#34;</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;x.y.service.UserService&#34;</span><span style="color:#f92672">/&gt;</span>
</span></span></code></pre></div><p>您的 UserService bean 将如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserService</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Long <span style="color:#a6e22e">registerUser</span>(User user) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// execute some SQL that e.g.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// inserts the user into the db and retrieves the autogenerated id</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> id;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>从 Java 代码的角度来看，这种声明式事务方法看起来比编程方法简单得多。但它会导致大量复杂、冗长的 XML，以及切入点和顾问程序配置。</p>
<p>因此，这就引出了一个问题：是否有比 XML 更好的声明式事务管理方法？是的，有：@Transactional 注释。</p>
<h3 id="如何使用-spring-的transactional-注解声明式事务管理">如何使用 Spring 的@Transactional 注解（声明式事务管理）</h3>
<p>现在让我们看看现代 Spring 事务管理通常是什么样子的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserService</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Transactional</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Long <span style="color:#a6e22e">registerUser</span>(User user) {
</span></span><span style="display:flex;"><span>       <span style="color:#75715e">// execute some SQL that e.g.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// inserts the user into the db and retrieves the autogenerated id</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// userDao.save(user);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> id;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这怎么可能？不再需要 XML 配置，也不需要其他代码。相反，您现在需要做两件事：</p>
<ul>
<li>确保您的 Spring 配置带有 @EnableTransactionManagement 注释（在 Spring Boot 中，这将自动为您完成）。</li>
<li>确保您在 Spring 配置中指定了事务管理器（无论如何您都需要这样做）。</li>
<li>然后 Spring 足够智能，可以透明地为您处理事务：您用 @Transactional 注释注释的任何 bean 的公共方法都将在数据库事务内执行（注意：存在一些陷阱）。</li>
</ul>
<p>因此，要使 @Transactional 注释正常工作，您需要做的就是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Configuration</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@EnableTransactionManagement</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MySpringConfig</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Bean</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> PlatformTransactionManager <span style="color:#a6e22e">txManager</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> yourTxManager; <span style="color:#75715e">// more on that later</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在，当我说 Spring 透明地为您处理事务时。那个的真实意义是什么？</p>
<p>借助 JDBC 事务示例中的知识，上面的 @Transactional UserService 代码可以直接转换（简化）为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserService</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Long <span style="color:#a6e22e">registerUser</span>(User user) {
</span></span><span style="display:flex;"><span>        Connection connection <span style="color:#f92672">=</span> dataSource.<span style="color:#a6e22e">getConnection</span>(); <span style="color:#75715e">// (1)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> (connection) {
</span></span><span style="display:flex;"><span>            connection.<span style="color:#a6e22e">setAutoCommit</span>(<span style="color:#66d9ef">false</span>); <span style="color:#75715e">// (1)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// execute some SQL that e.g.</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// inserts the user into the db and retrieves the autogenerated id</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// userDao.save(user); &lt;(2)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            connection.<span style="color:#a6e22e">commit</span>(); <span style="color:#75715e">//(1)</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (SQLException e) {
</span></span><span style="display:flex;"><span>            connection.<span style="color:#a6e22e">rollback</span>(); <span style="color:#75715e">// (1)</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>这只是 JDBC 连接的标准打开和关闭。这就是 Spring 的事务注释自动为您做的事情，而无需您显式地编写它。</li>
<li>这是您自己的代码，通过 DAO 或类似的东西保存用户。</li>
</ol>
<p>这个例子可能看起来有点神奇，但是让我们看看 Spring 如何为您插入这个连接代码。</p>
<h3 id="cglib-和-jdk-代理---transactional-的幕后黑手">CGlib 和 JDK 代理 - @Transactional 的幕后黑手</h3>
<p>Spring 无法真正重写您的 Java 类，就像我上面所做的那样，以插入连接代码（除非您使用字节码编织等高级技术，但我们现在忽略它）。</p>
<p>你的 registerUser() 方法实际上只是调用 userDao.save(user) ，没有办法动态改变它。</p>
<p>但 Spring 有一个优势。它的核心是一个 IoC 容器。它为您实例化一个 UserService 并确保将该 UserService 自动装配到任何其他需要 UserService 的 bean 中。</p>
<p>现在，每当您在 bean 上使用 @Transactional 时，Spring 都会使用一个小技巧。它不仅实例化 UserService，而且还实例化该 UserService 的事务代理。</p>
<p>它在 Cglib 库的帮助下通过一种称为代理通过子类化的方法来实现这一点。还有其他构建代理的方法（例如动态 JDK 代理），但我们暂时就这样吧。</p>
<p>让我们看看这张图中代理的作用：</p>
<p><img src="../../../static/images/spring-transaction-management-01.webp" alt="document1"></p>
<p>从该图中可以看出，代理有一项工作。</p>
<ul>
<li>打开和关闭数据库连接/事务。</li>
<li>然后委托给真正的 UserService，即您编写的那个。</li>
<li>而其他 bean，例如 UserRestController，永远不会知道它们正在与代理通信，而不是与真实的事物通信。</li>
</ul>
<p><strong>快速考试</strong></p>
<p>看一下下面的源代码，告诉我 Spring 自动构造什么类型的 UserService，假设它带有 @Transactional 标记或具有 @Transactional 方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Configuration</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@EnableTransactionManagement</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyAppConfig</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Bean</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> UserService <span style="color:#a6e22e">userService</span>() {  <span style="color:#75715e">// (1)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> UserService();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>正确的。 Spring 在这里为您的 UserService 类构造一个动态 CGLib 代理，它可以为您打开和关闭数据库事务。您或任何其他 bean 甚至不会注意到它不是您的 UserService，而是包装您的 UserService 的代理。</li>
</ol>
<h3 id="为什么需要事务管理器如-platformtransactionmanager">为什么需要事务管理器（如 PlatformTransactionManager）？</h3>
<p>现在只缺少一条关键信息，尽管我们已经提到过几次了。</p>
<p>您的 UserService 会动态被代理，并且代理会为您管理事务。但处理所有事务状态（打开、提交、关闭）的不是代理本身，而是代理委托给事务管理器。</p>
<p>Spring 为您提供了 PlatformTransactionManager / TransactionManager 接口，默认情况下，它附带了一些方便的实现。其中之一是数据源事务管理器。</p>
<p>它所做的正是您迄今为止所做的管理事务的操作，但首先，让我们看看所需的 Spring 配置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Bean</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> DataSource <span style="color:#a6e22e">dataSource</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> MysqlDataSource(); <span style="color:#75715e">// (1)</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Bean</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> PlatformTransactionManager <span style="color:#a6e22e">txManager</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> DataSourceTransactionManager(dataSource()); <span style="color:#75715e">// (2)</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>您可以在此处创建特定于数据库或特定于连接池的数据源。本示例使用 MySQL。</li>
<li>在这里，您创建事务管理器，它需要一个数据源才能管理事务。</li>
</ol>
<p>简单如。然后，所有事务管理器都有像“doBegin”（用于启动事务）或“doCommit”这样的方法，它们看起来像这样——直接取自 Spring 的源代码并进行了一些简化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DataSourceTransactionManager</span> <span style="color:#66d9ef">implements</span> PlatformTransactionManager {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doBegin</span>(Object transaction, TransactionDefinition definition) {
</span></span><span style="display:flex;"><span>        Connection newCon <span style="color:#f92672">=</span> obtainDataSource().<span style="color:#a6e22e">getConnection</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>        con.<span style="color:#a6e22e">setAutoCommit</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// yes, that&#39;s it!</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doCommit</span>(DefaultTransactionStatus status) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>        Connection connection <span style="color:#f92672">=</span> status.<span style="color:#a6e22e">getTransaction</span>().<span style="color:#a6e22e">getConnectionHolder</span>().<span style="color:#a6e22e">getConnection</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            con.<span style="color:#a6e22e">commit</span>();
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (SQLException ex) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> TransactionSystemException(<span style="color:#e6db74">&#34;Could not commit JDBC transaction&#34;</span>, ex);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因此，数据源事务管理器在管理事务时使用与您在 JDBC 部分中看到的完全相同的代码。</p>
<p>考虑到这一点，让我们从上面扩展我们的图片：</p>
<p><img src="../../../static/images/spring-transaction-management-02.webp" alt="document2"></p>
<p>总结一下：</p>
<ol>
<li>如果 Spring 检测到 bean 上的 @Transactional 注释，它会创建该 bean 的动态代理。</li>
<li>代理可以访问事务管理器，并要求它打开和关闭事务/连接。</li>
<li>事务管理器本身将简单地执行您在普通 Java 部分中所做的操作：管理良好的旧 JDBC 连接。</li>
</ol>
<h3 id="物理事务和逻辑事务有什么区别">物理事务和逻辑事务有什么区别？</h3>
<p>想象一下以下两个事务类。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Service</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserService</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Autowired</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> InvoiceService invoiceService;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Transactional</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">invoice</span>() {
</span></span><span style="display:flex;"><span>        invoiceService.<span style="color:#a6e22e">createPdf</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// send invoice as email, etc.</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Service</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InvoiceService</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Transactional</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">createPdf</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>UserService 有一个事务性 Invoice() 方法。它调用 InvoiceService 上的另一个事务方法 createPdf()。</p>
<p>现在就数据库事务而言，这实际上应该只是一个数据库事务。 （记住：getConnection().setAutocommit(false).commit()。）Spring 调用此物理事务，尽管一开始这听起来有点令人困惑。</p>
<p>然而，从 Spring 的角度来看，发生了两个逻辑事务：第一个在 UserService 中，另一个在 InvoiceService 中。 Spring 必须足够聪明，知道这两个 @Transactional 方法应该使用相同的底层物理数据库事务。</p>
<p>如果对 InvoiceService 进行以下更改，情况会有什么不同？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Service</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InvoiceService</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Transactional</span>(propagation <span style="color:#f92672">=</span> Propagation.<span style="color:#a6e22e">REQUIRES_NEW</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">createPdf</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>将传播模式更改为 require_new 是告诉 Spring createPDF() 需要在自己的事务中执行，独立于任何其他已存在的事务。回想一下本指南的纯 Java 部分，您是否看到了将事务“拆分”为两半的方法？我也不。</p>
<p>这基本上意味着您的代码将打开两个到数据库的（物理）连接/事务。 （再次：getConnection() x2.setAutocommit(false) x2.commit() x2）Spring 现在必须足够智能，两个逻辑事务部分 (invoice()/createPdf()) 现在也映射到两个不同的物理数据库交易。</p>
<p>所以，总结一下：</p>
<ul>
<li>物理事务：是您实际的 JDBC 事务。</li>
<li>逻辑事务：是（可能嵌套的）@Transactional 注解的（Spring）方法。</li>
</ul>
<p>这使我们能够更详细地介绍传播模式。</p>
<h3 id="transactional-传播级别的用途是什么">@Transactional 传播级别的用途是什么？</h3>
<p>查看 Spring 源代码时，您会发现可以插入 @Transactional 方法的各种传播级别或模式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>  <span style="color:#a6e22e">@Transactional</span>(propagation <span style="color:#f92672">=</span> Propagation.<span style="color:#a6e22e">REQUIRED</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// or</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@Transactional</span>(propagation <span style="color:#f92672">=</span> Propagation.<span style="color:#a6e22e">REQUIRES_NEW</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// etc</span>
</span></span></code></pre></div><p>完整列表：</p>
<ul>
<li>REQUIRED 必需的</li>
<li>SUPPORTS 支持</li>
<li>MANDATORY 强制的</li>
<li>REQUIRES_NEW REQUIRES_NEW</li>
<li>NOT_SUPPORTED 不支持</li>
<li>NEVER 绝不</li>
<li>NESTED 嵌套</li>
</ul>
<p><strong>练习：</strong></p>
<p>在普通 Java 部分中，我向您展示了 JDBC 在事务方面可以执行的所有操作。花点时间思考一下每个 Spring 传播模式最终对您的数据源（或者更确切地说，您的 JDBC 连接）到底做了什么。</p>
<p>那就看看下面的回答吧。</p>
<p><strong>答案：</strong></p>
<ul>
<li><strong>Required (default)</strong>：我的方法需要一个事务，要么为我打开一个事务，要么使用现有的事务 → getConnection()。设置自动提交（假）。犯罪（）。</li>
<li><strong>Supports</strong>：我并不关心事务是否打开，我可以以任何一种方式工作 → 与 JDBC 无关</li>
<li><strong>Mandatory</strong>：我自己不会打开一个事务，但是如果没有人打开一个事务我会哭 → 与 JDBC 无关</li>
<li><strong>Require_new</strong>：我想要完全自己的事务 → getConnection()。设置自动提交（假）。犯罪（）。</li>
<li><strong>Not_Supported</strong>：我真的不喜欢事务，我什至会尝试挂起当前正在运行的事务 → 与 JDBC 无关</li>
<li>**Never：**如果其他人启动事务我会哭 → 与 JDBC 无关</li>
<li><strong>Nested：</strong> 听起来很复杂，但我们只是在谈论保存点！ → 连接.setSavepoint()</li>
</ul>
<p>正如您所看到的，大多数传播模式实际上与数据库或 JDBC 无关，而更多地与您如何使用 Spring 构建程序以及 Spring 期望事务出现的方式/时间/地点有关。</p>
<p>看这个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserService</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">@Transactional</span>(propagation <span style="color:#f92672">=</span> Propagation.<span style="color:#a6e22e">MANDATORY</span>)
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">myMethod</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// execute some sql</span>
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在这种情况下，每当您调用 UserService 类的 myMethod() 时，Spring 都会期望打开一个事务。它本身不会打开一个方法，相反，如果您在没有预先存在的事务的情况下调用该方法，Spring 将抛出异常。请记住这一点，作为“逻辑事务处理”的附加点。</p>
<h3 id="transactional-隔离级别有什么用">@Transactional 隔离级别有什么用？</h3>
<p>此时这几乎是一个棘手的问题，但是当您像这样配置 @Transactional 注释时会发生什么？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Transactional</span>(isolation <span style="color:#f92672">=</span> Isolation.<span style="color:#a6e22e">REPEATABLE_READ</span>)
</span></span></code></pre></div><p>是的，它确实会导致这样的结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>connection.<span style="color:#a6e22e">setTransactionIsolation</span>(Connection.<span style="color:#a6e22e">TRANSACTION_REPEATABLE_READ</span>);
</span></span></code></pre></div><p>然而，数据库隔离级别是一个复杂的主题，您应该花一些时间来完全掌握它们。一个好的开始是 Postgres <a href="https://www.postgresql.org/docs/9.5/transaction-iso.html" target="_blank">官方文档</a>及其有关隔离级别的部分。</p>
<p>另请注意，在事务期间切换隔离级别时，您必须确保咨询 JDBC 驱动程序/数据库以了解支持哪些场景，哪些不支持。</p>
<h3 id="最常见的transactional-陷阱">最常见的@Transactional 陷阱</h3>
<p>Spring 初学者通常会遇到一个陷阱。看一下下面的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Service</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserService</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Transactional</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">invoice</span>() {
</span></span><span style="display:flex;"><span>        createPdf();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// send invoice as email, etc.</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Transactional</span>(propagation <span style="color:#f92672">=</span> Propagation.<span style="color:#a6e22e">REQUIRES_NEW</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">createPdf</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>您有一个带有事务发票方法的 UserService 类。它调用 createPDF()，这也是事务性的。</p>
<p>一旦有人调用 invoice()，您期望打开多少实际交易？</p>
<p>不，答案不是两个，而是一个。为什么？</p>
<p>让我们回到本指南的代理部分。 Spring 为您创建事务性 UserService 代理，但是一旦您进入 UserService 类并调用其他内部方法，就不再涉及代理。这意味着，您没有新的交易。</p>
<p>我们用一张图来看看：</p>
<p><img src="../../../static/images/spring-transaction-management-03.webp" alt="document3"></p>
<p>您可以使用一些技巧（例如自注入）来绕过此限制。但主要的要点是：始终牢记代理事务边界。</p>
<h3 id="如何在-spring-boot-或-spring-mvc-中使用-transactional">如何在 Spring Boot 或 Spring MVC 中使用 @Transactional</h3>
<p>到目前为止，我们只讨论了简单的、核心的 Spring。但是 Spring Boot 呢？还是 Spring Web MVC？他们处理交易的方式有什么不同吗？</p>
<p>最简洁的答案是不。</p>
<p>对于任一框架（或者更确切地说：Spring 生态系统中的所有框架），您将始终使用 <code>*@Transactional*</code> 注释，并结合事务管理器和 @EnableTransactionManagement 注释。没有其他办法。</p>
<p>然而，与 Spring Boot 的唯一区别是，它使用 JDBC 自动配置自动设置 <code>*@EnableTransactionManagement*</code> 注释并为您创建 <code>*PlatformTransactionManager*</code> 。在此处了解有关自动配置的更多信息。</p>
<h3 id="spring-如何处理回滚以及默认回滚策略">Spring 如何处理回滚（以及默认回滚策略）</h3>
<p>有关 Spring 回滚的部分将在本指南的下一版本中处理。</p>
<h2 id="spring-和-jpahibernate-事务管理如何工作">Spring 和 JPA/Hibernate 事务管理如何工作</h2>
<h3 id="目标同步-spring-的-transactional-和-hibernate--jpa">目标：同步 Spring 的 @Transactional 和 Hibernate / JPA</h3>
<p>在某些时候，您会希望 Spring 应用程序与另一个数据库库集成，例如 Hibernate（一种流行的 JPA 实现）或 Jooq 等。</p>
<p>让我们以普通 Hibernate 为例（注意：直接使用 Hibernate，或者通过 JPA 使用 Hibernate 并不重要）。</p>
<p>将之前的 UserService 重写为 Hibernate 如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserService</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Autowired</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> SessionFactory sessionFactory; <span style="color:#f92672">/</span> (1)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">registerUser</span>(User user) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Session session <span style="color:#f92672">=</span> sessionFactory.<span style="color:#a6e22e">openSession</span>(); <span style="color:#f92672">/</span> (2)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// lets open up a transaction. remember setAutocommit(false)!</span>
</span></span><span style="display:flex;"><span>        session.<span style="color:#a6e22e">beginTransaction</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// save == insert our objects</span>
</span></span><span style="display:flex;"><span>        session.<span style="color:#a6e22e">save</span>(user);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// and commit it</span>
</span></span><span style="display:flex;"><span>        session.<span style="color:#a6e22e">getTransaction</span>().<span style="color:#a6e22e">commit</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// close the session == our jdbc connection</span>
</span></span><span style="display:flex;"><span>        session.<span style="color:#a6e22e">close</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>这是一个普通的、旧的 Hibernate SessionFactory，是所有 Hibernate 查询的入口点。</li>
<li>使用 Hibernate API 手动管理会话（即：数据库连接）和事务。</li>
</ol>
<p>然而，上面的代码有一个很大的问题：</p>
<ul>
<li>Hibernate 不会知道 Spring 的 @Transactional 注释。</li>
<li>Spring 的 @Transactional 对 Hibernate 的事务一无所知。</li>
</ul>
<p>但我们实际上希望 Spring 和 Hibernate 能够无缝集成，这意味着它们了解彼此的事务。</p>
<p>用纯代码表示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Service</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserService</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Autowired</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> SessionFactory sessionFactory; <span style="color:#f92672">/</span> (1)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Transactional</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">registerUser</span>(User user) {
</span></span><span style="display:flex;"><span>        sessionFactory.<span style="color:#a6e22e">getCurrentSession</span>().<span style="color:#a6e22e">save</span>(user); <span style="color:#f92672">/</span> (2)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>与之前相同的 SessionFactory</li>
<li>但不再需要手动状态管理。相反， getCurrentSession() 和 @Transactional 是同步的。</li>
</ol>
<p>到那里怎么走？</p>
<h3 id="使用-hibernatetransactionmanager">使用 HibernateTransactionManager</h3>
<p>对于这个集成问题有一个非常简单的解决方法：</p>
<p>您将使用 HibernateTransactionManager（如果使用普通 Hibernate）或 JpaTransactionManager（如果通过 JPA 使用 Hibernate），而不是在 Spring 配置中使用 DataSourcePlatformTransactionManager。</p>
<p>专门的 HibernateTransactionManager 将确保：</p>
<ol>
<li>通过 Hibernate（即 SessionFactory）管理事务。</li>
<li>足够聪明，允许 Spring 在非 Hibernate 中使用相同的事务，即 @Transactional Spring 代码。</li>
</ol>
<p>与往常一样，图片可能更容易理解（但请注意，代理和实际服务之间的流程仅在概念上正确且过于简单）。</p>
<p><img src="../../../static/images/spring-transaction-management-04.webp" alt="document4"></p>
<p>简而言之，就是如何集成 Spring 和 Hibernate。</p>
<p>对于其他集成或更深入的理解，快速查看 Spring 提供的所有可能的 PlatformTransactionManager 实现会有所帮助。</p>
<h2 id="fin">Fin</h2>
<p>到目前为止，您应该对事务管理如何与 Spring 框架配合使用以及它如何应用于其他 Spring 库（如 Spring Boot 或 Spring WebMVC）有一个很好的概述。最大的收获应该是，最终使用哪个框架并不重要，这都与 JDBC 基础知识有关。</p>
<p>如果它们正确（记住：getConnection().setAutocommit(false).commit().），您将更容易理解稍后在复杂的企业应用程序中发生的情况。</p>
<p>谢谢阅读。</p>
<h2 id="致谢">致谢</h2>
<p>感谢 Andreas Eisele 对本指南早期版本的反馈。感谢 Ben Horsfield 提供了急需的 Javascript 片段来增强本指南。</p>
<p>原文链接：<a href="https://www.marcobehler.com/guides/spring-transaction-management-transactional-in-depth" target="_blank">https://www.marcobehler.com/guides/spring-transaction-management-transactional-in-depth</a></p>

		</div>


	</article>
</main>
<footer class="post__footer">
	

<div class="post-related">
	<h3>相关文章</h3>
	<ul class="post-related-list">
		
		<li class="post-related-item">
			<a href="/posts/2023/08/16/spring-security-form-login-with-database/" target="_blank" title="[译]Spring Security - 使用数据库表单登录">[译]Spring Security - 使用数据库表单登录</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2023/07/14/oauth-2-centralized-authorization-with-spring-boot-2-and-spring-security-5-and-jdbc-token-store/" target="_blank" title="[译]使用Spring Boot2和Spring Security 5以及JDBC令牌存储进行Oauth2集中授权">[译]使用Spring Boot2和Spring Security 5以及JDBC令牌存储进行Oauth2集中授权</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2023/08/16/spring-security-with-jwt/" target="_blank" title="[译]Spring Security - JWT">[译]Spring Security - JWT</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2023/08/16/spring-security-form-login-remember-me-and-logout/" target="_blank" title="[译]Spring Security - 表单登录、记住我和注销">[译]Spring Security - 表单登录、记住我和注销</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2023/08/16/spring-security/" target="_blank" title="[译]Spring Security 和 Spring Boot 入门">[译]Spring Security 和 Spring Boot 入门</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2023/08/16/spring-security-authentication-and-authorization/" target="_blank" title="[译]Spring Security：深入了解身份验证和授权">[译]Spring Security：深入了解身份验证和授权</a>
		</li>
		
	</ul>
</div>

</footer>

<footer class="post__footer">
	<footer class="post__footer">
		
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/mysql/" rel="tag">mysql</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/java/" rel="tag">java</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/javascript/" rel="tag">javascript</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/backend/" rel="tag">backend</a>
		</li>
	</ul>
</div>
	</footer>
</footer>


<nav class="pagination flex">
	<div class="pagination__item pagination__item--prev">
		<a class="pagination__link" href="/posts/2023/08/16/spring-boot-docker/" rel="prev">
			<p class="pagination__title">«&thinsp;上一篇: [译]为 Spring Boot 应用程序创建优化的 Docker 映像</p>
		</a>
	</div>
	<div class="pagination__item pagination__item--next">
		<a class="pagination__link" href="/posts/2023/08/16/spring-security-authentication-and-authorization/" rel="next">
			<p class="pagination__title">&thinsp;» 下一篇: [译]Spring Security：深入了解身份验证和授权</p>
		</a>
	</div>
</nav>



<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="ChenSoul avatar" src="/avatar.jpg" class="avatar" height="60" width="60" loading="lazy">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">关于 ChenSoul</span>
	</div>
	<div class="authorbox__description">
		一个来自中国武汉的开发者，主要撰写软件开发和开源方面的文章。浏览我的<a href="%28/posts%29">博客文章</a>，订阅我的 <a href="/index.xml">RSS</a> 源，或了解更多<a href="/about/">关于我</a>的信息。
	</div>
</div>




	<p><h3>欢迎留言！</h3></p>
<div id="remark42"></div>
<script>
	var remark_config = {
		host: 'https:\/\/comment.chensoul.cc',
		site_id: 'remark',
		components: ['embed'],
		url: 'https:\/\/blog.chensoul.cc\/posts\/2023\/08\/16\/spring-transaction-management-transactional-in-depth\/',
		locale: 'zh'
	};

	!function(e, n) {
		for (var o = 0; o < e.length; o++) {
			var r = n.createElement('script'),
			c = '.js',
			d = n.head || n.body;
			'noModule' in r ? (r.type = 'module', c = '.mjs') : r.async = !0, r.defer = !0, r.src = remark_config.host + '/web/' + e[o] + c, d.appendChild(r)
		}
	}(remark_config.components || ['embed'], document);

</script>





			</div>
			

<aside class="sidebar sidebar--right">
	<div class="post__toc toc">
		<div class="toc__title">目录</div>
		<div class="toc__menu">
			<nav id="TableOfContents">
  <ul>
    <li><a href="#介绍">介绍</a></li>
    <li><a href="#普通-jdbc-事务管理的工作原理">普通 JDBC 事务管理的工作原理</a>
      <ul>
        <li><a href="#如何启动提交或回滚-jdbc-事务">如何启动、提交或回滚 JDBC 事务</a></li>
        <li><a href="#如何使用-jdbc-隔离级别和保存点">如何使用 JDBC 隔离级别和保存点</a></li>
      </ul>
    </li>
    <li><a href="#spring-或-spring-boot-的事务管理如何工作">Spring 或 Spring Boot 的事务管理如何工作</a>
      <ul>
        <li><a href="#如何使用-spring-的程序化事务管理">如何使用 Spring 的程序化事务管理？</a></li>
        <li><a href="#如何使用-spring-的-xml-声明式事务管理">如何使用 Spring 的 XML 声明式事务管理？</a></li>
        <li><a href="#如何使用-spring-的transactional-注解声明式事务管理">如何使用 Spring 的@Transactional 注解（声明式事务管理）</a></li>
        <li><a href="#cglib-和-jdk-代理---transactional-的幕后黑手">CGlib 和 JDK 代理 - @Transactional 的幕后黑手</a></li>
        <li><a href="#为什么需要事务管理器如-platformtransactionmanager">为什么需要事务管理器（如 PlatformTransactionManager）？</a></li>
        <li><a href="#物理事务和逻辑事务有什么区别">物理事务和逻辑事务有什么区别？</a></li>
        <li><a href="#transactional-传播级别的用途是什么">@Transactional 传播级别的用途是什么？</a></li>
        <li><a href="#transactional-隔离级别有什么用">@Transactional 隔离级别有什么用？</a></li>
        <li><a href="#最常见的transactional-陷阱">最常见的@Transactional 陷阱</a></li>
        <li><a href="#如何在-spring-boot-或-spring-mvc-中使用-transactional">如何在 Spring Boot 或 Spring MVC 中使用 @Transactional</a></li>
        <li><a href="#spring-如何处理回滚以及默认回滚策略">Spring 如何处理回滚（以及默认回滚策略）</a></li>
      </ul>
    </li>
    <li><a href="#spring-和-jpahibernate-事务管理如何工作">Spring 和 JPA/Hibernate 事务管理如何工作</a>
      <ul>
        <li><a href="#目标同步-spring-的-transactional-和-hibernate--jpa">目标：同步 Spring 的 @Transactional 和 Hibernate / JPA</a></li>
        <li><a href="#使用-hibernatetransactionmanager">使用 HibernateTransactionManager</a></li>
      </ul>
    </li>
    <li><a href="#fin">Fin</a></li>
    <li><a href="#致谢">致谢</a></li>
  </ul>
</nav>
		</div>
	</div>
</aside>

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
<div class="footer__links">
	<a class="footer__link" href="/">首页</a> | <a class="footer__link" href="/categories/">分类</a> | <a class="footer__link" href="/tags/">标签</a> | <a class="footer__link" href="/index.xml">订阅</a> | <a class="footer__link" href="/about/">关于</a>
</div>
		<div class="footer__copyright">
			&copy; 2025 ChenSoul.
			<span class="footer__copyright-credits">基于 <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> 引擎和 <a href="https://github.com/chensoul/rose-hugo/" rel="nofollow noopener" target="_blank">Rose Hugo</a> 主题</span>
		</div>
	</div>

	






<style>
	.scroll-up a {
		display: block;
		height: 3.125rem;
		width: 3.125rem;
		text-align: center;
		line-height: 2.7;
		border-radius: 50px;
		font-size: 1.125rem;
		color: #fff;
		opacity: 1;
		transition: all 0.3s ease 0s;
		box-shadow: 0 0 10px rgb(0 0 0 / 20%);
	}
	.scroll-up a {
		background: #ee591f;
	}
	.scroll-up {
		position: fixed;
		display: none;
		bottom: 50px;
		z-index: 999;
	}
	.scroll-up.right {
		right: 60px;
	}
</style>

<div class="scroll-up custom right" style="display: block;"><a href="#top" id="top-link" accesskey="g"><i
	class="fa fa-arrow-up"></i></a></div>

<script>
	var mybutton = document.getElementById("top-link");
	window.onscroll = function () {
		if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
			mybutton.style.visibility = "visible";
			mybutton.style.opacity = "1";
		} else {
			mybutton.style.visibility = "hidden";
			mybutton.style.opacity = "0";
		}
	};
</script>


    <script defer src="https://umami.chensoul.cc/random-string.js" data-website-id="1e07d36d-bec3-4ba6-9459-876b1ac3bbe7"></script>
</footer>


	</div>

	<script>
		'use strict';
		(function iifeMenu(document, window, undefined) {
			var menuBtn = document.querySelector('.menu__btn');
			var	menu = document.querySelector('.menu__list');
			function toggleMenu() {
				menu.classList.toggle('menu__list--active');
				menu.classList.toggle('menu__list--transition');
				this.classList.toggle('menu__btn--active');
				this.setAttribute(
					'aria-expanded',
					this.getAttribute('aria-expanded') === 'true' ? 'false' : 'true'
				);
			}
			function removeMenuTransition() {
				this.classList.remove('menu__list--transition');
			}
			if (menuBtn && menu) {
				menuBtn.addEventListener('click', toggleMenu, false);
				menu.addEventListener('transitionend', removeMenuTransition, false);
			}
		}(document, window));
	</script>
</body>
</html>