<!DOCTYPE html>
<html class="no-js" lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[译]《Grokking the System Design Interview》系统设计主模板 - Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="[译]《Grokking the System Design Interview》系统设计主模板">
	<meta property="og:description" content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps">
	<meta property="og:type" content="article">
	<meta property="og:url" content="https://blog.chensoul.cc/posts/2023/11/16/system-design-master-template/">
	<meta property="og:site_name" content="ChenSoul Blog">
	<meta property="og:image" content="">
	
  <meta itemprop="name" content="[译]《Grokking the System Design Interview》系统设计主模板">
  <meta itemprop="description" content="这是一篇双语翻译的文章，原文出自《Grokking the System Design Interview》教程的 System Design Master Template 这篇章节。">
  <meta itemprop="datePublished" content="2023-11-16T00:00:00+00:00">
  <meta itemprop="dateModified" content="2023-11-16T00:00:00+00:00">
  <meta itemprop="wordCount" content="3016">
  <meta itemprop="keywords" content="Javascript,Rabbitmq,Kafka,Redis">
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:title" content="[译]《Grokking the System Design Interview》系统设计主模板">
	<meta name="twitter:description" content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps">
	<meta name="twitter:image" content="">

	<link rel="preconnect" href="//fonts.loli.net" crossorigin>
	<link rel="dns-prefetch" href="//fonts.loli.net">
	<link rel="stylesheet" href="https://fonts.loli.net/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css" integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
	<link rel="stylesheet" href="/css/style.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="ChenSoul Blog" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="/logo.svg" loading="lazy" alt="Site logo" width="60" height="60">
				</div><div class="logo__item logo__text">
					<div class="logo__title">ChenSoul Blog</div>
					<div class="logo__tagline">Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">菜单</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/">
				
				<span class="menu__text">首页</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/categories/">
				
				<span class="menu__text">分类</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/tags/">
				
				<span class="menu__text">标签</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/index.xml">
				
				<span class="menu__text">订阅</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">关于</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[译]《Grokking the System Design Interview》系统设计主模板</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 1 1 0 28 1 1 0 0 1 0-28m0 3a3 3 0 1 0 0 22 3 3 0 0 0 0-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class="meta__text" datetime="2023-11-16">2023-11-16</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class="meta__text"><a class="meta__link" href="/categories/architecture/" rel="category">Architecture</a>
	</span>
</div><div class="meta__item-tags meta__item"><svg class="meta__icon icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg><span class="meta__text"><a class="meta__link" href="/tags/javascript/" rel="tag">Javascript</a>, <a class="meta__link" href="/tags/rabbitmq/" rel="tag">Rabbitmq</a>, <a class="meta__link" href="/tags/kafka/" rel="tag">Kafka</a>, <a class="meta__link" href="/tags/redis/" rel="tag">Redis</a>
	</span>
</div>
</div>
		</header>
		
		<div class="content post__content clearfix">
			<p>这是一篇双语翻译的文章，原文出自《Grokking the System Design Interview》教程的 <a href="https://www.designgurus.io/course-play/grokking-the-system-design-interview/doc/645d5161fff33a24ccce4bb1" target="_blank">System Design Master Template</a> 这篇章节。</p>
<hr>
<p>System design interviews are unstructured by design. In these interviews, you are asked to take on an open-ended design problem that doesn’t have a standard solution.</p>
<blockquote>
<p>系统设计面试在设计上是非结构化的。在这些面试中，您被要求解决一个没有标准解决方案的开放式设计问题。</p></blockquote>
<p>The two biggest challenges of answering a system design interview question are:</p>
<blockquote>
<p>回答系统设计面试问题的两个最大挑战是：</p></blockquote>
<ol>
<li>
<p>To know where to start.</p>
<blockquote>
<p>知道从哪里开始。</p></blockquote>
</li>
<li>
<p>To know if you have talked about all the important parts of the system.</p>
<blockquote>
<p>了解您是否已经讨论过系统的所有重要部分。</p></blockquote>
</li>
</ol>
<p>To simplify this process, the course offers a comprehensive system design template that can effectively guide you in addressing any system design interview question.</p>
<blockquote>
<p>为了简化这个过程，本课程提供了一个全面的系统设计模板，可以有效地指导您解决任何系统设计面试问题。</p></blockquote>
<p>Have a look at the following image to understand the major components that could be part of any system design and how these components interact with each other.
查看下图，了解可能成为任何系统设计一部分的主要组件以及这些组件如何相互交互。</p>
<p><img src="../../../static/images/system-design-master-template-01.webp" alt="system-design-master-template-01"></p>
<p>With this master template in mind, we will discuss the 18 essential system design concepts. Here is a brief description of each:</p>
<blockquote>
<p>考虑到这个主模板，我们将讨论 18 个基本的系统设计概念。以下是每项的简要说明：</p></blockquote>
<h2 id="1-domain-name-system-dns">1. Domain Name System (DNS)</h2>
<blockquote>
<p>1.域名系统（DNS）</p></blockquote>
<p>The Domain Name System (DNS) serves as a fundamental component of the internet infrastructure, translating user-friendly domain names into their corresponding IP addresses. It acts as a phonebook for the internet, enabling users to access websites and services by entering easily memorable domain names, such as <a href="http://www.designgurus.io/" target="_blank">www.designgurus.io</a>, rather than the numerical IP addresses like &ldquo;192.0.2.1&rdquo; that computers utilize to identify each other.</p>
<blockquote>
<p>域名系统 (DNS) 是互联网基础设施的基本组成部分，它将用户友好的域名转换为其相应的 IP 地址。它充当互联网的电话簿，使用户能够通过输入易于记忆的域名（例如 <a href="https://www.designgurus.io" target="_blank">www.designgurus.io</a>）来访问网站和服务，而不是计算机用来识别彼此的数字 IP 地址（例如“192.0.2.1”） 。</p></blockquote>
<p>When you input a domain name into your web browser, the DNS is responsible for finding the associated IP address and directing your request to the appropriate server. This process commences with your computer sending a query to a recursive resolver, which then searches a series of DNS servers, beginning with the root server, followed by the Top-Level Domain (TLD) server, and ultimately the authoritative name server. Once the IP address is located, the recursive resolver returns it to your computer, allowing your browser to establish a connection with the target server and access the desired content.</p>
<blockquote>
<p>当您在网络浏览器中输入域名时，DNS 负责查找关联的 IP 地址并将您的请求定向到适当的服务器。此过程首先是您的计算机向递归解析器发送查询，然后递归解析器搜索一系列 DNS 服务器，从根服务器开始，然后是顶级域 (TLD) 服务器，最后是权威名称服务器。一旦找到 IP 地址，递归解析器会将其返回到您的计算机，从而允许您的浏览器与目标服务器建立连接并访问所需的内容。</p></blockquote>
<p><img src="../../../static/images/system-design-master-template-02.webp" alt="system-design-master-template-02"></p>
<h2 id="2-load-balancer">2. Load Balancer</h2>
<blockquote>
<p>2.负载均衡器</p></blockquote>
<p>A load balancer is a networking device or software designed to distribute incoming network traffic across multiple servers, ensuring optimal resource utilization, reduced latency, and maintained high availability. It plays a crucial role in scaling applications and efficiently managing server workloads, particularly in situations where there is a sudden surge in traffic or uneven distribution of requests among servers.</p>
<blockquote>
<p>负载均衡器是一种网络设备或软件，旨在跨多个服务器分配传入的网络流量，确保最佳的资源利用率、减少延迟并保持高可用性。它在扩展应用程序和有效管理服务器工作负载方面发挥着至关重要的作用，特别是在流量突然激增或服务器之间请求分布不均匀的情况下。</p></blockquote>
<p>Load balancers employ various algorithms to determine the distribution of incoming traffic. Some common algorithms include:</p>
<blockquote>
<p>负载均衡器采用各种算法来确定传入流量的分配。一些常见的算法包括：</p></blockquote>
<ul>
<li>
<p><strong>Round Robin:</strong> Requests are sequentially and evenly distributed across all available servers in a cyclical manner.</p>
<blockquote>
<p>循环：请求以循环方式顺序均匀地分布在所有可用服务器上。</p></blockquote>
</li>
<li>
<p><strong>Least Connections:</strong> The load balancer assigns requests to the server with the fewest active connections, giving priority to less-busy servers.</p>
<blockquote>
<p>最少连接：负载均衡器将请求分配给活动连接最少的服务器，并优先考虑不太繁忙的服务器。</p></blockquote>
</li>
<li>
<p><strong>IP Hash:</strong> The client&rsquo;s IP address is hashed, and the resulting value is used to determine which server the request should be directed to. This method ensures that a specific client&rsquo;s requests are consistently routed to the same server, helping maintain session persistence.</p>
<blockquote>
<p>IP 哈希：对客户端的 IP 地址进行哈希处理，结果值用于确定请求应定向到哪个服务器。此方法可确保特定客户端的请求一致路由到同一服务器，从而有助于维护会话持久性。</p></blockquote>
</li>
</ul>
<p><img src="../../../static/images/system-design-master-template-03.webp" alt="system-design-master-template-03"></p>
<h2 id="3-api-gateway">3. API Gateway</h2>
<blockquote>
<p>3.API网关</p></blockquote>
<p>An API Gateway serves as a server or service that functions as an intermediary between external clients and the internal microservices or API-based backend services of an application. It is a vital component in contemporary architectures, particularly in microservices-based systems, where it streamlines the communication process and offers a single entry point for clients to access various services.</p>
<blockquote>
<p>API 网关充当服务器或服务，充当外部客户端与应用程序的内部微服务或基于 API 的后端服务之间的中介。它是当代架构中的重要组成部分，特别是在基于微服务的系统中，它简化了通信流程，并为客户端访问各种服务提供了单一入口点。</p></blockquote>
<p>The primary functions of an API Gateway encompass:</p>
<blockquote>
<p>API网关的主要功能包括：</p></blockquote>
<ol>
<li>
<p>Request Routing: The API Gateway directs incoming API requests from clients to the appropriate backend service or microservice, based on predefined rules and configurations.</p>
<blockquote>
<p>请求路由：API 网关根据预定义的规则和配置，将来自客户端的传入 API 请求定向到适当的后端服务或微服务。</p></blockquote>
</li>
<li>
<p>Authentication and Authorization: The API Gateway manages user authentication and authorization, ensuring that only authorized clients can access the services. It verifies API keys, tokens, or other credentials before routing requests to the backend services.</p>
<blockquote>
<p>身份验证和授权：API网关管理用户身份验证和授权，确保只有授权的客户端才能访问服务。它在将请求路由到后端服务之前验证 API 密钥、令牌或其他凭据。</p></blockquote>
</li>
<li>
<p>Rate Limiting and Throttling: To safeguard backend services from excessive load or abuse, the API Gateway enforces rate limits or throttles requests from clients according to predefined policies.</p>
<blockquote>
<p>速率限制和节流：为了保护后端服务免受过度负载或滥用，API 网关根据预定义的策略强制执行速率限制或节流来自客户端的请求。</p></blockquote>
</li>
<li>
<p>Caching: In order to minimize latency and backend load, the API Gateway caches frequently-used responses, serving them directly to clients without the need to query the backend services.</p>
<blockquote>
<p>缓存：为了最大程度地减少延迟和后端负载，API 网关会缓存常用的响应，将其直接提供给客户端，而无需查询后端服务。</p></blockquote>
</li>
<li>
<p>Request and Response Transformation: The API Gateway can modify requests and responses, such as converting data formats, adding or removing headers, or altering query parameters, to ensure compatibility between clients and services.</p>
<blockquote>
<p>请求和响应转换：API网关可以修改请求和响应，例如转换数据格式、添加或删除标头或更改查询参数，以确保客户端和服务之间的兼容性。</p></blockquote>
</li>
</ol>
<p><img src="../../../static/images/system-design-master-template-04.webp" alt="system-design-master-template-04"></p>
<h2 id="4-cdn">4. CDN</h2>
<blockquote>
<p>4.CDN</p></blockquote>
<p>A Content Delivery Network (CDN) is a distributed network of servers that store and deliver content, such as images, videos, stylesheets, and scripts, to users from locations that are geographically closer to them. CDNs are designed to enhance the performance, speed, and reliability of content delivery to end-users, irrespective of their location relative to the origin server. Here&rsquo;s how a CDN operates:</p>
<blockquote>
<p>内容交付网络 (CDN) 是一种分布式服务器网络，用于存储并向地理位置较近的用户交付内容（例如图像、视频、样式表和脚本）。 CDN 旨在增强向最终用户交付内容的性能、速度和可靠性，无论其相对于源服务器的位置如何。 CDN 的运作方式如下：</p></blockquote>
<ol>
<li>
<p>When a user requests content from a website or application, the request is directed to the nearest CDN server, also known as an edge server.</p>
<blockquote>
<p>当用户从网站或应用程序请求内容时，请求将被定向到最近的 CDN 服务器（也称为边缘服务器）。</p></blockquote>
</li>
<li>
<p>If the edge server has the requested content cached, it directly serves the content to the user. This process reduces latency and improves the user experience, as the content travels a shorter distance.</p>
<blockquote>
<p>如果边缘服务器缓存了所请求的内容，则它直接向用户提供内容。由于内容传输的距离较短，因此此过程减少了延迟并改善了用户体验。</p></blockquote>
</li>
<li>
<p>If the content is not cached on the edge server, the CDN retrieves it from the origin server or another nearby CDN server. Once the content is fetched, it is cached on the edge server and served to the user.</p>
<blockquote>
<p>如果内容未缓存在边缘服务器上，则 CDN 会从源服务器或其他附近的 CDN 服务器检索内容。获取内容后，它会缓存在边缘服务器上并提供给用户。</p></blockquote>
</li>
<li>
<p>To ensure the content stays up-to-date, the CDN periodically checks the origin server for changes and updates its cache accordingly.</p>
<blockquote>
<p>为了确保内容保持最新，CDN 定期检查源服务器是否有更改并相应更新其缓存。</p></blockquote>
</li>
</ol>
<p><img src="../../../static/images/system-design-master-template-05.webp" alt="system-design-master-template-05"></p>
<h2 id="5-forward-proxy-vs-reverse-proxy">5. Forward Proxy vs. Reverse Proxy</h2>
<blockquote>
<ol start="5">
<li>正向代理与反向代理</li>
</ol></blockquote>
<p>A forward proxy, also referred to as a &ldquo;proxy server&rdquo; or simply &ldquo;proxy,&rdquo; is a server positioned in front of one or more client machines, acting as an intermediary between the clients and the internet. When a client machine requests a resource on the internet, the request is initially sent to the forward proxy. The forward proxy then forwards the request to the internet on behalf of the client machine and returns the response to the client machine.</p>
<blockquote>
<p>转发代理也称为“代理服务器”或简称为“代理”，是位于一台或多台客户端计算机前面的服务器，充当客户端和互联网之间的中介。当客户端计算机请求互联网上的资源时，该请求最初被发送到转发代理。然后，转发代理代表客户端计算机将请求转发到互联网，并将响应返回到客户端计算机。</p></blockquote>
<p>On the other hand, a reverse proxy is a server that sits in front of one or more web servers, serving as an intermediary between the web servers and the internet. When a client requests a resource on the internet, the request is first sent to the reverse proxy. The reverse proxy then forwards the request to one of the web servers, which returns the response to the reverse proxy. Finally, the reverse proxy returns the response to the client.</p>
<blockquote>
<p>另一方面，反向代理是位于一个或多个 Web 服务器前面的服务器，充当 Web 服务器和互联网之间的中介。当客户端请求互联网上的资源时，请求首先发送到反向代理。然后，反向代理将请求转发到其中一台 Web 服务器，该服务器将响应返回给反向代理。最后，反向代理将响应返回给客户端。</p></blockquote>
<p><img src="../../../static/images/system-design-master-template-06.webp" alt="system-design-master-template-06"></p>
<h2 id="6-caching">6. Caching</h2>
<blockquote>
<ol start="6">
<li>缓存</li>
</ol></blockquote>
<p>Cache is a high-speed storage layer positioned between the application and the original data source, such as a database, file system, or remote web service. When an application requests data, the cache is checked first. If the data is present in the cache, it is returned to the application. If the data is not found in the cache, it is retrieved from its original source, stored in the cache for future use, and then returned to the application. In a distributed system, caching can occur in multiple locations, including the client, DNS, CDN, load balancer, API gateway, server, database, and more.</p>
<blockquote>
<p>缓存是位于应用程序和原始数据源（例如数据库、文件系统或远程 Web 服务）之间的高速存储层。当应用程序请求数据时，首先检查缓存。如果数据存在于缓存中，则将其返回给应用程序。如果在缓存中找不到数据，则会从原始来源检索该数据，将其存储在缓存中以供将来使用，然后返回给应用程序。在分布式系统中，缓存可以发生在多个位置，包括客户端、DNS、CDN、负载均衡器、API 网关、服务器、数据库等。</p></blockquote>
<p><img src="../../../static/images/system-design-master-template-07.webp" alt="system-design-master-template-07"></p>
<h2 id="7-data-partitioning">7. Data Partitioning</h2>
<blockquote>
<ol start="7">
<li>数据分区</li>
</ol></blockquote>
<p>In a database, <strong>horizontal partitioning</strong>, often referred to as <strong>sharding</strong>, entails dividing the rows of a table into smaller tables and storing them on distinct servers or database instances. This method is employed to distribute the database load across multiple servers, thereby enhancing performance.</p>
<blockquote>
<p>在数据库中，水平分区（通常称为分片）需要将表的行划分为更小的表，并将它们存储在不同的服务器或数据库实例上。该方法用于将数据库负载分散到多个服务器上，从而提高性能。</p></blockquote>
<p>Conversely, <strong>vertical partitioning</strong> involves splitting the columns of a table into separate tables. This technique aims to reduce the column count in a table and boost the performance of queries that only access a limited number of columns.</p>
<blockquote>
<p>相反，垂直分区涉及将表的列拆分为单独的表。该技术旨在减少表中的列数并提高仅访问有限数量列的查询的性能。</p></blockquote>
<p><img src="../../../static/images/system-design-master-template-08.webp" alt="system-design-master-template-08"></p>
<h2 id="8-database-replication">8. Database Replication</h2>
<blockquote>
<ol start="8">
<li>数据库复制</li>
</ol></blockquote>
<p>Database replication is a method employed to maintain multiple copies of the same database across various servers or locations. The main objective of database replication is to enhance data availability, redundancy, and fault tolerance, ensuring the system remains operational even in the face of hardware failures or other issues.</p>
<blockquote>
<p>数据库复制是一种用于跨不同服务器或位置维护同一数据库的多个副本的方法。数据库复制的主要目标是增强数据可用性、冗余和容错能力，确保系统即使在遇到硬件故障或其他问题时也能保持运行。</p></blockquote>
<p>In a replicated database configuration, one server serves as the primary (or master) database, while others act as replicas (or slaves). This process involves synchronizing data between the primary database and replicas, ensuring all possess the same up-to-date information. Database replication provides several advantages, including:</p>
<blockquote>
<p>在复制数据库配置中，一台服务器充当主（或主）数据库，而其他服务器充当副本（或从）数据库。此过程涉及在主数据库和副本之间同步数据，确保所有数据库都拥有相同的最新信息。数据库复制具有多种优势，包括：</p></blockquote>
<ol>
<li>
<p>Improved Performance: By distributing read queries among multiple replicas, the load on the primary database can be reduced, leading to faster query response times.</p>
<blockquote>
<p>提高性能：通过在多个副本之间分配读取查询，可以减少主数据库上的负载，从而加快查询响应时间。</p></blockquote>
</li>
<li>
<p>High Availability: If the primary database experiences failure or downtime, replicas can continue to provide data, ensuring uninterrupted access to the application.</p>
<blockquote>
<p>高可用性：如果主数据库出现故障或停机，副本可以继续提供数据，确保对应用程序的不间断访问。</p></blockquote>
</li>
<li>
<p>Enhanced Data Protection: Maintaining multiple copies of the database across different locations helps safeguard against data loss due to hardware failures or other disasters.</p>
<blockquote>
<p>增强的数据保护：在不同位置维护数据库的多个副本有助于防止由于硬件故障或其他灾难而导致的数据丢失。</p></blockquote>
</li>
<li>
<p>Load Balancing: Replicas can handle read queries, allowing for better load distribution and reducing overall stress on the primary database.</p>
<blockquote>
<p>负载平衡：副本可以处理读取查询，从而实现更好的负载分配并减少主数据库的整体压力。</p></blockquote>
</li>
</ol>
<h2 id="9-distributed-messaging-systems">9. Distributed Messaging Systems</h2>
<blockquote>
<p>9.分布式消息系统</p></blockquote>
<p>Distributed messaging systems provide a reliable, scalable, and fault-tolerant means for exchanging messages between numerous, possibly geographically-dispersed applications, services, or components. These systems facilitate communication by decoupling sender and receiver components, enabling them to develop and function independently. Distributed messaging systems are especially valuable in large-scale or intricate systems, like those seen in microservices architectures or distributed computing environments. Examples of these systems include Apache Kafka and RabbitMQ.</p>
<blockquote>
<p>分布式消息传递系统提供了一种可靠、可扩展且容错的方式，用于在众多可能在地理上分散的应用程序、服务或组件之间交换消息。这些系统通过解耦发送器和接收器组件来促进通信，使它们能够独立开发和运行。分布式消息传递系统在大规模或复杂的系统中尤其有价值，例如微服务架构或分布式计算环境中的系统。这些系统的示例包括 Apache Kafka 和 RabbitMQ。</p></blockquote>
<h2 id="10-microservices">10. Microservices</h2>
<blockquote>
<ol start="10">
<li>微服务</li>
</ol></blockquote>
<p>Microservices represent an architectural style wherein an application is organized as an assembly of small, loosely-coupled, and autonomously deployable services. Each microservice is accountable for a distinct aspect of functionality or domain within the application and communicates with other microservices via well-defined APIs. This method deviates from the conventional monolithic architecture, where an application is constructed as a single, tightly-coupled unit.</p>
<blockquote>
<p>微服务代表了一种架构风格，其中应用程序被组织为小型、松散耦合且可自主部署的服务的集合。每个微服务负责应用程序内功能或领域的不同方面，并通过定义良好的 API 与其他微服务进行通信。此方法不同于传统的整体架构，在传统的整体架构中，应用程序被构建为单个紧密耦合的单元。</p></blockquote>
<p>The primary characteristics of microservices include:</p>
<blockquote>
<p>微服务的主要特征包括：</p></blockquote>
<ol>
<li>
<p>Single Responsibility: Adhering to the Single Responsibility Principle, each microservice focuses on a specific function or domain, making the services more straightforward to comprehend, develop, and maintain.</p>
<blockquote>
<p>单一职责：遵循单一职责原则，每个微服务都专注于特定的功能或领域，使服务更易于理解、开发和维护。</p></blockquote>
</li>
<li>
<p>Independence: Microservices can be independently developed, deployed, and scaled, offering increased flexibility and agility in the development process. Teams can work on various services simultaneously without impacting the entire system.</p>
<blockquote>
<p>独立性：微服务可以独立开发、部署和扩展，从而提高开发过程的灵活性和敏捷性。团队可以同时处理各种服务，而不会影响整个系统。</p></blockquote>
</li>
<li>
<p>Decentralization: Typically, microservices are decentralized, with each service possessing its data and business logic. This approach fosters separation of concerns and empowers teams to make decisions and select technologies tailored to their unique requirements.</p>
<blockquote>
<p>去中心化：通常，微服务是去中心化的，每个服务都拥有自己的数据和业务逻辑。这种方法促进了关注点分离，并使团队能够做出决策并选择适合其独特需求的技术。</p></blockquote>
</li>
<li>
<p>Communication: Microservices interact with each other using lightweight protocols, such as HTTP/REST, gRPC, or message queues. This fosters interoperability and facilitates the integration of new services or the replacement of existing ones.</p>
<blockquote>
<p>通信：微服务使用轻量级协议（例如 HTTP/REST、gRPC 或消息队列）相互交互。这促进了互操作性并促进新服务的集成或现有服务的替换。</p></blockquote>
</li>
<li>
<p>Fault Tolerance: As microservices are independent, the failure of one service does not necessarily result in the collapse of the entire system, enhancing the application&rsquo;s overall resiliency.</p>
<blockquote>
<p>容错性：由于微服务是独立的，一个服务的故障并不一定会导致整个系统崩溃，增强了应用程序的整体弹性。</p></blockquote>
</li>
</ol>
<h2 id="11-nosql-databases">11. NoSQL Databases</h2>
<blockquote>
<p>11.NoSQL 数据库</p></blockquote>
<p><a href="https://www.designgurus.io/blog/no-slq-database" target="_blank">NoSQL databases</a>, or “Not Only SQL” databases, are non-relational databases designed to store, manage, and retrieve unstructured or semi-structured data. They offer an alternative to traditional relational databases, which rely on structured data and predefined schemas. NoSQL databases have become popular due to their flexibility, scalability, and ability to handle large volumes of data, making them well-suited for modern applications, big data processing, and real-time analytics.</p>
<blockquote>
<p>NoSQL 数据库或“Not Only SQL”数据库是非关系数据库，旨在存储、管理和检索非结构化或半结构化数据。它们提供了传统关系数据库的替代方案，传统关系数据库依赖于结构化数据和预定义模式。 NoSQL 数据库因其灵活性、可扩展性和处理大量数据的能力而变得流行，使其非常适合现代应用程序、大数据处理和实时分析。</p></blockquote>
<p>NoSQL databases can be categorized into four main types:</p>
<blockquote>
<p>NoSQL 数据库可分为四种主要类型：</p></blockquote>
<ol>
<li>
<p>Document-Based: These databases store data in document-like structures, such as JSON or BSON. Each document is self-contained and can have its own unique structure, making them suitable for handling heterogeneous data. Examples of document-based NoSQL databases include MongoDB and Couchbase.</p>
<blockquote>
<p>基于文档：这些数据库以类似文档的结构存储数据，例如 JSON 或 BSON。每个文档都是独立的，可以有自己独特的结构，使它们适合处理异构数据。基于文档的 NoSQL 数据库的示例包括 MongoDB 和 Couchbase。</p></blockquote>
</li>
<li>
<p>Key-Value: These databases store data as key-value pairs, where the key acts as a unique identifier, and the value holds the associated data. Key-value databases are highly efficient for simple read and write operations, and they can be easily partitioned and scaled horizontally. Examples of key-value NoSQL databases include Redis and Amazon DynamoDB.</p>
<blockquote>
<p>键值：这些数据库将数据存储为键值对，其中键充当唯一标识符，值保存关联的数据。键值数据库对于简单的读写操作非常高效，并且可以轻松地进行分区和水平扩展。键值 NoSQL 数据库的示例包括 Redis 和 Amazon DynamoDB。</p></blockquote>
</li>
<li>
<p>Column-Family: These databases store data in column families, which are groups of related columns. They are designed to handle write-heavy workloads and are highly efficient for querying data with a known row and column keys. Examples of column-family NoSQL databases include Apache Cassandra and HBase.</p>
<blockquote>
<p>列族：这些数据库将数据存储在列族中，列族是相关列的组。它们旨在处理写入繁重的工作负载，并且对于使用已知的行键和列键查询数据非常高效。列族 NoSQL 数据库的示例包括 Apache Cassandra 和 HBase。</p></blockquote>
</li>
<li>
<p>Graph-Based: These databases are designed for storing and querying data that has complex relationships and interconnected structures, such as social networks or recommendation systems. Graph databases use nodes, edges, and properties to represent and store data, making it easier to perform complex traversals and relationship-based queries. Examples of graph-based NoSQL databases include Neo4j and Amazon Neptune.</p>
<blockquote>
<p>基于图：这些数据库旨在存储和查询具有复杂关系和互连结构的数据，例如社交网络或推荐系统。图数据库使用节点、边和属性来表示和存储数据，从而更容易执行复杂的遍历和基于关系的查询。基于图形的 NoSQL 数据库的示例包括 Neo4j 和 Amazon Neptune。</p></blockquote>
</li>
</ol>
<p><img src="../../../static/images/system-design-master-template-09.webp" alt="system-design-master-template-09"></p>
<h2 id="12-database-index">12. Database Index</h2>
<blockquote>
<ol start="12">
<li>数据库索引</li>
</ol></blockquote>
<p>Database indexes are data structures that enhance the speed and efficiency of query operations within a database. They function similarly to an index in a book, enabling the database management system (DBMS) to swiftly locate data associated with a specific value or group of values, without the need to search through every row in a table. By offering a more direct route to the desired data, indexes can considerably decrease the time required to retrieve information from a database.</p>
<blockquote>
<p>数据库索引是提高数据库内查询操作速度和效率的数据结构。它们的功能类似于书中的索引，使数据库管理系统 (DBMS) 能够快速定位与特定值或一组值关联的数据，而无需搜索表中的每一行。通过提供获取所需数据的更直接途径，索引可以大大减少从数据库检索信息所需的时间。</p></blockquote>
<p>Indexes are typically constructed on one or more columns of a database table. The B-tree index is the most prevalent type, organizing data in a hierarchical tree structure, which allows for rapid search, insertion, and deletion operations. Other types of indexes, such as bitmap indexes and hash indexes, exist as well, each with their particular use cases and advantages.</p>
<blockquote>
<p>索引通常构建在数据库表的一列或多列上。 B 树索引是最流行的类型，以分层树结构组织数据，允许快速搜索、插入和删除操作。还存在其他类型的索引，例如位图索引和哈希索引，每种索引都有其特定的用例和优点。</p></blockquote>
<p>Although indexes can significantly enhance query performance, they also involve certain trade-offs:</p>
<blockquote>
<p>虽然索引可以显着提高查询性能，但它们也涉及某些权衡：</p></blockquote>
<ul>
<li>
<p><strong>Storage Space:</strong> Indexes require additional storage space since they generate and maintain separate data structures alongside the original table data.</p>
<blockquote>
<p>存储空间：索引需要额外的存储空间，因为它们与原始表数据一起生成和维护单独的数据结构。</p></blockquote>
</li>
<li>
<p><strong>Write Performance:</strong> When data is inserted, updated, or deleted in a table, the corresponding indexes must also be updated, which may slow down write operations.</p>
<blockquote>
<p>写入性能：当在表中插入、更新或删除数据时，相应的索引也必须更新，这可能会减慢写入操作。</p></blockquote>
</li>
</ul>
<p><img src="../../../static/images/system-design-master-template-10.webp" alt="system-design-master-template-10"></p>
<h2 id="13-distributed-file-systems">13. Distributed File Systems</h2>
<blockquote>
<p>13.分布式文件系统</p></blockquote>
<p>Distributed file systems are storage systems designed to manage and grant access to files and directories across multiple servers, nodes, or machines, frequently distributed across a network. They allow users and applications to access and modify files as though they were situated on a local file system, despite the fact that the actual files may be physically located on various remote servers. Distributed file systems are commonly employed in large-scale or distributed computing environments to offer fault tolerance, high availability, and enhanced performance.</p>
<blockquote>
<p>分布式文件系统是一种存储系统，旨在管理和授予对跨多个服务器、节点或机器的文件和目录的访问权限，这些服务器、节点或机器经常分布在网络上。它们允许用户和应用程序访问和修改文件，就像它们位于本地文件系统上一样，尽管实际文件可能物理上位于各种远程服务器上。分布式文件系统通常用于大规模或分布式计算环境中，以提供容错、高可用性和增强的性能。</p></blockquote>
<h2 id="14-notification-system">14. Notification System</h2>
<blockquote>
<p>14.通知系统</p></blockquote>
<p>These are used to send notifications or alerts to users, such as emails, push notifications, or text messages.</p>
<blockquote>
<p>它们用于向用户发送通知或警报，例如电子邮件、推送通知或短信。</p></blockquote>
<h2 id="15-full-text-search">15. Full-text Search</h2>
<blockquote>
<ol start="15">
<li>全文检索</li>
</ol></blockquote>
<p>Full-text search allows users to search for particular words or phrases within an application or website. Upon receiving a user query, the application or website delivers the most relevant results. To accomplish this rapidly and effectively, full-text search utilizes an inverted index, a data structure that associates words or phrases with the documents where they are found. Elastic Search is an example of such systems.</p>
<blockquote>
<p>全文搜索允许用户在应用程序或网站中搜索特定单词或短语。收到用户查询后，应用程序或网站会提供最相关的结果。为了快速有效地完成此任务，全文搜索使用倒排索引，这是一种将单词或短语与找到它们的文档相关联的数据结构。 Elastic Search 就是此类系统的一个示例。</p></blockquote>
<h2 id="16-distributed-coordination-services">16. Distributed Coordination Services</h2>
<blockquote>
<p>16.分布式协调服务</p></blockquote>
<p>Distributed coordination services are systems engineered to regulate and synchronize the actions of distributed applications, services, or nodes in a dependable, efficient, and fault-tolerant way. They assist in maintaining consistency, addressing distributed synchronization, and overseeing the configuration and state of diverse components in a distributed setting. Distributed coordination services are especially valuable in large-scale or intricate systems, like those encountered in microservices architectures, distributed computing environments, or clustered databases. Apache ZooKeeper, etcd, and Consul are examples of such services.</p>
<blockquote>
<p>分布式协调服务是旨在以可靠、高效和容错的方式调节和同步分布式应用程序、服务或节点的操作的系统。它们有助于维护一致性、解决分布式同步以及监督分布式环境中不同组件的配置和状态。分布式协调服务在大规模或复杂的系统中尤其有价值，例如微服务架构、分布式计算环境或集群数据库中遇到的系统。 Apache ZooKeeper、etcd 和 Consul 是此类服务的示例。</p></blockquote>
<h2 id="17-heartbeat">17. Heartbeat</h2>
<blockquote>
<ol start="17">
<li>心跳</li>
</ol></blockquote>
<p>In a distributed environment, work/data is distributed among servers. To efficiently route requests in such a setup, servers need to know what other servers are part of the system. Furthermore, servers should know if other servers are alive and working. In a decentralized system, whenever a request arrives at a server, the server should have enough information to decide which server is responsible for entertaining that request. This makes the timely detection of server failure an important task, which also enables the system to take corrective actions and move the data/work to another healthy server and stop the environment from further deterioration.</p>
<blockquote>
<p>在分布式环境中，工作/数据分布在服务器之间。为了在这样的设置中有效地路由请求，服务器需要知道系统中还有哪些其他服务器。此外，服务器应该知道其他服务器是否处于活动状态并正在工作。在去中心化系统中，每当请求到达服务器时，服务器都应该有足够的信息来决定哪个服务器负责处理该请求。这使得及时检测服务器故障成为一项重要任务，这也使系统能够采取纠正措施并将数据/工作转移到另一台健康的服务器上，并阻止环境进一步恶化。</p></blockquote>
<p>To solve this, each server periodically sends a heartbeat message to a central monitoring server or other servers in the system to show that it is still alive and functioning.</p>
<blockquote>
<p>为了解决这个问题，每个服务器定期向中央监控服务器或系统中的其他服务器发送心跳消息，以表明它仍然活着并且正在运行。</p></blockquote>
<p>Heartbeating is one of the mechanisms for detecting failures in a distributed system. If there is a central server, all servers periodically send a heartbeat message to it. If there is no central server, all servers randomly choose a set of servers and send them a heartbeat message every few seconds. This way, if no heartbeat message is received from a server for a while, the system can suspect that the server might have crashed. If there is no heartbeat within a configured timeout period, the system can conclude that the server is not alive anymore and stop sending requests to it and start working on its replacement.</p>
<blockquote>
<p>心跳是分布式系统中检测故障的机制之一。如果有一个中心服务器，所有服务器都会定期向它发送心跳消息。如果没有中心服务器，则所有服务器随机选择一组服务器，每隔几秒向它们发送一条心跳消息。这样，如果一段时间内没有收到服务器的心跳消息，系统就会怀疑该服务器可能已经崩溃了。如果在配置的超时时间内没有心跳，系统可以断定服务器不再活动，并停止向其发送请求并开始进行替换。</p></blockquote>
<h2 id="18-checksum">18. Checksum</h2>
<blockquote>
<ol start="18">
<li>校验和</li>
</ol></blockquote>
<p>In a distributed system, while moving data between components, it is possible that the data fetched from a node may arrive corrupted. This corruption can occur because of faults in a storage device, network, software, etc. How can a distributed system ensure data integrity, so that the client receives an error instead of corrupt data?</p>
<blockquote>
<p>在分布式系统中，当在组件之间移动数据时，从节点获取的数据可能会损坏。这种损坏可能是由于存储设备、网络、软件等的故障而发生的。分布式系统如何确保数据完整性，以便客户端收到错误而不是损坏的数据？</p></blockquote>
<p>To solve this, we can calculate a checksum and store it with data.</p>
<blockquote>
<p>为了解决这个问题，我们可以计算校验和并将其与数据一起存储。</p></blockquote>
<p>To calculate a checksum, a cryptographic hash-function like <code>MD5</code>, <code>SHA-1</code>, <code>SHA-256</code>, or <code>SHA-512</code> is used. The hash function takes the input data and produces a string (containing letters and numbers) of fixed length; this string is called the checksum.</p>
<blockquote>
<p>要计算校验和，需要使用<code>MD5</code>、<code>SHA-1</code>、<code>SHA-256</code>或<code>SHA-512</code>等加密哈希函数。哈希函数获取输入数据并生成固定长度的字符串（包含字母和数字）；该字符串称为校验和。</p></blockquote>
<p>When a system is storing some data, it computes a checksum of the data and stores the checksum with the data. When a client retrieves data, it verifies that the data it received from the server matches the checksum stored. If not, then the client can opt to retrieve that data from another replica.</p>
<blockquote>
<p>当系统存储某些数据时，它会计算数据的校验和并将校验和与数据一起存储。当客户端检索数据时，它会验证从服务器接收的数据是否与存储的校验和匹配。如果没有，那么客户端可以选择从另一个副本检索该数据。</p></blockquote>

		</div>


	</article>
</main>
<footer class="post__footer">
	

<div class="post-related">
	<h3>相关文章</h3>
	<ul class="post-related-list">
		
		<li class="post-related-item">
			<a href="/posts/2023/05/22/docker-continuous-integration/" target="_blank" title="[译]Build Robust Continuous Integration With Docker and Friends">[译]Build Robust Continuous Integration With Docker and Friends</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2023/05/18/jsr-166/" target="_blank" title="JSR 166规范">JSR 166规范</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2021/09/09/mac-development-environment-setup/" target="_blank" title="Mac开发环境配置">Mac开发环境配置</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2023/11/10/distributed-systems-03/" target="_blank" title="[译]《分布式系统：为了乐趣和利益》3.时间及顺序">[译]《分布式系统：为了乐趣和利益》3.时间及顺序</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2023/11/10/distributed-systems-04/" target="_blank" title="[译]《分布式系统：为了乐趣和利益》4.复制">[译]《分布式系统：为了乐趣和利益》4.复制</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2023/11/02/jhipster-intro/" target="_blank" title="JHipster安装和介绍">JHipster安装和介绍</a>
		</li>
		
	</ul>
</div>

</footer>

<footer class="post__footer">
	<footer class="post__footer">
		
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/javascript/" rel="tag">javascript</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/rabbitmq/" rel="tag">rabbitmq</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/kafka/" rel="tag">kafka</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/redis/" rel="tag">redis</a>
		</li>
	</ul>
</div>
	</footer>
</footer>


<nav class="pagination flex">
	<div class="pagination__item pagination__item--prev">
		<a class="pagination__link" href="/posts/2023/11/14/distributed-system-basic/" rel="prev">
			<p class="pagination__title">«&thinsp;上一篇: 分布式基础知识</p>
		</a>
	</div>
	<div class="pagination__item pagination__item--next">
		<a class="pagination__link" href="/posts/2023/11/16/sdi-a-step-by-step-guide/" rel="next">
			<p class="pagination__title">&thinsp;» 下一篇: [译]《Grokking the System Design Interview》系统设计访谈：分步指南</p>
		</a>
	</div>
</nav>



<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="ChenSoul avatar" src="/avatar.jpg" class="avatar" height="60" width="60" loading="lazy">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">关于 ChenSoul</span>
	</div>
	<div class="authorbox__description">
		一个来自中国武汉的开发者，主要撰写软件开发和开源方面的文章。浏览我的<a href="%28/posts%29">博客文章</a>，订阅我的 <a href="/index.xml">RSS</a> 源，或了解更多<a href="/about/">关于我</a>的信息。
	</div>
</div>




	<p><h3>欢迎留言！</h3></p>
<div id="remark42"></div>
<script>
	var remark_config = {
		host: 'https:\/\/comment.chensoul.cc',
		site_id: 'remark',
		components: ['embed'],
		url: 'https:\/\/blog.chensoul.cc\/posts\/2023\/11\/16\/system-design-master-template\/',
		locale: 'zh'
	};

	!function(e, n) {
		for (var o = 0; o < e.length; o++) {
			var r = n.createElement('script'),
			c = '.js',
			d = n.head || n.body;
			'noModule' in r ? (r.type = 'module', c = '.mjs') : r.async = !0, r.defer = !0, r.src = remark_config.host + '/web/' + e[o] + c, d.appendChild(r)
		}
	}(remark_config.components || ['embed'], document);

</script>





			</div>
			

<aside class="sidebar sidebar--right">
	<div class="post__toc toc">
		<div class="toc__title">目录</div>
		<div class="toc__menu">
			<nav id="TableOfContents">
  <ul>
    <li><a href="#1-domain-name-system-dns">1. Domain Name System (DNS)</a></li>
    <li><a href="#2-load-balancer">2. Load Balancer</a></li>
    <li><a href="#3-api-gateway">3. API Gateway</a></li>
    <li><a href="#4-cdn">4. CDN</a></li>
    <li><a href="#5-forward-proxy-vs-reverse-proxy">5. Forward Proxy vs. Reverse Proxy</a></li>
    <li><a href="#6-caching">6. Caching</a></li>
    <li><a href="#7-data-partitioning">7. Data Partitioning</a></li>
    <li><a href="#8-database-replication">8. Database Replication</a></li>
    <li><a href="#9-distributed-messaging-systems">9. Distributed Messaging Systems</a></li>
    <li><a href="#10-microservices">10. Microservices</a></li>
    <li><a href="#11-nosql-databases">11. NoSQL Databases</a></li>
    <li><a href="#12-database-index">12. Database Index</a></li>
    <li><a href="#13-distributed-file-systems">13. Distributed File Systems</a></li>
    <li><a href="#14-notification-system">14. Notification System</a></li>
    <li><a href="#15-full-text-search">15. Full-text Search</a></li>
    <li><a href="#16-distributed-coordination-services">16. Distributed Coordination Services</a></li>
    <li><a href="#17-heartbeat">17. Heartbeat</a></li>
    <li><a href="#18-checksum">18. Checksum</a></li>
  </ul>
</nav>
		</div>
	</div>
</aside>

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
<div class="footer__links">
	<a class="footer__link" href="/">首页</a> | <a class="footer__link" href="/categories/">分类</a> | <a class="footer__link" href="/tags/">标签</a> | <a class="footer__link" href="/index.xml">订阅</a> | <a class="footer__link" href="/about/">关于</a>
</div>
		<div class="footer__copyright">
			&copy; 2025 ChenSoul.
			<span class="footer__copyright-credits">基于 <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> 引擎和 <a href="https://github.com/chensoul/rose-hugo/" rel="nofollow noopener" target="_blank">Rose Hugo</a> 主题</span>
		</div>
	</div>

	






<style>
	.scroll-up a {
		display: block;
		height: 3.125rem;
		width: 3.125rem;
		text-align: center;
		line-height: 2.7;
		border-radius: 50px;
		font-size: 1.125rem;
		color: #fff;
		opacity: 1;
		transition: all 0.3s ease 0s;
		box-shadow: 0 0 10px rgb(0 0 0 / 20%);
	}
	.scroll-up a {
		background: #ee591f;
	}
	.scroll-up {
		position: fixed;
		display: none;
		bottom: 50px;
		z-index: 999;
	}
	.scroll-up.right {
		right: 60px;
	}
</style>

<div class="scroll-up custom right" style="display: block;"><a href="#top" id="top-link" accesskey="g"><i
	class="fa fa-arrow-up"></i></a></div>

<script>
	var mybutton = document.getElementById("top-link");
	window.onscroll = function () {
		if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
			mybutton.style.visibility = "visible";
			mybutton.style.opacity = "1";
		} else {
			mybutton.style.visibility = "hidden";
			mybutton.style.opacity = "0";
		}
	};
</script>


    <script defer src="https://umami.chensoul.cc/random-string.js" data-website-id="1e07d36d-bec3-4ba6-9459-876b1ac3bbe7"></script>
</footer>


	</div>

	<script>
		'use strict';
		(function iifeMenu(document, window, undefined) {
			var menuBtn = document.querySelector('.menu__btn');
			var	menu = document.querySelector('.menu__list');
			function toggleMenu() {
				menu.classList.toggle('menu__list--active');
				menu.classList.toggle('menu__list--transition');
				this.classList.toggle('menu__btn--active');
				this.setAttribute(
					'aria-expanded',
					this.getAttribute('aria-expanded') === 'true' ? 'false' : 'true'
				);
			}
			function removeMenuTransition() {
				this.classList.remove('menu__list--transition');
			}
			if (menuBtn && menu) {
				menuBtn.addEventListener('click', toggleMenu, false);
				menu.addEventListener('transitionend', removeMenuTransition, false);
			}
		}(document, window));
	</script>
</body>
</html>