<!DOCTYPE html>
<html class="no-js" lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[译]2024年最好的WebSocket替代品 - Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="[译]2024年最好的WebSocket替代品">
	<meta property="og:description" content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps">
	<meta property="og:type" content="article">
	<meta property="og:url" content="https://blog.chensoul.cc/posts/2024/05/07/websocket-alternatives/">
	<meta property="og:site_name" content="ChenSoul Blog">
	<meta property="og:image" content="">
	
  <meta itemprop="name" content="[译]2024年最好的WebSocket替代品">
  <meta itemprop="description" content="原文链接：https://ably.com/topic/websocket-alternatives
什么是 WebSocket？ 简而言之，WebSocket 是一种实时 Web 技术，可通过持久连接在客户端和服务器之间实现双向、全双工通信。 WebSocket 连接会根据需要保持活动状态（理论上，它可以永远持续），从而允许服务器和客户端以最小的开销随意发送数据。">
  <meta itemprop="datePublished" content="2024-05-07T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-05-07T00:00:00+00:00">
  <meta itemprop="wordCount" content="436">
  <meta itemprop="keywords" content="Javascript,Backend,Tutorial,Translation">
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:title" content="[译]2024年最好的WebSocket替代品">
	<meta name="twitter:description" content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps">
	<meta name="twitter:image" content="">

	<link rel="preconnect" href="//fonts.loli.net" crossorigin>
	<link rel="dns-prefetch" href="//fonts.loli.net">
	<link rel="stylesheet" href="https://fonts.loli.net/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css" integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
	<link rel="stylesheet" href="/css/style.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="ChenSoul Blog" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="/logo.svg" loading="lazy" alt="Site logo" width="60" height="60">
				</div><div class="logo__item logo__text">
					<div class="logo__title">ChenSoul Blog</div>
					<div class="logo__tagline">Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">菜单</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/">
				
				<span class="menu__text">首页</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/categories/">
				
				<span class="menu__text">分类</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/tags/">
				
				<span class="menu__text">标签</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/index.xml">
				
				<span class="menu__text">订阅</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">关于</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[译]2024年最好的WebSocket替代品</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 1 1 0 28 1 1 0 0 1 0-28m0 3a3 3 0 1 0 0 22 3 3 0 0 0 0-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class="meta__text" datetime="2024-05-07">2024-05-07</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class="meta__text"><a class="meta__link" href="/categories/java/" rel="category">Java</a>
	</span>
</div><div class="meta__item-tags meta__item"><svg class="meta__icon icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg><span class="meta__text"><a class="meta__link" href="/tags/javascript/" rel="tag">Javascript</a>, <a class="meta__link" href="/tags/backend/" rel="tag">Backend</a>, <a class="meta__link" href="/tags/tutorial/" rel="tag">Tutorial</a>, <a class="meta__link" href="/tags/translation/" rel="tag">Translation</a>
	</span>
</div>
</div>
		</header>
		
		<div class="content post__content clearfix">
			<p>原文链接：<a href="https://ably.com/topic/websocket-alternatives" target="_blank">https://ably.com/topic/websocket-alternatives</a></p>
<h2 id="什么是-websocket">什么是 WebSocket？</h2>
<p>简而言之，WebSocket 是一种实时 Web 技术，可通过持久连接在客户端和服务器之间实现双向、全双工通信。 WebSocket 连接会根据需要保持活动状态（理论上，它可以永远持续），从而允许服务器和客户端以最小的开销随意发送数据。</p>
<p><img src="../../../static/images/websockets.webp" alt="img"></p>
<p>了解更多：</p>
<ul>
<li><a href="https://ably.com/topic/websockets" target="_blank">什么是 WebSocket？</a></li>
<li><a href="https://ably.com/topic/how-do-websockets-work" target="_blank">WebSocket 是如何工作的？</a></li>
</ul>
<h2 id="什么时候应该考虑使用-websocket-替代方案">什么时候应该考虑使用 WebSocket 替代方案？</h2>
<p>对于实时或近实时发送和使用数据至关重要（或至少是理想的）的用例，WebSocket 是一个绝佳的选择。示例包括<a href="https://ably.com/solutions/chat" target="_blank">聊天应用程序</a>、<a href="https://ably.com/solutions/multiplayer-collaboration" target="_blank">多人协作体验</a>以及<a href="https://ably.com/solutions/data-broadcast" target="_blank">广播实时路况更新</a>。</p>
<p><a href="https://ably.com/topic/what-are-websockets-used-for" target="_blank">了解有关 WebSocket 用例的更多信息</a></p>
<p>然而，很少有一种放之四海而皆准的协议：不同的协议比其他协议更好地服务于不同的目的。例如，如果您的应用程序严重依赖 CRUD 操作，并且用户不需要快速对更改做出反应，那么 HTTP 是比 WebSockets 更好的选择。另一个例子 - 如果您想传输音频和视频数据，WebRTC 是比 WebSockets 更好的选择。</p>
<p>我们要提到的最后一个例子：如果您只需要将文本（字符串）数据推送到浏览器客户端，并且您从不期望需要双向通信，那么您可以使用服务器发送事件（SSE）之类的东西。与 WebSocket 相比，SSE 的复杂性和要求较低，并且更易于扩展。</p>
<p><a href="https://ably.com/topic/websockets-pros-cons" target="_blank">了解 WebSocket 的优点和缺点</a></p>
<h2 id="websocket-协议的五种替代方案">WebSocket 协议的五种替代方案</h2>
<p>现在，我们将研究 WebSocket 协议的五种替代方案 - 您可以使用这些技术来构建实时应用程序，这些技术有些类似。</p>
<h3 id="服务器发送的事件">服务器发送的事件</h3>
<p><a href="https://ably.com/topic/server-sent-events" target="_blank">服务器发送事件 (SSE)</a>是一种 HTTP 服务器推送技术。这个想法很简单：浏览器客户端可以订阅服务器生成的事件流，并在新事件发生时接收更新。</p>
<p><img src="../../../static/images/server_sent_events_how_it_works.webp" alt="img"></p>
<p><strong>服务器发送事件的优点</strong></p>
<ul>
<li>内置对重新连接的支持。</li>
<li>所有现代浏览器都支持。</li>
<li>轻量级协议。</li>
</ul>
<p><strong>服务器发送事件的缺点</strong></p>
<ul>
<li>它是单向的；只有服务器可以将数据推送到客户端。</li>
<li>每个浏览器在同一时间只能有六个并发 SSE 连接。</li>
<li>仅支持UTF-8文本数据； SSE 无法处理二进制数据。</li>
</ul>
<p>对于不需要双向消息传递的场景（例如实时比分更新），SSE 是一个不错的选择。对于需要双向通信的用例，WebSocket 是更好的选择。</p>
<p><a href="https://ably.com/blog/websockets-vs-sse" target="_blank">查看 SSE 与 WebSocket 的比较</a></p>
<h3 id="长轮询">长轮询</h3>
<p><a href="https://ably.com/topic/long-polling" target="_blank">长轮询</a>是一种客户端拉取技术，它采用 HTTP 请求/响应轮询并使其更加高效。在长轮询中，服务器选择尽可能长时间地保持客户端连接打开，并在新数据可用或达到超时阈值时发送响应。</p>
<p><img src="../../../static/images/http-long-polling.webp" alt="img"></p>
<p><strong>长轮询的优点</strong></p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank">长轮询是在XMLHttpRequest</a>的基础上实现的，它几乎受到设备的普遍支持，因此通常不需要实现任何后备。</li>
<li>在必须处理异常的情况下，或者可以查询服务器以获取新数据但不支持长轮询（更不用说其他更现代的技术标准）时，基本轮询有时仍然具有有限的用途，并且可以使用XMLHttpRequest，或通过简单的 HTML 脚本标记通过 JSONP。</li>
</ul>
<p><strong>长轮询的缺点</strong></p>
<ul>
<li>与 WebSocket 相比，长轮询在服务器上消耗更多资源。</li>
<li>长轮询可能会带来延迟开销，因为它需要在服务器和设备之间进行多次跳跃。</li>
<li>可靠的消息排序可能是一个问题。</li>
</ul>
<p>长轮询是 WebSocket 的早期先驱。当谈到构建高性能、低延迟的实时应用程序时，WebSocket 几乎在各个方面都是一个优越的选择。这并不是说长轮询已经过时；而是说长轮询已经过时。在某些环境中，例如带有代理服务器的公司网络会阻止 WebSocket 连接。在这种情况下，长轮询作为 WebSocket 的后备机制非常有用。</p>
<p><a href="https://ably.com/blog/websockets-vs-long-polling" target="_blank">查看轮询与 WebSocket 相比需要多长时间</a></p>
<h3 id="mqtt">MQTT</h3>
<p><a href="https://ably.com/topic/mqtt" target="_blank">MQTT</a>（消息队列遥测传输）是一种<a href="https://ably.com/topic/pub-sub" target="_blank">发布-订阅</a>消息传递协议，其历史可以追溯到 1999 年，当时 IBM 的 Andy Stanley-Clark 和 Cirrus Link 的 Arlen Nipper<a href="http://mqtt.org/2009/07/10th-birthday-party" target="_blank">发布了第一个迭代</a>。</p>
<p>在 MQTT 架构中，我们有：</p>
<ul>
<li>发布者（生产者）和订阅者（消费者）。请注意，发布者也可以是订阅者。</li>
<li>充当中间件 MQTT 服务器的代理，管理发布者和订阅者之间的消息交换。</li>
</ul>
<p><img src="../../../static/images/mqtt-overview_2x.webp" alt="img"></p>
<p><strong>MQTT 优势</strong></p>
<ul>
<li>轻量级协议非常适合带宽有限或连接不可预测的网络以及 CPU、内存和电池寿命有限的设备。</li>
<li>可靠协议，具有三种不同级别的数据传递保证：0（最多传递一次）、1（至少传递一次）和2（恰好传递一次）。</li>
<li>双向且灵活 - 它提供一对一、一对多和多对多通信。</li>
</ul>
<p><strong>MQTT 缺点</strong></p>
<ul>
<li>对于发送照片、视频或音频数据来说不是一个好的选择。</li>
<li>您无法将 MQTT 消息发送到浏览器，因为 Web 浏览器没有内置 MQTT 支持。</li>
<li>基本 MQTT 协议不使用加密通信。某些 MQTT 代理允许您使用 MQTT over TLS 来增强安全性，但这会导致 CPU 使用率增加，这对于受限设备来说可能是一个问题。</li>
</ul>
<p>由于设计轻量，对于许多物联网用例（例如从温度或压力传感器实时收集数据）来说，MQTT 是比 WebSocket 更好的选择。但是，如前所述，MQTT 无法直接向浏览器发送消息。这就是为什么 WebSocket 通常被用作将 MQTT 数据流式传输到浏览器客户端的传输方式（基于 WebSocket 的 MQTT）。</p>
<p><img src="../../../static/images/mqtt-over-websocket-overview.webp" alt="img"></p>
<p><a href="https://ably.com/topic/mqtt-vs-websocket" target="_blank">查看 MQTT 与 WebSocket 的比较</a></p>
<h3 id="网络rtc">网络RTC</h3>
<p><a href="https://ably.com/blog/what-is-webrtc" target="_blank">Web 实时通信 (WebRTC)</a>是一个框架，可让您向 Web 和移动应用程序添加实时通信 (RTC) 功能。 WebRTC 允许<em>以点对点方式传输任意数据（视频、语音和通用数据）。</em></p>
<p><img src="../../../static/images/webrtc-logo-vert-retro.webp" alt="img"></p>
<p><strong>WebRTC优势</strong></p>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc3711" target="_blank">强大的安全保证，通过 WebRTC 传输的数据在安全实时传输协议 (SRTP)</a>的帮助下进行加密和验证。</li>
<li>开源且免费使用。</li>
<li>平台和设备无关； WebRTC 应用程序可以在任何支持 WebRTC 的浏览器上运行，无论操作系统或设备类型如何。</li>
</ul>
<p><strong>WebRTC 的缺点</strong></p>
<ul>
<li>尽管 WebRTC 是一种点对点技术，您仍然需要管理 Web 服务器并为其付费。为了使两个对等点能够相互“交谈”，您需要使用信令服务器来建立、管理和终止 WebRTC 通信会话。</li>
<li>在处理视频内容和大量用户时，WebRTC 可能会占用大量 CPU 资源。</li>
<li>WebRTC 入门很难。有很多概念需要探索和掌握：各种接口、编解码器、网络地址转换 (NAT) 和防火墙、UDP（WebRTC 使用的主要底层通信协议）等等。</li>
</ul>
<p>WebRTC 主要设计用于流式传输音频和视频内容（通过 UDP），在这种情况下通常是比 WebSocket 更好的选择。另一方面，当数据完整性（保证排序和交付）至关重要时，WebSocket 是更好的选择，因为您可以从 TCP 的底层可靠性中受益。</p>
<p>通常，WebRTC 和 WebSocket 是互补技术。 WebRTC 对等点通过称为信令的过程来协调通信。需要注意的是，WebRTC 不提供标准的信令实现，允许开发人员为此目的使用不同的协议。<em>WebSocket 协议通常用作 WebRTC 应用程序的信令机制</em>。</p>
<p><img src="../../../static/images/signaling-overview-webrtc-websockets_2x.webp" alt="img"></p>
<p><a href="https://ably.com/topic/webrtc-vs-websocket" target="_blank">了解 WebRTC 与 WebSocket 的比较</a></p>
<h3 id="网络传输">网络传输</h3>
<p><a href="https://ably.com/blog/can-webtransport-replace-websockets" target="_blank">WebTransport</a>是一项新兴的实时技术，通过<a href="https://ably.com/topic/http3" target="_blank">HTTP/3</a>提供客户端-服务器消息传递。 WebTransport 有两个关键概念：</p>
<ul>
<li><strong>数据报</strong>。数据报是一个独立的数据包，可以按任何特定顺序到达。专为需要低延迟且尽力而为的数据传输就足够好的用例而设计。</li>
<li><strong>溪流</strong>。 Streams API 提供可靠、有序的数据传输。请注意，您可以创建单向和双向流。</li>
</ul>
<p><strong>网络传输优势</strong></p>
<ul>
<li>通过使用 Datagrams API 或通过多个 Streams API 实例，您不必担心队头阻塞。</li>
<li>建立新连接非常快——这是因为 HTTP/3 在底层使用了 QUIC；众所周知，QUIC 握手比通过 TLS 启动 TCP 更快。</li>
</ul>
<p><strong>Web传输的缺点</strong></p>
<ul>
<li>WebTransport 仍然是一项新兴技术。截至 2022 年 11 月，<a href="https://w3c.github.io/webtransport/" target="_blank">WebTransport 是 W3C 的草案规范</a>，与其工作方式相关的方面始终有可能发生变化。</li>
<li><a href="https://caniuse.com/webtransport" target="_blank">并非所有浏览器都支持 WebTransport</a>。例如，您无法在 Firefox 和 Safari 中使用 WebTransport。</li>
</ul>
<p>与我们在本文中介绍的其他 WebSocket 替代方案（这些都是已经存在一段时间的成熟技术）不同，WebTransport 更像是 WebSocket 的未来潜在替代方案。我们不知道它在未来几年将如何发展，开发人员采用它的可能性有多大，或者它在生产就绪系统中使用时可能存在哪些陷阱。相比之下，WebSocket 已经存在十多年了；它是一种强大、稳定的技术，拥有庞大而活跃的社区，目前使其成为 WebTransport 的卓越替代品。</p>
<p><a href="https://ably.com/blog/can-webtransport-replace-websockets" target="_blank">了解有关 WebTransport 的更多信息</a></p>
<h2 id="websocket-及其替代方案头对头比较">WebSocket 及其替代方案：头对头比较</h2>
<p>下表显示了 WebSocket 与我们在本文中介绍的替代实时技术之间的主要区别和相似之处。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left"><strong>标准</strong></th>
          <th style="text-align: left"><strong>WebSockets</strong></th>
          <th style="text-align: left"><strong>长轮询</strong></th>
          <th style="text-align: left"><strong>上证所</strong></th>
          <th style="text-align: left"><strong>MQTT</strong></th>
          <th style="text-align: left"><strong>网络RTC</strong></th>
          <th style="text-align: left"><strong>网络传输</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">底层协议</td>
          <td style="text-align: left">传输控制协议</td>
          <td style="text-align: left">传输控制协议</td>
          <td style="text-align: left">传输控制协议</td>
          <td style="text-align: left">传输控制协议</td>
          <td style="text-align: left">UDP、TCP</td>
          <td style="text-align: left">WHO</td>
      </tr>
      <tr>
          <td style="text-align: left">双向？</td>
          <td style="text-align: left">是的</td>
          <td style="text-align: left">不</td>
          <td style="text-align: left">不</td>
          <td style="text-align: left">是的</td>
          <td style="text-align: left">是的</td>
          <td style="text-align: left">是的</td>
      </tr>
      <tr>
          <td style="text-align: left">潜伏</td>
          <td style="text-align: left">低的</td>
          <td style="text-align: left">高的</td>
          <td style="text-align: left">低的</td>
          <td style="text-align: left">低的</td>
          <td style="text-align: left">低的</td>
          <td style="text-align: left">低的</td>
      </tr>
      <tr>
          <td style="text-align: left">带宽</td>
          <td style="text-align: left">低的</td>
          <td style="text-align: left">高的</td>
          <td style="text-align: left">低的</td>
          <td style="text-align: left">低的</td>
          <td style="text-align: left">高的</td>
          <td style="text-align: left">高的</td>
      </tr>
      <tr>
          <td style="text-align: left">浏览器支持</td>
          <td style="text-align: left">广泛支持</td>
          <td style="text-align: left">广泛支持</td>
          <td style="text-align: left">广泛支持</td>
          <td style="text-align: left">浏览器没有内置的 MQTT 支持</td>
          <td style="text-align: left">Internet Explorer 和 Opera Mini 不支持</td>
          <td style="text-align: left">支持有限</td>
      </tr>
      <tr>
          <td style="text-align: left">使用方便</td>
          <td style="text-align: left">缓和</td>
          <td style="text-align: left">简单的</td>
          <td style="text-align: left">简单的</td>
          <td style="text-align: left">缓和</td>
          <td style="text-align: left">难的</td>
          <td style="text-align: left">简单的</td>
      </tr>
      <tr>
          <td style="text-align: left">到期</td>
          <td style="text-align: left">技术成熟</td>
          <td style="text-align: left">技术成熟</td>
          <td style="text-align: left">技术成熟</td>
          <td style="text-align: left">技术成熟</td>
          <td style="text-align: left">技术成熟</td>
          <td style="text-align: left">新兴科技</td>
      </tr>
      <tr>
          <td style="text-align: left">数据的完整性</td>
          <td style="text-align: left">高的</td>
          <td style="text-align: left">缓和</td>
          <td style="text-align: left">高的</td>
          <td style="text-align: left">高的</td>
          <td style="text-align: left">高的</td>
          <td style="text-align: left">高的</td>
      </tr>
      <tr>
          <td style="text-align: left">可扩展性</td>
          <td style="text-align: left">高的</td>
          <td style="text-align: left">缓和</td>
          <td style="text-align: left">高的</td>
          <td style="text-align: left">高的</td>
          <td style="text-align: left">低的</td>
          <td style="text-align: left">高的</td>
      </tr>
      <tr>
          <td style="text-align: left">它是干什么用的？</td>
          <td style="text-align: left">服务器和客户端之间的实时通信。</td>
          <td style="text-align: left">客户端发起的实时更新通信。</td>
          <td style="text-align: left">单向数据流（服务器推送）。</td>
          <td style="text-align: left">用于 IoT 和 M2M 通信的轻量级消息传递协议。</td>
          <td style="text-align: left">用于实时音频和视频流的点对点通信。</td>
          <td style="text-align: left">用于低延迟 Web 通信的多路复用传输协议。</td>
      </tr>
  </tbody>
</table>
<h2 id="使用多种协议提供实时体验">使用多种协议提供实时体验</h2>
<p>我们希望您发现本文对您发现 WebSocket 的潜在替代方案有所帮助。然而，现实情况是，许多生产就绪的实时系统不仅仅使用一种协议，而是多种协议的混合。</p>
<p>例如，如果您正在开发视频会议解决方案，WebRTC 是在对等点之间发送音频和视频数据的绝佳选择。在这种情况下，WebSocket 补充了 WebRTC，并经常用作WebRTC 对等方的<a href="https://ably.com/blog/solving-the-webrtc-signalling-challenge" target="_blank">信令机制</a>。</p>
<p>另一个例子：由于其轻量级设计，MQTT 是从物联网传感器收集遥测数据的绝佳选择。但是，如果您想使用这些数据来支持可以在浏览器中监控的实时仪表板，则 MQTT 不适合，因为浏览器不支持它。您可以做的就是通过 WebSocket 将数据发送到浏览器。这就是为什么现在许多 MQTT 代理也支持 WebSocket（或基于 WebSocket 的 MQTT）。</p>
<p>如果您确实决定使用 WebSocket 作为您的用例的主要传输协议，您仍然需要考虑支持后备传输，因为某些环境会阻止 WebSocket 连接（例如，限制性的公司网络）。 SSE 和长轮询通常用作 WebSocket 的后备方案。</p>
<h2 id="ably在任何规模下都能可靠运行的多协议实时平台">Ably，在任何规模下都能可靠运行的多协议实时平台</h2>
<p>Ably 是一家实时体验基础设施提供商。我们的 API 和 SDK 可帮助开发人员构建和提供实时体验，而无需担心维护和扩展混乱的实时基础设施。</p>
<p>Ably 的主要特性和功能：</p>
<ul>
<li>具有丰富功能的发布/订阅消息传递，例如消息增量压缩、连续性自动重新连接、用户状态、消息历史记录和消息交互。</li>
<li>多协议功能。 Ably 协议基于 WebSocket，但我们还支持长轮询作为后备、SSE、MQTT、AMQP、STOMP 和 HTTP/REST。</li>
<li>全球分布式数据中心网络和边缘加速接入点。</li>
<li>保证消息排序和传递。</li>
<li>全球容错和 99.999% 的正常运行时间 SLA。</li>
<li>&lt; 65 毫秒往返延迟 (P99)。</li>
<li>动态弹性，因此我们可以快速扩展以处理任何需求（发送到数百万个发布/订阅通道和客户端连接的数十亿条消息）。</li>
</ul>

		</div>


	</article>
</main>
<footer class="post__footer">
	

<div class="post-related">
	<h3>相关文章</h3>
	<ul class="post-related-list">
		
		<li class="post-related-item">
			<a href="/posts/2024/05/07/the-websocket-api-and-protocol-explained/" target="_blank" title="[译]WebSocket API和协议说明">[译]WebSocket API和协议说明</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/05/07/websockets-vs-http/" target="_blank" title="[译]WebSocket与HTTP：2024年为您的项目选择哪一个">[译]WebSocket与HTTP：2024年为您的项目选择哪一个</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/05/07/http3/" target="_blank" title="[译]什么是HTTP/3？">[译]什么是HTTP/3？</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/05/07/socket-io/" target="_blank" title="[译]什么是Socket.IO？">[译]什么是Socket.IO？</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/05/07/websockets/" target="_blank" title="[译]什么是WebSocket？">[译]什么是WebSocket？</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/05/07/thingsboard-domain/" target="_blank" title="ThingsBoard的领域模型">ThingsBoard的领域模型</a>
		</li>
		
	</ul>
</div>

</footer>

<footer class="post__footer">
	<footer class="post__footer">
		
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/javascript/" rel="tag">javascript</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/backend/" rel="tag">backend</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/tutorial/" rel="tag">tutorial</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/translation/" rel="tag">translation</a>
		</li>
	</ul>
</div>
	</footer>
</footer>


<nav class="pagination flex">
	<div class="pagination__item pagination__item--prev">
		<a class="pagination__link" href="/posts/2024/05/07/apache-kafka-vs-rabbitmq-vs-aws-sns-sqs/" rel="prev">
			<p class="pagination__title">«&thinsp;上一篇: [译]Apache Kafka、RabbitMQ 与 AWS SNSSQS：哪个消息代理最好？</p>
		</a>
	</div>
	<div class="pagination__item pagination__item--next">
		<a class="pagination__link" href="/posts/2024/05/08/exploring-http2-part-2-overview/" rel="next">
			<p class="pagination__title">&thinsp;» 下一篇: [译]探索 http2（第 2 部分）：使用 node-http2 核心和 hapijs</p>
		</a>
	</div>
</nav>



<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="ChenSoul avatar" src="/avatar.jpg" class="avatar" height="60" width="60" loading="lazy">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">关于 ChenSoul</span>
	</div>
	<div class="authorbox__description">
		一个来自中国武汉的开发者，主要撰写软件开发和开源方面的文章。浏览我的<a href="%28/posts%29">博客文章</a>，订阅我的 <a href="/index.xml">RSS</a> 源，或了解更多<a href="/about/">关于我</a>的信息。
	</div>
</div>




	<p><h3>欢迎留言！</h3></p>
<div id="remark42"></div>
<script>
	var remark_config = {
		host: 'https:\/\/comment.chensoul.cc',
		site_id: 'remark',
		components: ['embed'],
		url: 'https:\/\/blog.chensoul.cc\/posts\/2024\/05\/07\/websocket-alternatives\/',
		locale: 'zh'
	};

	!function(e, n) {
		for (var o = 0; o < e.length; o++) {
			var r = n.createElement('script'),
			c = '.js',
			d = n.head || n.body;
			'noModule' in r ? (r.type = 'module', c = '.mjs') : r.async = !0, r.defer = !0, r.src = remark_config.host + '/web/' + e[o] + c, d.appendChild(r)
		}
	}(remark_config.components || ['embed'], document);

</script>





			</div>
			

<aside class="sidebar sidebar--right">
	<div class="post__toc toc">
		<div class="toc__title">目录</div>
		<div class="toc__menu">
			<nav id="TableOfContents">
  <ul>
    <li><a href="#什么是-websocket">什么是 WebSocket？</a></li>
    <li><a href="#什么时候应该考虑使用-websocket-替代方案">什么时候应该考虑使用 WebSocket 替代方案？</a></li>
    <li><a href="#websocket-协议的五种替代方案">WebSocket 协议的五种替代方案</a>
      <ul>
        <li><a href="#服务器发送的事件">服务器发送的事件</a></li>
        <li><a href="#长轮询">长轮询</a></li>
        <li><a href="#mqtt">MQTT</a></li>
        <li><a href="#网络rtc">网络RTC</a></li>
        <li><a href="#网络传输">网络传输</a></li>
      </ul>
    </li>
    <li><a href="#websocket-及其替代方案头对头比较">WebSocket 及其替代方案：头对头比较</a></li>
    <li><a href="#使用多种协议提供实时体验">使用多种协议提供实时体验</a></li>
    <li><a href="#ably在任何规模下都能可靠运行的多协议实时平台">Ably，在任何规模下都能可靠运行的多协议实时平台</a></li>
  </ul>
</nav>
		</div>
	</div>
</aside>

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
<div class="footer__links">
	<a class="footer__link" href="/">首页</a> | <a class="footer__link" href="/categories/">分类</a> | <a class="footer__link" href="/tags/">标签</a> | <a class="footer__link" href="/index.xml">订阅</a> | <a class="footer__link" href="/about/">关于</a>
</div>
		<div class="footer__copyright">
			&copy; 2025 ChenSoul.
			<span class="footer__copyright-credits">基于 <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> 引擎和 <a href="https://github.com/chensoul/rose-hugo/" rel="nofollow noopener" target="_blank">Rose Hugo</a> 主题</span>
		</div>
	</div>

	






<style>
	.scroll-up a {
		display: block;
		height: 3.125rem;
		width: 3.125rem;
		text-align: center;
		line-height: 2.7;
		border-radius: 50px;
		font-size: 1.125rem;
		color: #fff;
		opacity: 1;
		transition: all 0.3s ease 0s;
		box-shadow: 0 0 10px rgb(0 0 0 / 20%);
	}
	.scroll-up a {
		background: #ee591f;
	}
	.scroll-up {
		position: fixed;
		display: none;
		bottom: 50px;
		z-index: 999;
	}
	.scroll-up.right {
		right: 60px;
	}
</style>

<div class="scroll-up custom right" style="display: block;"><a href="#top" id="top-link" accesskey="g"><i
	class="fa fa-arrow-up"></i></a></div>

<script>
	var mybutton = document.getElementById("top-link");
	window.onscroll = function () {
		if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
			mybutton.style.visibility = "visible";
			mybutton.style.opacity = "1";
		} else {
			mybutton.style.visibility = "hidden";
			mybutton.style.opacity = "0";
		}
	};
</script>


    <script defer src="https://umami.chensoul.cc/random-string.js" data-website-id="1e07d36d-bec3-4ba6-9459-876b1ac3bbe7"></script>
</footer>


	</div>

	<script>
		'use strict';
		(function iifeMenu(document, window, undefined) {
			var menuBtn = document.querySelector('.menu__btn');
			var	menu = document.querySelector('.menu__list');
			function toggleMenu() {
				menu.classList.toggle('menu__list--active');
				menu.classList.toggle('menu__list--transition');
				this.classList.toggle('menu__btn--active');
				this.setAttribute(
					'aria-expanded',
					this.getAttribute('aria-expanded') === 'true' ? 'false' : 'true'
				);
			}
			function removeMenuTransition() {
				this.classList.remove('menu__list--transition');
			}
			if (menuBtn && menu) {
				menuBtn.addEventListener('click', toggleMenu, false);
				menu.addEventListener('transitionend', removeMenuTransition, false);
			}
		}(document, window));
	</script>
</body>
</html>