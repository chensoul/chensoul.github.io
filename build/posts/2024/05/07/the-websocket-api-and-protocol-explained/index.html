<!DOCTYPE html>
<html class="no-js" lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[译]WebSocket API和协议说明 - Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="[译]WebSocket API和协议说明">
	<meta property="og:description" content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps">
	<meta property="og:type" content="article">
	<meta property="og:url" content="https://blog.chensoul.cc/posts/2024/05/07/the-websocket-api-and-protocol-explained/">
	<meta property="og:site_name" content="ChenSoul Blog">
	<meta property="og:image" content="">
	
  <meta itemprop="name" content="[译]WebSocket API和协议说明">
  <meta itemprop="description" content="原文地址：https://ably.com/topic/websockets
WebSocket 标志着 Web 开发的转折点。 WebSocket 技术旨在以事件为驱动，并针对低延迟进行了优化，已成为许多寻求构建交互式实时数字体验以提供令人愉悦的用户体验的组织和开发人员的首选。本文探讨了与 WebSocket 相关的关键主题：">
  <meta itemprop="datePublished" content="2024-05-07T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-05-07T00:00:00+00:00">
  <meta itemprop="wordCount" content="1016">
  <meta itemprop="keywords" content="Javascript,Backend,Tutorial,Translation">
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:title" content="[译]WebSocket API和协议说明">
	<meta name="twitter:description" content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps">
	<meta name="twitter:image" content="">

	<link rel="preconnect" href="//fonts.loli.net" crossorigin>
	<link rel="dns-prefetch" href="//fonts.loli.net">
	<link rel="stylesheet" href="https://fonts.loli.net/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css" integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
	<link rel="stylesheet" href="/css/style.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="ChenSoul Blog" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="/logo.svg" loading="lazy" alt="Site logo" width="60" height="60">
				</div><div class="logo__item logo__text">
					<div class="logo__title">ChenSoul Blog</div>
					<div class="logo__tagline">Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">菜单</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/">
				
				<span class="menu__text">首页</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/categories/">
				
				<span class="menu__text">分类</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/tags/">
				
				<span class="menu__text">标签</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/index.xml">
				
				<span class="menu__text">订阅</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">关于</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[译]WebSocket API和协议说明</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 1 1 0 28 1 1 0 0 1 0-28m0 3a3 3 0 1 0 0 22 3 3 0 0 0 0-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class="meta__text" datetime="2024-05-07">2024-05-07</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class="meta__text"><a class="meta__link" href="/categories/java/" rel="category">Java</a>
	</span>
</div><div class="meta__item-tags meta__item"><svg class="meta__icon icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg><span class="meta__text"><a class="meta__link" href="/tags/javascript/" rel="tag">Javascript</a>, <a class="meta__link" href="/tags/backend/" rel="tag">Backend</a>, <a class="meta__link" href="/tags/tutorial/" rel="tag">Tutorial</a>, <a class="meta__link" href="/tags/translation/" rel="tag">Translation</a>
	</span>
</div>
</div>
		</header>
		
		<div class="content post__content clearfix">
			<p>原文地址：<a href="https://ably.com/topic/websockets" target="_blank">https://ably.com/topic/websockets</a></p>
<p>WebSocket 标志着 Web 开发的转折点。 WebSocket 技术旨在以事件为驱动，并针对低延迟进行了优化，已成为许多寻求构建交互式实时数字体验以提供令人愉悦的用户体验的组织和开发人员的首选。本文探讨了与 WebSocket 相关的关键主题：</p>
<ul>
<li>
<p><a href="https://ably.com/topic/websockets#web-sockets-the-web-socket-protocol-and-api-explained" target="_blank">WebSocket 协议和 API 解释</a></p>
</li>
<li>
<p><a href="https://ably.com/topic/websockets#how-do-web-sockets-work" target="_blank">WebSockets 是如何工作的？</a></p>
</li>
<li>
<p><a href="https://ably.com/topic/websockets#what-are-the-pros-and-cons-of-web-sockets" target="_blank">WebSockets的优缺点是什么？</a></p>
</li>
<li>
<p><a href="https://ably.com/topic/websockets#are-web-sockets-scalable" target="_blank">WebSockets 是否可扩展？</a></p>
</li>
<li>
<p><a href="https://ably.com/topic/websockets#what-are-web-sockets-used-for" target="_blank">WebSocket 的用途是什么？</a></p>
</li>
<li>
<p><a href="https://ably.com/topic/websockets#what-are-the-best-alternatives-to-web-sockets" target="_blank">WebSockets 的最佳替代品是什么？</a></p>
</li>
<li>
<p><a href="https://ably.com/topic/websockets#how-to-start-building-realtime-experiences-with-web-sockets" target="_blank">如何开始使用 WebSockets 构建实时体验</a></p>
</li>
<li>
<p><a href="https://ably.com/topic/websockets#web-sockets-fa-qs" target="_blank">WebSocket 常见问题解答</a></p>
</li>
</ul>
<h2 id="websocket协议和-api-解释">WebSocket：协议和 API 解释</h2>
<p>WebSocket 是一种实时技术，可通过持久的单套接字连接在客户端和服务器之间实现双向全双工通信。只要需要，WebSocket 连接就会保持活动状态（理论上，它可以永远持续下去），允许服务器和客户端随意发送数据，开销最小。</p>
<p>WebSocket 技术由两个核心构建块组成：</p>
<ul>
<li>WebSocket 协议。</li>
<li>WebSocket API。</li>
</ul>
<h3 id="websocket的历史是什么">WebSocket的历史是什么？</h3>
<p>第一个实时 Web 应用程序开始出现在 2000 年代，试图提供响应迅速、动态和交互式的最终用户体验。然而，在那个时候，实时网络很难实现，而且比我们现在习惯的要慢;它是通过入侵现有的基于HTTP的技术（AJAX和Comet）来实现的，这些技术不是为实时应用程序设计和优化的。很明显，需要一个更好的替代方案。</p>
<p>在 2008 年，开发人员 Michael Carter 和 Ian Hickson 特别敏锐地感受到了在实现任何类似实时的东西时使用 AJAX 和 Comet 的痛苦和局限性。通过在 <a href="https://krijnhoetmer.nl/irc-logs/whatwg/20080618#l-1145" target="_blank">IRC</a> 和 <a href="https://lists.w3.org/Archives/Public/public-whatwg-archive/2008Jun/0165.html" target="_blank">W3C 邮件列表</a>上的合作，他们提出了一个计划，为网络上的现代、真正的实时通信引入一个新标准。<a href="https://lists.w3.org/Archives/Public/public-whatwg-archive/2008Jun/0186.html" target="_blank">因此，“WebSocket”这个名字被创造出来</a>。</p>
<h3 id="什么是-websocket-协议">什么是 WebSocket 协议？</h3>
<p>WebSocket 协议支持 Web 客户端和 Web 服务器之间通过基础 TCP 连接进行持续的全双工双向通信。该协议旨在允许客户端和服务器实时通信，从而在 Web 应用程序中实现高效且响应迅速的数据传输。</p>
<p>2011 年 12 月，互联网工程任务组 （IETF） 通过 <a href="https://www.rfc-editor.org/rfc/rfc6455" target="_blank">RFC 6455</a> 对 WebSocket 协议进行了标准化。互联网号码分配机构 （IANA） 与 IETF 协调维护 <a href="https://www.iana.org/assignments/websocket/websocket.xml" target="_blank">WebSocket 协议注册管理机构</a>，该注册管理机构定义了协议使用的许多代码和参数标识符。</p>
<h3 id="什么是-websocket-api">什么是 WebSocket API？</h3>
<p>WebSocket API 包含在 <a href="https://websockets.spec.whatwg.org/" target="_blank">HTML Living Standard</a> 中，是一个编程接口，用于创建 WebSocket 连接并管理 Web 应用程序中客户端和服务器之间的数据交换。它为开发人员提供了一种简单且标准化的方法，可以在其应用程序中使用 WebSocket 协议。</p>
<p>如今，几乎所有现代浏览器都支持 WebSocket API。此外，还有许多框架和库（包括开源和商业解决方案）实现了 WebSocket API。</p>
<h2 id="websocket-的用途是什么">WebSocket 的用途是什么？</h2>
<p>WebSocket 提供低延迟通信功能，适用于各种类型的实时用例。例如，可以使用 WebSockets 执行以下操作：</p>
<ul>
<li>强大的实时聊天体验。</li>
<li>广播实时事件数据，例如实时比分和流量更新。</li>
<li>促进共享项目和白板上的多人协作。</li>
<li>发送通知和警报。</li>
<li>让您的后端和前端保持实时同步。</li>
<li>为城市交通和送餐应用添加实时位置跟踪功能。</li>
</ul>
<p><img src="../../../static/images/websocket-main-use-cases.webp" alt="img"></p>
<h2 id="websockets-是如何工作的">WebSockets 是如何工作的？</h2>
<p>概括地说，使用 WebSockets 涉及三个主要步骤：</p>
<ul>
<li>打开 WebSocket 连接。建立 WebSocket 连接的过程称为开始握手，由客户端和服务器之间的 HTTP 请求/响应交换组成。有关详细信息，请参阅<a href="https://ably.com/topic/how-do-websockets-work#how-to-establish-a-web-socket-connection" target="_blank">如何建立 WebSocket 连接</a>。</li>
<li>通过WebSocket进行数据传输。成功打开握手后，客户端和服务器可以通过持久 WebSocket 连接交换消息（帧）。WebSocket 消息可能包含字符串（纯文本）或二进制数据。<a href="https://ably.com/topic/how-do-websockets-work#how-to-transmit-data-over-web-sockets" target="_blank">详细了解通过 WebSocket 传输数据</a>。</li>
<li>关闭 WebSocket 连接。一旦持久的 WebSocket 连接达到其目的，它就可以终止;客户端和服务器都可以通过发送关闭消息来启动关闭握手。<a href="https://ably.com/topic/how-do-websockets-work#how-to-close-web-socket-connections" target="_blank">阅读有关关闭 WebSocket 连接的详细信息</a>。</li>
</ul>
<p><img src="../../../static/images/websockets-02.webp" alt="img"></p>
<h3 id="如何建立-websocket-连接">如何建立 WebSocket 连接</h3>
<h4 id="在-websocket-协议级别建立连接">在 WebSocket 协议级别建立连接</h4>
<p>根据 <a href="https://www.rfc-editor.org/rfc/rfc6455" target="_blank">WebSocket 协议规范</a>，建立 WebSocket 连接的过程称为打开握手，由客户端和服务器之间的 HTTP/1.1 请求/响应交换组成。客户端始终发起握手;它向服务器发送请求 <code>GET</code> ，指示它想要将连接从 HTTP 协议升级到 WebSocket。</p>
<p>下面是客户端发出的启动开场握手 <code>GET</code> 的请求的基本示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HTML" data-lang="HTML"><span style="display:flex;"><span>GET wss://example.com:8181/ HTTP/1.1
</span></span><span style="display:flex;"><span>Host: localhost: 8181
</span></span><span style="display:flex;"><span>Connection: Upgrade
</span></span><span style="display:flex;"><span>Upgrade: websocket
</span></span><span style="display:flex;"><span>Sec-WebSocket-Version: 13
</span></span><span style="display:flex;"><span>Sec-WebSocket-Key: zy6Dy9mSAIM7GJZNf9rI1A==
</span></span></code></pre></div><p>服务器必须返回响应 <code>HTTP 101 Switching Protocols</code> 代码才能成功建立 WebSocket 连接：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HTML" data-lang="HTML"><span style="display:flex;"><span>HTTP/1.1 101 Switching Protocols
</span></span><span style="display:flex;"><span>Connection: Upgrade
</span></span><span style="display:flex;"><span>Sec-WebSocket-Accept: EDJa7WCAQQzMCYNJM42Syuo9SqQ=
</span></span><span style="display:flex;"><span>Upgrade: websocket
</span></span></code></pre></div><p><strong>打开握手标头</strong></p>
<p>下表描述了客户端和服务器在打开握手期间使用的标头 - 包括必需的标头（在上面的代码片段中进行了说明）和可选标头。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left"><strong>Header</strong></th>
          <th style="text-align: left"><strong>Required</strong></th>
          <th style="text-align: left"><strong>Description</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><code>Host</code></td>
          <td style="text-align: left">Yes</td>
          <td style="text-align: left">主机名，以及请求发送到的服务器的端口号（可选）。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>Connection</code></td>
          <td style="text-align: left">Yes</td>
          <td style="text-align: left">指示客户端希望协商更改连接的使用方式。值必须为 <code>Upgrade</code> 。Also returned by the server. 也由服务器返回。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>Sec-WebSocket-Version</code></td>
          <td style="text-align: left">Yes</td>
          <td style="text-align: left">唯一接受的值是 13。在此标头中传递的任何其他版本都是无效的。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>Sec-WebSocket-Key</code></td>
          <td style="text-align: left">Yes</td>
          <td style="text-align: left">客户端发送的 base64 编码的一次性随机值（随机数）。由大多数 WebSocket 库或使用浏览器中提供的 WebSocket 类自动为您处理。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>Sec-WebSocket-Accept</code></td>
          <td style="text-align: left">Yes</td>
          <td style="text-align: left">服务器返回的 base64 编码的 SHA-1 哈希值，作为对 <code>Sec-WebSocket-Key</code> 的直接响应。Indicates that the server is willing to initiate the WebSocket connection.  指示服务器愿意启动 WebSocket 连接。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>Sec-WebSocket-Protocol</code></td>
          <td style="text-align: left">No</td>
          <td style="text-align: left">可选标头字段，包含一个值列表，这些值指示客户端要发言的子协议，按首选项排序。服务器需要在响应中将此字段与选定的子协议值之一（列表中支持的第一个值）一起包含。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>Sec-WebSocket-Extensions</code></td>
          <td style="text-align: left">No</td>
          <td style="text-align: left">可选标头字段，最初从客户端发送到服务器，然后从服务器发送到客户端。它帮助客户端和服务器就一组协议级扩展达成一致，以便在连接期间使用。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>Origin</code></td>
          <td style="text-align: left">No</td>
          <td style="text-align: left">所有浏览器客户端发送的标头字段（对于非浏览器客户端是可选的）。用于防止在 Web 浏览器中使用 WebSocket API 的脚本未经授权跨域使用 WebSocket 服务器。如果 <code>Origin</code> 指示的连接对服务器不可接受，则连接将被拒绝。</td>
      </tr>
  </tbody>
</table>
<p><strong>Sec-WebSocket-Key 和 Sec-WebSocket-Accept</strong></p>
<p>值得一提的是，有关 WebSocket 握手期间使用的两个必需标头的更多详细信息： <code>Sec-WebSocket-Key</code> 和 <code>Sec-WebSocket-Accept</code> .总之，这些标头对于保证服务器和客户端都能够通过 WebSocket 进行通信至关重要。</p>
<p>首先，我们有 <code>Sec-WebSocket-Key</code> ，它由客户端传递给服务器，并包含一个 16 字节、base64 编码的一次性随机值（nonce）。其目的是帮助确保服务器不接受来自非 WebSocket 客户端（例如 HTTP 客户端）的连接，这些客户端被滥用（或配置错误）以将数据发送到毫无戒心的 WebSocket 服务器。下面是一个示例 <code>Sec-WebSocket-Key</code> ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HTML" data-lang="HTML"><span style="display:flex;"><span>Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
</span></span></code></pre></div><p>与 直接相关的是 <code>Sec-WebSocket-Key</code> ，服务器响应包括一个 <code>Sec-WebSocket-Accept</code> 标头。此标头包含通过连接客户端发送的 <code>Sec-WebSocket-Key</code> 随机数和静态值 （UUID） <code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code> 生成的 base64 编码的 SHA-1 哈希值。</p>
<p>根据上面提供的 <code>Sec-WebSocket-Key</code> 示例，下面是服务器返回的 <code>Sec-WebSocket-Accept</code> 标头：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HTML" data-lang="HTML"><span style="display:flex;"><span>Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
</span></span></code></pre></div><h4 id="在-websocket-api-级别建立连接">在 WebSocket API 级别建立连接</h4>
<p>浏览器（以及大多数 WebSocket 库）中的 WebSocket API 会自动为您处理开场握手。您所要做的就是实例化 <code>WebSocket</code> 对象，该对象将自动尝试打开与服务器的连接：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Javascript" data-lang="Javascript"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">socket</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WebSocket</span>(<span style="color:#e6db74">&#39;wss://example.org&#39;</span>);
</span></span></code></pre></div><p>建立 WebSocket 连接时会引发 <code>open</code> 事件。它表示客户端和服务器之间的打开握手成功，现在可以使用 WebSocket 连接来发送和接收数据。下面是一个示例（请注意， <code>open</code> 该事件是通过 <code>onopen</code> 属性处理的）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Javascript" data-lang="Javascript"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">/ Create WebSocket connection</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">socket</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WebSocket</span>(<span style="color:#e6db74">&#39;wss://example.org&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">/ Connection opened</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">socket</span>.<span style="color:#a6e22e">onopen</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">e</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;Connection open!&#39;</span>);
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="如何通过-websocket-传输数据">如何通过 WebSocket 传输数据</h3>
<h4 id="数据传输协议级注意事项">数据传输：协议级注意事项</h4>
<p>成功打开握手后，客户端和服务器可以使用 WebSocket 连接在全双工模式下交换消息。WebSocket 消息由一个或多个帧组成。</p>
<p>WebSocket 帧采用二进制语法，包含多条信息，如下图所示：</p>
<p><img src="../../../static/images/wss-ebook-websocket-frame.webp" alt="img"></p>
<p><strong>FIN钻头和碎片</strong></p>
<p>在许多情况下，需要将 WebSocket 消息分段为多个帧（或至少是可取的）。例如，碎片化通常用于提高性能。如果没有碎片，终结点在发送消息之前必须缓冲整个消息。通过分段，端点可以选择一个大小合理的缓冲区，当缓冲区已满时，将后续帧作为延续发送。然后，接收端点组装帧以重新创建 WebSocket 消息。</p>
<p>以下是单帧消息的样子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HTML" data-lang="HTML"><span style="display:flex;"><span>0x81 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains &#34;Hello&#34;)
</span></span></code></pre></div><p>相比之下，对于碎片化，相同的消息将如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HTML" data-lang="HTML"><span style="display:flex;"><span>0x01 0x03 0x48 0x65 0x6c (contains &#34;Hel&#34;)
</span></span><span style="display:flex;"><span>0x80 0x02 0x6c 0x6f (contains &#34;lo&#34;)
</span></span></code></pre></div><p><strong>RSV 1-3</strong></p>
<p><code>RSV1</code> 、 <code>RSV2</code> 和 <code>RSV3</code> 是保留位。它们必须为 0，除非在开始握手期间协商了定义非零值的扩展。</p>
<p><strong>Opcodes</strong></p>
<p>每个帧都有一个操作码，用于确定如何解释该帧的有效载荷数据。当前使用的标准操作码由 RFC 6455 定义，并由互联网号码分配机构 （IANA） 维护。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left"><strong>Opcode</strong></th>
          <th style="text-align: left"><strong>Description</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><code>0</code></td>
          <td style="text-align: left">延续框架;继续上一帧的有效载荷。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>1</code></td>
          <td style="text-align: left">指示文本框架（UTF-8 文本数据）。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>2</code></td>
          <td style="text-align: left">指示二进制帧。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>3-7</code></td>
          <td style="text-align: left">为自定义数据框保留。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>8</code></td>
          <td style="text-align: left">连接闭合框架;导致连接终止。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>9</code></td>
          <td style="text-align: left">ping 帧。用作确保连接仍处于活动状态的心跳机制。接收器必须以乒乓球框架进行响应。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>10</code></td>
          <td style="text-align: left">pong 帧。用作确保连接仍处于活动状态的心跳机制。在收到 ping 帧后作为响应发送。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>11-15</code></td>
          <td style="text-align: left">保留用于自定义控制帧。</td>
      </tr>
  </tbody>
</table>
<p><strong>Masking</strong></p>
<p>客户端发送到服务器的每个 WebSocket 帧都需要借助随机 <code>masking-key</code> （32 位值）进行屏蔽。此键包含在帧中，用于混淆有效负载数据。但是，当数据以相反的方式流动时，服务器不得屏蔽它发送到客户端的任何帧。</p>
<p>在服务器端，在进一步处理之前，必须取消屏蔽从客户端接收的帧。下面是一个示例，说明如何做到这一点：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Javascript" data-lang="Javascript"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">unmask</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">mask</span>, <span style="color:#a6e22e">buffer</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">payload</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Buffer</span>(<span style="color:#a6e22e">buffer</span>.<span style="color:#a6e22e">length</span>);
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">buffer</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>       <span style="color:#a6e22e">payload</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">mask</span>[<span style="color:#a6e22e">i</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span>] <span style="color:#f92672">^</span> <span style="color:#a6e22e">buffer</span>[<span style="color:#a6e22e">i</span>];
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">payload</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>有效载荷长度和有效载荷数据</strong>WebSocket 协议使用可变字节数对有效负载数据的长度进行编码：</p>
<ul>
<li>对于 &lt;126 字节的有效负载，长度将打包到前两个帧标头字节中。</li>
<li>对于 126 字节的有效负载，使用两个额外的标头字节来指示长度。</li>
<li>如果有效负载为 127 字节，则使用另外 8 个标头字节来指示其长度。
WebSocket 协议支持两种类型的有效负载数据：文本（UTF-8 Unicode 文本）和二进制。</li>
</ul>
<h4 id="使用-websocket-api-进行数据传输">使用 WebSocket API 进行数据传输</h4>
<p>WebSocket 编程遵循异步、事件驱动的编程模型。只要 WebSocket 连接处于打开状态，客户端和服务器就只需侦听事件，即可处理传入数据和连接状态更改（无需轮询）。</p>
<p>当通过 WebSocket 接收数据时，将触发该 <code>message</code> 事件。消息可能包含字符串（纯文本）或二进制数据，如何处理和可视化这些数据取决于您。</p>
<p>下面是如何处理 <code>message</code> 事件的示例（使用属性 <code>onmessage</code> ）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Javascript" data-lang="Javascript"><span style="display:flex;"><span><span style="color:#a6e22e">socket</span>.<span style="color:#a6e22e">onmessage</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">msg</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">msg</span>.<span style="color:#a6e22e">data</span> <span style="color:#66d9ef">instanceof</span> <span style="color:#a6e22e">ArrayBuffer</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">processArrayBuffer</span>(<span style="color:#a6e22e">msg</span>.<span style="color:#a6e22e">data</span>);
</span></span><span style="display:flex;"><span>   } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">processText</span>(<span style="color:#a6e22e">msg</span>.<span style="color:#a6e22e">data</span>);
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><p>要通过 WebSocket API 发送消息，您必须使用该 <code>send()</code> 方法，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Javascript" data-lang="Javascript"><span style="display:flex;"><span><span style="color:#a6e22e">socket</span>.<span style="color:#a6e22e">onopen</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">e</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">socket</span>.<span style="color:#a6e22e">send</span>(<span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">stringify</span>({<span style="color:#e6db74">&#39;msg&#39;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;payload&#39;</span>}));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的示例代码演示如何发送文本（字符串）消息。但是，除了字符串之外，您还可以发送二进制数据（ <code>Blob</code> 或 <code>ArrayBuffer</code> ）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Javascript" data-lang="Javascript"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">buffer</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ArrayBuffer</span>(<span style="color:#ae81ff">128</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">socket</span>.<span style="color:#a6e22e">send</span>(<span style="color:#a6e22e">buffer</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">intview</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Uint32Array</span>(<span style="color:#a6e22e">buffer</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">socket</span>.<span style="color:#a6e22e">send</span>(<span style="color:#a6e22e">intview</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">blob</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Blob</span>([<span style="color:#a6e22e">buffer</span>]);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">socket</span>.<span style="color:#a6e22e">send</span>(<span style="color:#a6e22e">blob</span>);
</span></span></code></pre></div><h3 id="如何关闭-websocket-连接">如何关闭 WebSocket 连接</h3>
<h4 id="在协议级别关闭-websocket-连接">在协议级别关闭 WebSocket 连接</h4>
<p>关闭 WebSocket 连接的过程称为关闭握手。您可以通过发送操作码为 的 <code>close</code> <code>8</code> 帧来启动它。除了操作码之外，关闭帧还可能包含指示关闭原因的正文。此正文由状态代码（整数）和 UTF-8 编码字符串（原因）组成。</p>
<p>在结束握手期间可以使用的标准状态代码由 RFC 6455 定义，并在下表中列出：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">**Status code</th>
          <th style="text-align: left"><strong>Name</strong></th>
          <th style="text-align: left"><strong>Description</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><code>0-999</code></td>
          <td style="text-align: left">N/A</td>
          <td style="text-align: left">低于 1000 的代码无效，不能使用。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>1000</code></td>
          <td style="text-align: left">正常闭合</td>
          <td style="text-align: left">指示正常闭包，表示已实现建立 WebSocket 连接的目的。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>1001</code></td>
          <td style="text-align: left">离开</td>
          <td style="text-align: left">应在关闭连接时使用，并且不会尝试后续连接（例如，服务器关闭或浏览器离开页面）。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>1002</code></td>
          <td style="text-align: left">协议错误</td>
          <td style="text-align: left">由于协议错误，终结点正在终止连接。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>1003</code></td>
          <td style="text-align: left">不支持的数据</td>
          <td style="text-align: left">连接被终止，因为端点接收到它无法处理的数据类型（例如，接收二进制数据的纯文本端点）。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>1004</code></td>
          <td style="text-align: left">Reserved</td>
          <td style="text-align: left">Reserved. A meaning might be defined in the future.  保留。将来可能会定义一个含义。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>1005</code></td>
          <td style="text-align: left">未收到状态</td>
          <td style="text-align: left">应用和 WebSocket API 用于指示未收到状态代码，尽管预期会收到状态代码。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>1006</code></td>
          <td style="text-align: left">异常闭合</td>
          <td style="text-align: left">由应用和 WebSocket API 用于指示连接异常关闭（例如，未发送或接收 <code>close</code> 帧）。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>1007</code></td>
          <td style="text-align: left">无效的负载数据</td>
          <td style="text-align: left">终结点正在终止连接，因为它收到包含不一致数据的消息（例如，文本消息中的非 UTF-8 数据）。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>1008</code></td>
          <td style="text-align: left">Policy violation 违反政策</td>
          <td style="text-align: left">终结点正在终止连接，因为它收到了违反其策略的消息。这是一个通用状态代码;当其他状态代码不合适时，或者需要隐藏有关策略的特定详细信息时，应使用它。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>1009</code></td>
          <td style="text-align: left">消息太大</td>
          <td style="text-align: left">. 由于接收到的数据帧太大而无法处理，端点正在终止连接。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>1010</code></td>
          <td style="text-align: left">强制延期</td>
          <td style="text-align: left">T客户端正在终止连接，因为服务器在打开握手期间未能协商扩展。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>1011</code></td>
          <td style="text-align: left">内部错误</td>
          <td style="text-align: left">服务器正在终止连接，因为它遇到了意外情况，导致它无法满足请求。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>1012</code></td>
          <td style="text-align: left">服务重启</td>
          <td style="text-align: left">服务器正在终止连接，因为它正在重新启动。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>1013</code></td>
          <td style="text-align: left">请稍后再试</td>
          <td style="text-align: left">服务器由于临时情况（例如，它过载）而终止连接。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>1014</code></td>
          <td style="text-align: left">Bad gateway 网关错误</td>
          <td style="text-align: left">服务器充当网关或代理，并收到来自上游服务器的无效响应。类似于 <code>502 Bad Gateway</code> HTTP 状态代码。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>1015</code></td>
          <td style="text-align: left">TLS handshake TLS 握手</td>
          <td style="text-align: left">保留。指示由于无法执行 TLS 握手（例如，无法验证服务器证书）而关闭连接。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>1016-1999</code></td>
          <td style="text-align: left">N/A</td>
          <td style="text-align: left">保留供 WebSocket 标准将来使用。</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>2000-2999</code></td>
          <td style="text-align: left">N/A</td>
          <td style="text-align: left">保留供 WebSocket 扩展将来使用。</td>
      </tr>
      <tr>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
  </tbody>
</table>
<p>客户端和 Web 服务器都可以启动关闭握手。收到 <code>close</code> 帧后，端点（客户端或服务器）必须发送帧 <code>close</code> 作为响应（回显接收到的状态代码）。终结点发送和接收 <code>close</code> 帧后，结束握手完成，WebSocket 连接被视为已关闭。</p>
<h4 id="使用-websocket-api-关闭-websocket-连接">使用 WebSocket API 关闭 WebSocket 连接</h4>
<p>该 <code>close()</code> 方法用于关闭 WebSocket 连接。调用此方法后，无法通过 WebSocket 连接发送或接收更多数据。</p>
<p>下面是调用 <code>close()</code> 该方法的最基本示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Javascript" data-lang="Javascript"><span style="display:flex;"><span><span style="color:#a6e22e">socket</span>.<span style="color:#a6e22e">close</span>();
</span></span></code></pre></div><p>（可选）您可以使用 close（） 方法传递两个参数：</p>
<ul>
<li>一个数值，指示说明关闭连接原因的状态代码。有关详细信息，请参阅本文上一节中的状态代码表。</li>
<li>一个人类可读的字符串，解释连接关闭的原因。</li>
</ul>
<p>下面是使用两个可选参数调用 <code>close()</code> 方法的示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Javascript" data-lang="Javascript"><span style="display:flex;"><span><span style="color:#a6e22e">socket</span>.<span style="color:#a6e22e">close</span>(<span style="color:#ae81ff">1003</span>, <span style="color:#e6db74">&#34;Unsupported data type!&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">当</span> <span style="color:#a6e22e">WebSocket</span> <span style="color:#a6e22e">连接关闭时</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">将触发一个</span> <span style="color:#e6db74">`close`</span> <span style="color:#a6e22e">事件</span><span style="color:#960050;background-color:#1e0010">。</span><span style="color:#a6e22e">以下是侦听</span> <span style="color:#e6db74">`close`</span> <span style="color:#a6e22e">事件的方式</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Javascript" data-lang="Javascript"><span style="display:flex;"><span><span style="color:#a6e22e">socket</span>.<span style="color:#a6e22e">onclose</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">e</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Connection closed&#34;</span>, <span style="color:#a6e22e">e</span>);
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="websockets的优缺点是什么">WebSockets的优缺点是什么？</h2>
<p>WebSocket 的优点是它们支持客户端和服务器之间的实时通信，而无需频繁的 HTTP 请求/响应。这带来了一些好处，例如减少延迟，以及提高 Web 应用程序的性能和响应能力。</p>
<p>由于其持久性和双向性，WebSocket 协议在构建需要频繁数据交换的实时应用程序时比 HTTP 更灵活。WebSocket 也更有效率，因为它们允许传输数据而无需重复的 HTTP 标头和握手。这可以减少带宽使用和服务器负载。</p>
<p>虽然 WebSocket 有很多优点，但它们也有一些缺点。以下是主要的：</p>
<ul>
<li>WebSocket 未针对流式音频和视频数据进行优化。</li>
<li>当连接终止时，WebSocket 不会自动恢复。</li>
<li>某些环境（例如具有代理服务器的企业网络）将阻止 WebSocket 连接。</li>
<li>WebSocket 是有状态的，这使得它们很难在大型系统中使用。</li>
</ul>
<h2 id="websockets-的最佳替代品是什么">WebSockets 的最佳替代品是什么？</h2>
<p>WebSocket 是实时或近乎实时发送和使用数据的关键（或至少是可取的）用例的绝佳选择。然而，很少有放之四海而皆准的协议——不同的协议比其他协议更好地服务于不同的目的。WebSockets 的实时替代方案包括：</p>
<ul>
<li><a href="https://ably.com/topic/server-sent-events" target="_blank">Server-Sent Events</a></li>
<li><a href="https://ably.com/topic/long-polling" target="_blank">HTTP 长轮询</a></li>
<li><a href="https://ably.com/topic/mqtt" target="_blank">MQTT </a></li>
<li><a href="https://ably.com/blog/what-is-webrtc" target="_blank">WebRTC</a></li>
<li><a href="https://ably.com/blog/can-webtransport-replace-websockets" target="_blank">WebTransport</a></li>
</ul>
<h2 id="如何开始使用-websockets-构建实时体验">如何开始使用 WebSockets 构建实时体验</h2>
<p>WebSockets 的入门非常简单。WebSocket API 使用起来很简单，每种编程语言都有许多可用的 WebSocket 库和框架。它们中的大多数都建立在原始 WebSocket 协议之上，同时提供了额外的功能，从而使开发人员更容易、更方便地在他们的应用程序中实现 WebSocket 并构建基于 WebSocket 的功能。</p>
<p>如果您刚刚开始使用 WebSockets，并且希望构建第一个由 WebSockets 提供支持的实时应用程序，请查看此分步教程。它教您如何使用两个简单的开源 WebSocket 库开发交互式光标位置共享演示。这种项目需要客户端和服务器之间的双向即时通信，而 WebSocket 技术正是在这种用例中大放异彩的。</p>
<p>另一方面，交付由开源 WebSocket 库提供支持的生产就绪实时功能并不像构建一个简单的演示应用程序那样容易。这是一条充满障碍和工程复杂性的道路。例如，请参阅扩展 Socket.IO 所涉及的许多工程挑战，这是目前最流行的开源 WebSocket 库之一。</p>
<p>如果您想避免在内部扩展和维护 WebSocket 基础架构的挑战和成本，您可以将这种复杂性卸载到托管的第三方 PaaS（如 Ably）上。</p>
<h3 id="ablywebsocket平台在任何规模下都能可靠地工作">Ably，WebSocket平台在任何规模下都能可靠地工作</h3>
<p>Ably 是一家实时体验基础设施提供商。我们的 API 和 SDK 可帮助开发人员构建和交付实时体验，而无需担心维护和扩展杂乱无章的 WebSocket 基础设施。</p>
<p>Ably 的主要特性和功能：</p>
<ul>
<li>通过无服务器 WebSocket 进行发布/订阅消息传递，具有丰富的功能，例如消息增量压缩、具有连续性的自动重新连接、用户状态、消息历史记录和消息交互。</li>
<li>由数据中心和边缘加速接入点组成的全球分布式网络。</li>
<li>保证消息排序和传递。</li>
<li>全局容错和 99.999% 的正常运行时间 SLA。</li>
<li>&lt; 65 毫秒的往返延迟 （P99）。</li>
<li>动态弹性，因此我们可以快速扩展以处理任何需求（数十亿条 WebSocket 消息发送到数百万个发布/订阅频道和 WebSocket 连接）。</li>
</ul>
<h2 id="websocket-常见问题解答">WebSocket 常见问题解答</h2>
<h3 id="什么是-websocket-连接">什么是 WebSocket 连接？</h3>
<p>您可以将 WebSocket 连接视为 Web 客户端和 Web 服务器之间的长期双向全双工通信通道。请注意，WebSocket 连接在 TCP 之上工作。</p>
<h3 id="websockets-是否可扩展">WebSockets 是否可扩展？</h3>
<p>是的，WebSocket 是可扩展的。Slack、Netflix 和 Uber 等公司使用 WebSockets 为其应用程序中的实时功能提供支持，为数百万最终用户提供支持。例如，<a href="https://slack.engineering/migrating-millions-of-concurrent-websockets-to-envoy/" target="_blank">Slack 使用 WebSockets 在聊天用户之间进行即时消息传递</a>。</p>
<p>然而，扩展 WebSocket 并非易事，涉及大量工程决策和技术权衡。其中：</p>
<ul>
<li>您应该使用垂直缩放还是水平缩放？</li>
<li>您如何处理不可预测的负载？</li>
<li>如何大规模管理 WebSocket 连接？</li>
<li>总体上使用了多少带宽，它如何影响您的预算？</li>
<li>您是否必须处理流量高峰，如果是这样，对服务器层的性能有什么影响？</li>
<li>如果需要，您将如何自动添加额外的服务器容量？</li>
<li>如何确保大规模的数据完整性（保证消息排序和传递）？</li>
</ul>
<h3 id="websocket-安全吗">WebSocket 安全吗？</h3>
<p>如果 WebSocket 采用适当的安全措施来实施，它们是安全的。安全 WebSocket 连接使用“wss://”URI。这表示连接是使用 SSL/TLS 加密的，这确保了 WebSocket 客户端和 WebSocket 服务器之间传输的数据是加密的，不会被第三方拦截或篡改。</p>
<p>此外，WebSocket 连接可能受到与 HTTP 连接相同的安全策略的约束，例如跨域资源共享 （CORS） 限制，可防止跨不同域对资源进行未经授权的访问。</p>
<p>请注意，WebSocket 协议没有规定服务器对客户端进行身份验证的任何特定方式。例如，您可以在开始握手期间使用 Cookie 标头处理身份验证。另一种选择是使用 JSON Web 令牌等技术在应用程序级别管理身份验证（和授权）。</p>
<h3 id="websockets-比-http-快吗">WebSockets 比 HTTP 快吗？</h3>
<p>在需要频繁数据交换的实时应用程序的上下文中，WebSocket 比 HTTP 更快。</p>
<p>与 WebSocket 连接相比，HTTP 连接具有额外的开销（例如标头和其他元数据），这可能会增加延迟并降低性能，而 WebSocket 连接专为持久、低延迟、双向通信而设计。使用 WebSockets，不需要多个 HTTP 请求和响应。这可以加快通信速度并降低延迟。</p>
<h3 id="websocket-是同步的还是异步的">WebSocket 是同步的还是异步的？</h3>
<p>WebSocket 在设计上是异步的，这意味着可以随时发送和接收数据，而无需阻塞或等待响应。但是，需要注意的是，虽然 WebSocket 本身是异步的，但用于处理 WebSocket 事件和消息的代码可能是同步的，也可能是异步的，具体取决于它的编写方式。</p>
<h3 id="websocket-贵吗">WebSocket 贵吗？</h3>
<p>WebSocket 连接本身并不昂贵，因为它被设计为轻量级和高效，开销最小。话虽如此，在内部构建和管理一个可扩展且可靠的 WebSocket 系统既昂贵又耗时，并且需要大量的工程工作：</p>
<ul>
<li>10.2 人月是在内部构建基本 WebSocket 基础设施的平均时间，可扩展性有限。</li>
<li>所有自建的 WebSocket 解决方案中有一半每年需要 $100K-$200K 的维护。</li>
</ul>
<h3 id="哪些浏览器支持-websockets">哪些浏览器支持 WebSockets？</h3>
<p>大多数现代 Web 浏览器都支持 WebSocket，包括：</p>
<ul>
<li>Google Chrome（版本 4 及更高版本）。</li>
<li>Mozilla Firefox（版本 4 及更高版本）。</li>
<li>Safari（版本 5 及更高版本）。</li>
<li>Microsoft Edge（版本 12 及更高版本）。</li>
<li>Opera（版本 10.70 及更高版本）。</li>
<li>Internet Explorer（版本 10 及更高版本）。</li>
<li>Microsoft Edge（版本 12 及更高版本）。
请注意，这些浏览器的旧版本要么不支持 WebSocket，要么支持有限。在撰写本文时（2023 年 4 月 25 日），Opera Mini 是唯一不支持 WebSocket 的现代浏览器。</li>
</ul>
<h3 id="websocket-可以保持打开状态多长时间">WebSocket 可以保持打开状态多长时间？</h3>
<p>通常，只要客户端和服务器保持连接并且网络稳定，WebSocket 连接就可以无限期保持打开状态。</p>
<h3 id="websocket-是有状态的还是无状态的">WebSocket 是有状态的还是无状态的？</h3>
<p>与 HTTP 不同，WebSocket 连接是持久且有状态的。这使得 WebSocket 难以在由多个 WebSocket 服务器组成的大型系统中使用（您需要在服务器之间共享连接状态）。</p>

		</div>


	</article>
</main>
<footer class="post__footer">
	

<div class="post-related">
	<h3>相关文章</h3>
	<ul class="post-related-list">
		
		<li class="post-related-item">
			<a href="/posts/2024/05/07/websocket-alternatives/" target="_blank" title="[译]2024年最好的WebSocket替代品">[译]2024年最好的WebSocket替代品</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/05/07/websockets-vs-http/" target="_blank" title="[译]WebSocket与HTTP：2024年为您的项目选择哪一个">[译]WebSocket与HTTP：2024年为您的项目选择哪一个</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/05/07/http3/" target="_blank" title="[译]什么是HTTP/3？">[译]什么是HTTP/3？</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/05/07/socket-io/" target="_blank" title="[译]什么是Socket.IO？">[译]什么是Socket.IO？</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/05/07/websockets/" target="_blank" title="[译]什么是WebSocket？">[译]什么是WebSocket？</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/05/07/thingsboard-domain/" target="_blank" title="ThingsBoard的领域模型">ThingsBoard的领域模型</a>
		</li>
		
	</ul>
</div>

</footer>

<footer class="post__footer">
	<footer class="post__footer">
		
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/javascript/" rel="tag">javascript</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/backend/" rel="tag">backend</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/tutorial/" rel="tag">tutorial</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/translation/" rel="tag">translation</a>
		</li>
	</ul>
</div>
	</footer>
</footer>


<nav class="pagination flex">
	<div class="pagination__item pagination__item--prev">
		<a class="pagination__link" href="/posts/2024/05/07/websockets-vs-http/" rel="prev">
			<p class="pagination__title">«&thinsp;上一篇: [译]WebSocket与HTTP：2024年为您的项目选择哪一个</p>
		</a>
	</div>
	<div class="pagination__item pagination__item--next">
		<a class="pagination__link" href="/posts/2024/05/07/websockets-java/" rel="next">
			<p class="pagination__title">&thinsp;» 下一篇: [译]Java和WebSockets：构建可靠的实时应用程序</p>
		</a>
	</div>
</nav>



<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="ChenSoul avatar" src="/avatar.jpg" class="avatar" height="60" width="60" loading="lazy">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">关于 ChenSoul</span>
	</div>
	<div class="authorbox__description">
		一个来自中国武汉的开发者，主要撰写软件开发和开源方面的文章。浏览我的<a href="%28/posts%29">博客文章</a>，订阅我的 <a href="/index.xml">RSS</a> 源，或了解更多<a href="/about/">关于我</a>的信息。
	</div>
</div>




	<p><h3>欢迎留言！</h3></p>
<div id="remark42"></div>
<script>
	var remark_config = {
		host: 'https:\/\/comment.chensoul.cc',
		site_id: 'remark',
		components: ['embed'],
		url: 'https:\/\/blog.chensoul.cc\/posts\/2024\/05\/07\/the-websocket-api-and-protocol-explained\/',
		locale: 'zh'
	};

	!function(e, n) {
		for (var o = 0; o < e.length; o++) {
			var r = n.createElement('script'),
			c = '.js',
			d = n.head || n.body;
			'noModule' in r ? (r.type = 'module', c = '.mjs') : r.async = !0, r.defer = !0, r.src = remark_config.host + '/web/' + e[o] + c, d.appendChild(r)
		}
	}(remark_config.components || ['embed'], document);

</script>





			</div>
			

<aside class="sidebar sidebar--right">
	<div class="post__toc toc">
		<div class="toc__title">目录</div>
		<div class="toc__menu">
			<nav id="TableOfContents">
  <ul>
    <li><a href="#websocket协议和-api-解释">WebSocket：协议和 API 解释</a>
      <ul>
        <li><a href="#websocket的历史是什么">WebSocket的历史是什么？</a></li>
        <li><a href="#什么是-websocket-协议">什么是 WebSocket 协议？</a></li>
        <li><a href="#什么是-websocket-api">什么是 WebSocket API？</a></li>
      </ul>
    </li>
    <li><a href="#websocket-的用途是什么">WebSocket 的用途是什么？</a></li>
    <li><a href="#websockets-是如何工作的">WebSockets 是如何工作的？</a>
      <ul>
        <li><a href="#如何建立-websocket-连接">如何建立 WebSocket 连接</a></li>
        <li><a href="#如何通过-websocket-传输数据">如何通过 WebSocket 传输数据</a></li>
        <li><a href="#如何关闭-websocket-连接">如何关闭 WebSocket 连接</a></li>
      </ul>
    </li>
    <li><a href="#websockets的优缺点是什么">WebSockets的优缺点是什么？</a></li>
    <li><a href="#websockets-的最佳替代品是什么">WebSockets 的最佳替代品是什么？</a></li>
    <li><a href="#如何开始使用-websockets-构建实时体验">如何开始使用 WebSockets 构建实时体验</a>
      <ul>
        <li><a href="#ablywebsocket平台在任何规模下都能可靠地工作">Ably，WebSocket平台在任何规模下都能可靠地工作</a></li>
      </ul>
    </li>
    <li><a href="#websocket-常见问题解答">WebSocket 常见问题解答</a>
      <ul>
        <li><a href="#什么是-websocket-连接">什么是 WebSocket 连接？</a></li>
        <li><a href="#websockets-是否可扩展">WebSockets 是否可扩展？</a></li>
        <li><a href="#websocket-安全吗">WebSocket 安全吗？</a></li>
        <li><a href="#websockets-比-http-快吗">WebSockets 比 HTTP 快吗？</a></li>
        <li><a href="#websocket-是同步的还是异步的">WebSocket 是同步的还是异步的？</a></li>
        <li><a href="#websocket-贵吗">WebSocket 贵吗？</a></li>
        <li><a href="#哪些浏览器支持-websockets">哪些浏览器支持 WebSockets？</a></li>
        <li><a href="#websocket-可以保持打开状态多长时间">WebSocket 可以保持打开状态多长时间？</a></li>
        <li><a href="#websocket-是有状态的还是无状态的">WebSocket 是有状态的还是无状态的？</a></li>
      </ul>
    </li>
  </ul>
</nav>
		</div>
	</div>
</aside>

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
<div class="footer__links">
	<a class="footer__link" href="/">首页</a> | <a class="footer__link" href="/categories/">分类</a> | <a class="footer__link" href="/tags/">标签</a> | <a class="footer__link" href="/index.xml">订阅</a> | <a class="footer__link" href="/about/">关于</a>
</div>
		<div class="footer__copyright">
			&copy; 2025 ChenSoul.
			<span class="footer__copyright-credits">基于 <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> 引擎和 <a href="https://github.com/chensoul/rose-hugo/" rel="nofollow noopener" target="_blank">Rose Hugo</a> 主题</span>
		</div>
	</div>

	






<style>
	.scroll-up a {
		display: block;
		height: 3.125rem;
		width: 3.125rem;
		text-align: center;
		line-height: 2.7;
		border-radius: 50px;
		font-size: 1.125rem;
		color: #fff;
		opacity: 1;
		transition: all 0.3s ease 0s;
		box-shadow: 0 0 10px rgb(0 0 0 / 20%);
	}
	.scroll-up a {
		background: #ee591f;
	}
	.scroll-up {
		position: fixed;
		display: none;
		bottom: 50px;
		z-index: 999;
	}
	.scroll-up.right {
		right: 60px;
	}
</style>

<div class="scroll-up custom right" style="display: block;"><a href="#top" id="top-link" accesskey="g"><i
	class="fa fa-arrow-up"></i></a></div>

<script>
	var mybutton = document.getElementById("top-link");
	window.onscroll = function () {
		if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
			mybutton.style.visibility = "visible";
			mybutton.style.opacity = "1";
		} else {
			mybutton.style.visibility = "hidden";
			mybutton.style.opacity = "0";
		}
	};
</script>


    <script defer src="https://umami.chensoul.cc/random-string.js" data-website-id="1e07d36d-bec3-4ba6-9459-876b1ac3bbe7"></script>
</footer>


	</div>

	<script>
		'use strict';
		(function iifeMenu(document, window, undefined) {
			var menuBtn = document.querySelector('.menu__btn');
			var	menu = document.querySelector('.menu__list');
			function toggleMenu() {
				menu.classList.toggle('menu__list--active');
				menu.classList.toggle('menu__list--transition');
				this.classList.toggle('menu__btn--active');
				this.setAttribute(
					'aria-expanded',
					this.getAttribute('aria-expanded') === 'true' ? 'false' : 'true'
				);
			}
			function removeMenuTransition() {
				this.classList.remove('menu__list--transition');
			}
			if (menuBtn && menu) {
				menuBtn.addEventListener('click', toggleMenu, false);
				menu.addEventListener('transitionend', removeMenuTransition, false);
			}
		}(document, window));
	</script>
</body>
</html>