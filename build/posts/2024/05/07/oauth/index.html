<!DOCTYPE html>
<html class="no-js" lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[译]什么是 OAuth？ - Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="[译]什么是 OAuth？">
	<meta property="og:description" content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps">
	<meta property="og:type" content="article">
	<meta property="og:url" content="https://blog.chensoul.cc/posts/2024/05/07/oauth/">
	<meta property="og:site_name" content="ChenSoul Blog">
	<meta property="og:image" content="">
	
  <meta itemprop="name" content="[译]什么是 OAuth？">
  <meta itemprop="description" content="原文链接：https://www.pubnub.com/guides/oauth/
什么是 OAuth？ OAuth（开放授权）是一种开放标准授权框架，允许第三方应用程序访问用户数据，而无需用户共享其登录凭据。它为用户提供了一种安全且标准化的方式，将其在一个网站上的资源的访问权限授予另一个网站或应用程序，而无需暴露其密码。">
  <meta itemprop="datePublished" content="2024-05-07T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-05-07T00:00:00+00:00">
  <meta itemprop="wordCount" content="534">
  <meta itemprop="keywords" content="Javascript,Backend,Security,Tutorial">
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:title" content="[译]什么是 OAuth？">
	<meta name="twitter:description" content="Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps">
	<meta name="twitter:image" content="">

	<link rel="preconnect" href="//fonts.loli.net" crossorigin>
	<link rel="dns-prefetch" href="//fonts.loli.net">
	<link rel="stylesheet" href="https://fonts.loli.net/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css" integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
	<link rel="stylesheet" href="/css/style.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="ChenSoul Blog" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="/logo.svg" loading="lazy" alt="Site logo" width="60" height="60">
				</div><div class="logo__item logo__text">
					<div class="logo__title">ChenSoul Blog</div>
					<div class="logo__tagline">Java、Spring、Spring Boot、MicroServices、Architecture、Kubernetes、DevOps</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">菜单</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/">
				
				<span class="menu__text">首页</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/categories/">
				
				<span class="menu__text">分类</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/tags/">
				
				<span class="menu__text">标签</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/index.xml">
				
				<span class="menu__text">订阅</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">关于</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[译]什么是 OAuth？</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 1 1 0 28 1 1 0 0 1 0-28m0 3a3 3 0 1 0 0 22 3 3 0 0 0 0-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class="meta__text" datetime="2024-05-07">2024-05-07</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class="meta__text"><a class="meta__link" href="/categories/java/" rel="category">Java</a>
	</span>
</div><div class="meta__item-tags meta__item"><svg class="meta__icon icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg><span class="meta__text"><a class="meta__link" href="/tags/javascript/" rel="tag">Javascript</a>, <a class="meta__link" href="/tags/backend/" rel="tag">Backend</a>, <a class="meta__link" href="/tags/security/" rel="tag">Security</a>, <a class="meta__link" href="/tags/tutorial/" rel="tag">Tutorial</a>
	</span>
</div>
</div>
		</header>
		
		<div class="content post__content clearfix">
			<p>原文链接：<a href="https://www.pubnub.com/guides/oauth/" target="_blank">https://www.pubnub.com/guides/oauth/</a></p>
<h2 id="什么是-oauth">什么是 OAuth？</h2>
<p><a href="https://oauth.net/" target="_blank">OAuth（开放授权）</a>是一种开放标准授权框架，允许第三方应用程序访问用户数据，而无需用户共享其登录凭据。它为用户提供了一种安全且标准化的方式，将其在一个网站上的资源的访问权限授予另一个网站或应用程序，而无需暴露其密码。</p>
<p>简单来说，OAuth 充当最终用户和他们想要授予访问权限的应用程序之间的中间人。用户不会直接向 Web 应用程序提供用户名和密码，而是会被重定向到授权服务器（例如 Google、Facebook 或 Twitter），在那里他们可以安全地验证自己的身份。经过身份验证后，用户可以授予或拒绝对其想要使用的应用程序上的数据的访问权限。</p>
<h2 id="oauth-是如何工作的">OAuth 是如何工作的？</h2>
<p>OAuth 为用户提供了一种安全且标准化的方式来授权应用程序从各种来源（例如社交媒体平台或在线服务）访问其数据。</p>
<p>OAuth<a href="https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use" target="_blank">工作流程</a>涉及三个主要方：用户、应用程序和服务提供商（也称为<a href="https://developers.google.com/identity/protocols/oauth2/web-server" target="_blank">OAuth 服务器</a>）。以下是 OAuth 流程的高级概述：</p>
<ol>
<li>用户启动该过程：用户想要使用需要访问服务提供商上受保护资源的应用程序。用户首先向应用程序请求访问权限。</li>
<li>应用程序请求授权：应用程序将用户重定向到服务提供商的授权端点，以及必要的参数，例如应用程序的客户端 ID 和请求的访问范围。</li>
<li>用户授予授权：服务提供商在授权端点向用户显示登录屏幕。用户输入其凭据，如果有效，则系统会要求授予或拒绝应用程序访问其资源的请求。</li>
<li>服务提供商发出授权代码：如果用户授予授权，服务提供商会生成授权代码并将用户重定向回应用程序指定的<a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/reply-url" target="_blank">重定向 URI</a>。授权码是一个临时令牌，代表用户的同意。</li>
<li>应用程序用授权代码交换<a href="https://oauth.net/2/access-tokens/" target="_blank">访问令牌</a>：现在拥有授权代码的应用程序向服务提供商发送请求，以用代码交换访问令牌。该请求包括代码、应用程序的客户端 ID 和客户端密钥，它们用于向服务提供商验证应用程序的身份。</li>
<li>服务提供商验证授权代码：服务提供商对其进行验证并检查它是否与之前为用户生成的授权代码相匹配。如果代码有效，服务提供商将向应用程序颁发访问令牌。</li>
<li>应用程序使用访问令牌来访问受保护的资源：通过从服务提供商获得的访问令牌，应用程序现在可以代表用户发出请求以访问其受保护的资源。这些请求通常是向服务提供商的 API 端点发出的。</li>
<li>访问令牌过期和刷新：访问令牌的生命周期有限，过期后就会过期。要继续访问用户的资源，应用程序可以使用刷新令牌（如果提供）来获取新的访问令牌，而无需用户的参与。</li>
</ol>
<h2 id="使用-oauth-有什么好处">使用 OAuth 有什么好处？</h2>
<p>这种广泛采用的协议为构建实时聊天和消息应用程序的开发人员提供了多种好处：</p>
<p><strong>增强的安全性：</strong> OAuth 消除了应用程序需要存储用户凭据的情况，从而降低了未经授权访问的风险。通过利用 OAuth，开发人员可以对用户进行身份验证和授权，而无需处理用户的敏感信息（例如密码）。这显着降低了数据泄露的可能性并增强了整体应用程序的安全性。</p>
<p><strong>简化的用户体验：</strong> OAuth 使用户能够向第三方应用程序授予权限而无需共享其凭据，从而提供无缝且用户友好的体验。这消除了为每个应用程序创建和管理单独帐户的麻烦，从而提高了便利性和用户采用率。</p>
<p><strong>可扩展性和互操作性：</strong> OAuth 使开发人员能够构建集成多个平台和服务的应用程序。通过利用 OAuth，开发人员可以轻松地验证和访问来自不同提供商的资源，从而允许他们的聊天和消息应用程序与其他系统无缝交互。这增强了可扩展性，并使开发人员能够利用不同平台的现有用户群。</p>
<p><strong>细粒度的访问控制：</strong> OAuth 允许开发人员为其聊天和消息应用程序实施细粒度的访问控制。可以为每个资源授予权限，确保第三方应用程序只能访问所需的资源。这种对访问的精细控制有助于维护数据隐私和控制，降低未经授权的数据泄露的风险。</p>
<p><strong>开发人员友好：</strong> OAuth 提供了一个简单、开发人员友好的框架，用于在聊天和消息传递应用程序中实现身份验证和授权。该协议有详细的文档记录，并受到各种库和 SDK 的支持，使开发人员可以轻松地将 OAuth 集成到他们的应用程序中。此外，OAuth 通过内置的令牌过期和撤销机制简化了访问令牌的管理。这简化了开发流程并降低了处理用户身份验证和授权的复杂性。</p>
<h2 id="使用-oauth-有哪些缺点">使用 OAuth 有哪些缺点？</h2>
<p>虽然 OAuth 对于构建实时聊天和消息应用程序的开发人员来说具有众多优势，但也存在一些缺点。这些缺点包括：</p>
<p>**复杂性：**实施 OAuth 可能很复杂，尤其是对于不熟悉该协议的开发人员而言。该过程涉及多个步骤，包括注册应用程序、获取客户端凭据和处理授权流程。与多个身份提供商集成或处理刷新令牌时，复杂性可能会进一步增加。开发人员需要投入时间和精力来正确理解和实施 OAuth。</p>
<p><strong>对第三方提供商的依赖：</strong> OAuth 依赖第三方身份提供商来对用户进行身份验证和授权。这种依赖性引入了潜在的单点故障。如果身份提供商遇到中断或更改其 API，则可能会中断聊天和消息传递应用程序的身份验证和授权过程。开发人员需要考虑所选身份提供商的可靠性和寿命。</p>
<p><strong>用户隐私问题：</strong> OAuth 提供了一种安全的身份验证和授权机制，但一些用户可能担心与第三方应用程序共享其个人信息。尽管 OAuth 不会公开密码等敏感信息，但用户仍然需要授予访问其数据的权限。某些用户可能会犹豫是否授予这些权限，尤其是对于鲜为人知或不太受信任的应用程序。</p>
<p>**缺乏标准化：**尽管 OAuth 被广泛采用，但不同提供商和平台的实施可能存在差异。缺乏标准化可能会导致与多个系统集成时出现不一致和兼容性问题。开发人员可能需要额外的努力来处理这些变化并确保不同平台和提供商之间的兼容性。</p>
<p>**安全漏洞：**虽然 OAuth 的设计是安全的，但也存在<a href="https://portswigger.net/web-security/oauth" target="_blank">发现</a>和利用漏洞的情况。这些漏洞可能导致未经授权的用户数据访问或冒充攻击。开发人员必须及时了解最新的安全最佳实践，并定期修补 OAuth 实施中的任何漏洞。</p>
<h2 id="oauth-与-openid">OAuth 与 OpenID</h2>
<p>OAuth 和<a href="https://openid.net/" target="_blank">OpenID</a>是广泛使用的身份验证和授权协议，但用途不同。</p>
<p>OAuth 主要是一种授权协议，允许应用程序访问另一个系统上的用户资源，而无需共享其凭据。它通常用于委托授权场景，即用户向第三方应用程序授予访问其在特定网站或服务上的数据的权限。例如，当您使用 Google 帐户登录第三方应用程序时，OAuth 通常用于授予该应用程序访问您的 Google 云端硬盘或 Gmail 数据的权限。</p>
<p>另一方面，OpenID 是一种<a href="https://en.wikipedia.org/wiki/Authentication_protocol" target="_blank">身份验证协议</a>，使用户能够使用一组凭据在多个网站或应用程序中对自己进行身份验证。它允许用户使用其 OpenID 凭据登录多个网站，而不是为每个网站创建单独的用户名和密码。 OpenID 通常用作<a href="https://en.wikipedia.org/wiki/Single_sign-on" target="_blank">单点登录 (SSO</a> ) 解决方案，为不想记住多个登录凭据的用户提供便利。</p>
<h2 id="oauth-与-openid-connect">OAuth 与 OpenID Connect</h2>
<p>OAuth 和<a href="https://openid.net/developers/how-connect-works/" target="_blank">OpenID Connect</a>经常出现在 auth（身份验证和授权）协议方面。虽然它们是相关的并且具有相似的目的，但它们也有一些关键的区别。本节将探讨这些差异并帮助您了解何时使用其中一种而不是另一种。</p>
<p><strong>OAuth：专注于授权</strong></p>
<p>如前所述，OAuth 主要是一种授权协议。其主要目的是允许应用程序访问另一个系统上的用户资源，而无需共享其凭据。这是通过使用访问令牌来实现的。</p>
<p>OAuth 的典型用例是当用户想要授予第三方应用程序访问其在特定网站或服务上的数据的权限时。例如，当您使用 Google 帐户登录第三方应用程序时，OAuth 通常用于授予该应用程序访问您的 Google 云端硬盘或 Gmail 数据的权限。</p>
<p><strong>OpenID Connect：专注于身份验证</strong></p>
<p>另一方面，OpenID Connect 是一种身份验证协议。其主要目标是为用户提供一种标准化的方式来跨多个网站或应用程序进行身份验证。它允许用户使用一组凭据（OpenID）登录多个站点，从而无需记住多个用户名和密码。</p>
<p>除了身份验证之外，OpenID Connect 还提供有关用户的身份信息，例如姓名和电子邮件地址。此信息可用于应用程序内的个性化和定制目的。</p>
<p>OAuth 和 OpenID Connect 之间的主要区别之一是用户交互级别。当用户向第三方应用程序授予对其资源的访问权限时，通常会使用 OAuth。系统可能会提示用户登录其帐户并授予权限，但重点是资源访问而不是身份验证。</p>
<p>另一方面，OpenID Connect 是专门为身份验证而设计的。它允许用户使用一组凭据证明自己的身份并登录多个站点。这是通过 OpenID 提供商（例如 Google 或 Facebook）颁发的 OpenID 令牌来实现的，并且可用于跨多个站点对用户进行身份验证。</p>
<p>OAuth 和 OpenID Connect 之间的另一个区别是提供的安全级别。 OAuth 侧重于授权和访问控制，确保只有授权的应用程序才能访问用户的资源。它不直接提供身份验证或身份信息。</p>
<p>简而言之，OpenID Connect 在 OAuth 之上添加了一个身份验证层。它允许用户验证自己的身份并提供有关用户的身份信息。此信息是通过 ID 令牌获取的，ID 令牌由 OpenID 提供商颁发并包含用户姓名和电子邮件地址等信息。</p>
<h2 id="oauth-与-saml">OAuth 与 SAML</h2>
<p>OAuth 和[SAML](<a href="https://support.google.com/a/answer/6262987?hl=en#:~:text=Security" target="_blank">https://support.google.com/a/answer/6262987?hl=en#:~:text=Security</a> Assertion Markup Language (SAML,trying to access secure content.)都是广泛使用的身份验证和授权协议，但它们具有不同的用例和设计理念。</p>
<p>OAuth 通常用于委托授权场景，例如允许第三方应用程序访问特定网站或服务上的用户数据。它被设计为轻量级、可扩展且易于实施，使其成为集成外部服务和 API 的流行选择。</p>
<p>另一方面，SAML（安全断言标记语言）是一种基于 XML 的协议，用于在身份提供商 (IdP) 和服务提供商 (SP) 之间交换身份验证和授权数据。它通常用于单点登录 (SSO) 场景，其中用户可以使用一组凭据登录多个网站或应用程序。 SAML 使 IdP 能够通过数字签名的 XML 文档向 SP 断言用户的身份。这可以实现集中且安全的身份验证机制，特别是在企业环境中。</p>
<p>比较 OAuth 和 SAML 时，需要考虑几个关键差异：</p>
<ul>
<li>用例：OAuth 主要关注委派授权，授予对另一个系统上的用户资源的访问权限。另一方面，SAML 专注于身份验证并支持跨多个系统的 SSO。</li>
<li>架构：OAuth 遵循分散式架构，其中用户、客户端应用程序和资源服务器是独立的实体。 SAML 遵循<a href="https://www.pubnub.com/blog/the-benefits-of-edge-messaging/" target="_blank">集中式架构</a>，其中身份提供商 (IdP) 是身份验证和授权的中央机构。</li>
<li>协议：OAuth使用<a href="https://www.pubnub.com/blog/implementing-google-oauth-2-and-pubnub-access-manager-with-smart-lock/" target="_blank">OAuth协议</a>，该协议基于<a href="https://www.pubnub.com/guides/http/" target="_blank">HTTP</a>和<a href="https://www.json.org/json-en.html" target="_blank">JSON</a>，使其轻量级且易于实现。另一方面，SAML使用SAML协议，该协议基于XML，实现起来比较复杂。</li>
<li>集成：OAuth通常用于与外部服务和API集成，允许第三方应用程序访问用户资源。 SAML 通常用于与企业系统集成并支持跨多个网站或应用程序的 SSO。</li>
<li>安全性：OAuth 使用访问令牌向第三方应用程序授予权限，允许它们在不共享凭据的情况下访问用户资源。相反，SAML 使用数字签名的 XML 文档来断言用户的身份，从而提供更安全的身份验证机制。</li>
</ul>
<h2 id="oauth-有哪些不同版本">OAuth 有哪些不同版本？</h2>
<p>多年来，已经发布了多个 OAuth 版本来解决安全问题并改进功能。让我们探讨一下 OAuth 的不同版本：</p>
<p><a href="https://oauth.net/core/1.0/" target="_blank"><strong>OAuth 1.0：</strong></a></p>
<p>OAuth 1.0 是定义授权核心原则的初始协议版本。它引入了令牌（请求和访问令牌）的概念来授予对受保护资源的访问权限。然而，OAuth 1.0 存在多个安全缺陷，包括要求共享消费者密钥，使其容易受到拦截攻击。</p>
<p><a href="https://oauth.net/core/1.0a/" target="_blank"><strong>OAuth 1.0a</strong></a><strong>：</strong></p>
<p>OAuth 1.0a 是 OAuth 1.0 的更新，解决了原始版本中的安全漏洞。它添加了签名机制来防止令牌拦截攻击。 OAuth 1.0a 使用三足授权流程，涉及用户、客户端应用程序和服务提供商。</p>
<p><a href="https://oauth.net/2/" target="_blank"><strong>OAuth 2.0</strong></a><strong>：</strong></p>
<p>OAuth 2.0 是对 OAuth 1.0 的彻底重新设计和改进。它简化了授权过程，同时解决了其前身的缺点。 OAuth 2.0 引入了更灵活和可扩展的框架，支持各种授权流程，例如授权代码、隐式、资源所有者密码凭据和客户端凭据。它还允许使用不同的身份验证机制，例如用户名/密码和 JWT（JSON Web 令牌）。</p>
<p><a href="https://oauth.net/2.1/" target="_blank"><strong>OAuth 2.1：</strong></a></p>
<p>OAuth 2.1 是 OAuth 协议的最新版本，于 2021 年发布。它的重点是提高安全性、澄清歧义并为开发人员提供更好的指导。 OAuth 2.1 对授权代码流引入了更严格的要求，并提供了实施安全令牌处理和撤销的建议。它还包括处理刷新令牌和客户端身份验证的额外安全注意事项。</p>
<p><strong>OAuth 1.0 和 OAuth 2.0 之间的主要区别是什么？</strong></p>
<p>OAuth 1.0 和 OAuth 2.0 在设计和功能上有显着不同。以下是两个版本之间的一些主要区别：</p>
<p><strong>复杂：</strong></p>
<p>与 OAuth 2.0 相比，OAuth 1.0 的设计更加复杂和严格。它需要加密签名和请求时间戳，使得实施过程更具挑战性。相反，OAuth 2.0 使用访问令牌提供了更简单、更灵活的框架。</p>
<p><strong>代币用途：</strong></p>
<p>在 OAuth 1.0 中，每个 API 请求中都会使用请求令牌和访问令牌，从而导致额外的开销和复杂性。 OAuth 2.0主要使用访问令牌，简化了令牌管理流程。</p>
<p><strong>安全模型：</strong></p>
<p>OAuth 1.0 依靠签名和时间戳来确保消息完整性并防止重放攻击。 OAuth 2.0更关注传输安全（例如HTTPS），并将令牌安全的责任留给了底层机制，例如安全存储和传输。 OAuth 2.0 还引入了刷新令牌的概念，用于在不涉及用户的情况下获取新的访问令牌。</p>
<p><strong>授权流程：</strong></p>
<p>OAuth 1.0仅支持一种授权流程，即三足一流程。此流程涉及用户、客户端应用程序和服务提供商。另一方面，OAuth 2.0 引入了多种授权流程，为不同的用例提供了更多的灵活性和选项。</p>
<p><strong>应用范围：</strong></p>
<p>OAuth 1.0 主要是为 Web 应用程序设计的，缺乏对移动和桌面应用程序的本机支持。另一方面，OAuth 2.0 旨在满足更广泛的应用程序，包括 Web、移动和桌面。</p>
<p><strong>标准化：</strong></p>
<p>OAuth 1.0 缺乏正式的标准化流程，导致其实施过程中出现变化和不一致。 OAuth 2.0 经历了标准化流程，创建了更加一致和可互操作的协议。</p>
<p><strong>社区采用：</strong></p>
<p>OAuth 2.0 获得了开发者社区和主要技术公司的更广泛采用和支持。它被广泛认为是现代应用程序中授权和身份验证的事实上的标准。</p>
<h2 id="什么是-oauth-访问令牌">什么是 OAuth 访问令牌？</h2>
<p>OAuth 访问令牌是应用程序用来代表用户访问受保护资源的凭据。它是一种授权机制，允许第三方应用程序在不知道用户登录凭据的情况下访问用户的数据。</p>
<p>当用户向应用程序授予访问其数据的权限时，应用程序会从授权服务器接收访问令牌。然后，此访问令牌用于验证和授权应用程序访问用户的资源，例如用户的个人资料信息或存储在服务器上的特定数据。</p>
<p>OAuth 访问令牌通常是短暂的，并且可以具有不同级别的范围或权限。范围定义应用程序可以代表用户访问的特定资源或操作。例如，应用程序可能仅具有对用户电子邮件地址的读取访问权限，但无法代表他们发送电子邮件。</p>
<p>访问令牌通常作为授权标头的一部分或作为请求 URL 中的参数与每个 API 请求一起传递。托管受保护资源的服务器验证访问令牌，以确保应用程序具有访问所请求资源的必要权限。</p>
<p>使用 OAuth 访问令牌有几个好处。首先，它增强了安全性，因为应用程序不需要存储或处理用户的登录凭据。其次，它允许用户授予或撤销对其数据的访问权限，而无需更改每个应用程序的登录凭据。此外，访问令牌的范围可以受到限制，从而为用户提供对应用程序可以访问哪些资源的细粒度控制。</p>
<p><strong>代币类型：</strong></p>
<p>OAuth 2.0 支持不同类型的访问令牌，具体取决于应用程序的特定用例和要求。最常用的令牌类型是：</p>
<ul>
<li>[不记名令牌：](<a href="https://apidog.com/articles/what-is-bearer-token/#:~:text=A" target="_blank">https://apidog.com/articles/what-is-bearer-token/#:~:text=A</a> Bearer token is a,JWT (JSON Web Token).)不记名令牌是 OAuth 2.0 中的默认令牌类型。它们是客户端在向服务器发出的每个请求中包含的简单字符串。不记名令牌通常是短暂的，并且不包含任何额外的安全机制。服务器验证令牌的有效性并根据令牌的范围授予访问权限。</li>
<li><a href="https://jwt.io/" target="_blank">JWT 令牌</a>：JSON Web 令牌 (JWT) 是一种独立的访问令牌，可以携带有关用户或其他信息的声明。 JWT 令牌经过数字签名，可用于验证令牌的完整性和真实性。它们还可以用于在服务之间安全地交换信息。</li>
</ul>
<p><strong>代币流程：</strong></p>
<p>获取 OAuth 访问令牌的过程通常涉及以下步骤：</p>
<ul>
<li>用户授权：用户会看到登录屏幕或授权提示，他们可以在其中授予应用程序访问其数据的权限。</li>
<li>授权码授予：用户授予权限后，应用程序会从授权服务器接收授权码。</li>
<li>令牌交换：应用程序通过请求授权服务器的令牌端点来交换访问令牌的授权代码。此请求包括客户端 ID、客户端密钥、授权代码和重定向 URI。</li>
<li>Access Token：如果授权服务器验证了授权码和其他参数，则会向应用程序颁发访问令牌。应用程序可以使用此访问令牌代表用户发出 API 请求。</li>
</ul>
<p><strong>代币管理：</strong></p>
<p>在构建实时聊天和消息传递应用程序时，正确的令牌管理至关重要。以下是一些需要考虑的最佳实践：</p>
<ul>
<li>令牌过期：访问令牌应具有有限的生命周期以增强安全性。当令牌过期时，应用程序应使用刷新令牌或重新对用户进行身份验证来获取新令牌。</li>
<li>令牌撤销：用户应该能够随时撤销对其数据的访问权限。应用程序应为用户提供一个界面来管理其授权的应用程序并在需要时撤销访问权限。</li>
<li>令牌范围：访问令牌的范围可以限制为仅允许访问特定资源或操作。请求访问令牌时，应用程序应指定所需的范围，以最大限度地降低未经授权的访问风险。</li>
<li>令牌存储：访问令牌应安全地存储在客户端。它们不应暴露给用户或存储在易于访问的位置。考虑使用安全存储机制，例如加密键值存储或安全 cookie。</li>
<li>令牌轮换：定期轮换访问令牌可以进一步增强安全性。通过轮换令牌可以降低因令牌受损而导致未经授权访问的风险。应用程序应该有一种机制，可以在一段时间后自动轮换令牌。</li>
<li>令牌验证：当接收带有访问令牌的 API 请求时，应用程序应验证其真实性和完整性，以确保它们没有被篡改或伪造。这可以通过使用授权服务器的公钥或令牌验证服务验证令牌的签名来完成。</li>
<li>令牌审计：跟踪令牌使用情况可以提供有价值的见解并帮助识别任何可疑活动。应用程序应记录令牌的使用情况，包括请求的 IP 地址、用户代理和时间戳，以检测异常或潜在的安全漏洞。</li>
<li>令牌撤销通知：除了允许用户手动撤销访问之外，应用程序还应该侦听来自授权服务器的令牌撤销事件。这允许应用程序实时失效并删除已撤销的令牌，进一步增强安全性并降低未经授权访问的风险。</li>
<li>令牌速率限制：为了防止滥用并防止恶意行为者，应用程序应使用访问令牌对 API 请求实施速率限制。这有助于防止暴力攻击并确保资源的公平使用。</li>
<li>Token加密：当Access Token中存储敏感数据（例如用户信息或权限）时，建议对Token进行加密。这增加了一层安全性，并防止未经授权访问敏感信息，即使令牌被泄露也是如此。</li>
</ul>
<h2 id="有哪些不同类型的流量">有哪些不同类型的流量？</h2>
<p>在身份验证和授权协议的上下文中存在多种类型的流。这些流程定义客户端应用程序如何获取和使用访问令牌来验证和授权对服务器的请求。以下是一些常用的流程：</p>
<p><a href="https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow" target="_blank"><strong>授权代码流程</strong></a>**：**此流程通常用于服务器端应用程序，其中客户端应用程序可以安全地存储客户端机密。客户端将用户重定向到授权服务器的登录页面，用户在该页面进行身份验证并向客户端授予权限。然后，授权服务器使用授权代码将用户重定向到客户端应用程序。客户端将此代码交换为访问令牌和刷新令牌，可用于在当前访问令牌过期时获取新的访问令牌。</p>
<p><a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-implicit-grant-flow" target="_blank"><strong>隐式流程</strong></a>**：**此流程适用于客户端应用程序，例如在 Web 浏览器中运行的基于<a href="https://www.pubnub.com/guides/javascript/" target="_blank">JavaScript</a>的应用程序。客户端应用程序将用户重定向到授权服务器的登录页面，用户在其中进行身份验证并授予权限。然后，授权服务器使用嵌入在 URL 片段中的访问令牌将用户重定向到客户端应用程序。客户端提取访问令牌并使用它来验证服务器请求。</p>
<p><a href="https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow" target="_blank"><strong>资源所有者密码凭据流程</strong></a>**：**此流程适用于受信任的应用程序，例如本机移动应用程序，其中客户端应用程序可以安全地存储用户凭据。客户端应用程序收集用户的用户名和密码，并将其直接发送到授权服务器以获得访问令牌。不建议公共客户端应用程序使用此流程，因为它要求客户端应用程序处理和存储敏感的用户凭据。</p>
<p><a href="https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow" target="_blank"><strong>客户端凭据流程：</strong></a>此流程最适合服务器到服务器的通信，其中客户端应用程序需要对自身而不是特定用户进行身份验证。客户端应用程序将其凭据（客户端 ID 和客户端密钥）直接发送到授权服务器以获取访问令牌。此流程不涉及用户身份验证，通常用于后端进程或 API。</p>
<p><a href="https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow" target="_blank"><strong>设备授权流程</strong></a>**：**此流程专为输入功能有限的设备（例如智能电视或游戏机）而设计。客户端应用程序在设备屏幕上显示代码，并指示用户转到另一设备（例如智能手机或计算机）上的指定 URL 以输入代码并对设备进行授权。客户端应用程序定期轮询授权服务器以检查用户是否已完成授权。获得授权后，设备会收到访问令牌以代表用户发出请求。</p>
<h2 id="验证-oauth-请求的步骤是什么">验证 OAuth 请求的步骤是什么？</h2>
<p>对 OAuth 请求进行身份验证涉及几个步骤，以确保客户端应用程序和服务器之间通信的安全性和完整性。以下是验证 OAuth 请求的一般步骤：</p>
<ol>
<li>注册您的应用程序：在使用 OAuth 对请求进行身份验证之前，您必须向 OAuth 提供商注册您的应用程序。这通常涉及提供有关您的应用程序的信息，例如名称、网站 URL 和回调 URL。</li>
<li>获取客户端凭据：注册应用程序后，OAuth 提供商将提供客户端凭据，包括客户端 ID 和客户端密钥。这些凭据可作为向 OAuth 提供商识别和验证您的应用程序的一种方式。</li>
<li>发送授权请求：客户端应用程序通过将用户重定向到 OAuth 提供程序的授权端点来启动身份验证过程。此请求通常包括客户端 ID、请求范围以及身份验证后将重定向用户的重定向 URL 等参数。</li>
<li>用户身份验证和授权：用户被重定向到 OAuth 提供商的身份验证页面，系统会提示用户登录并授权客户端应用程序访问其资源。用户的同意是身份验证过程中的关键步骤，并确保客户端应用程序仅访问用户授权的数据。</li>
<li>接收授权：用户成功登录并授权客户端应用程序后，OAuth 提供程序将用户重定向回授权请求中指定的重定向 URL。重定向 URL 包括授权许可作为查询参数。</li>
<li>将授权授予交换为访问令牌：客户端应用程序必须将上一步中收到的授权授予交换为访问令牌。这涉及请求 OAuth 提供程序的令牌端点、提供授权、客户端凭据以及任何其他所需参数。令牌端点以访问令牌和刷新令牌（可选）进行响应。</li>
<li>使用访问令牌发出经过身份验证的请求：使用上一步中获取的访问令牌，客户端应用程序可以将其包含在对 OAuth 提供程序受保护资源的后续请求的 Authorization 标头中。这允许客户端应用程序代表用户访问用户的资源。</li>
<li>处理令牌过期和刷新：访问令牌的生命周期有限，过期后将无法再用于访问受保护的资源。要继续发出经过身份验证的请求，客户端应用程序可以使用步骤 6 中的刷新令牌来获取新的访问令牌。这涉及请求令牌端点并提供刷新令牌和客户端凭据。令牌端点以新的访问令牌和（可选）新的刷新令牌进行响应。</li>
</ol>
<h2 id="oauth-和实时应用程序">OAuth 和实时应用程序</h2>
<p>OAuth 是一种广泛使用的协议，用于实时聊天和消息传递应用程序中的安全身份验证和授权。通过在应用程序中实施 OAuth，您可以提供安全、无缝的用户体验，同时降低数据泄露的风险。</p>
<ul>
<li>了解 OAuth 协议：在应用程序中实现 OAuth 之前，深入了解协议及其组件非常重要。 OAuth 允许用户从一个网站向另一个网站授予对资源的有限访问权限，而无需共享其凭据。它使用访问和刷新令牌来验证和授权对受保护资源的访问。熟悉 OAuth 工作流程和不同的 OAuth 流程（例如，授权代码流程、隐式流程、客户端凭据流程），以确定最适合您的应用程序的流程。</li>
<li>选择信誉良好的 OAuth 提供商：在应用程序中实施 OAuth 时，您应该只与信誉良好的 OAuth 提供商合作。这可确保 OAuth 提供商实施安全措施并遵循最佳实践来保护用户数据。寻找经过独立安全审核并拥有维护用户数据安全和隐私记录的提供商。</li>
<li>实施安全令牌存储：OAuth 依赖访问和刷新令牌来验证和授权对受保护资源的访问。安全地存储这些令牌以防止未经授权的访问至关重要。避免将令牌存储在明文或客户端存储中，因为这些方法很容易受到损害。相反，请使用安全存储机制，例如云提供商提供的加密数据库或密钥管理服务。此外，考虑实施令牌轮换或过期策略以进一步增强安全性。</li>
<li>实施速率限制和节流：实时聊天和消息传递应用程序通常会遇到流量大和 API 使用率高的情况。您应该考虑实施速率限制和节流机制，以防止滥用并保护您的应用程序免受拒绝服务攻击。这些机制可以帮助控制 API 请求的速率，确保资源的公平分配并防止恶意行为者压垮您的服务器。</li>
<li>定期更新和修补您的依赖项：实时聊天和消息传递应用程序依赖于第三方库和框架。定期更新和修补这些依赖项以解决安全漏洞至关重要。随时了解影响您的依赖项的安全更新和漏洞，并及时应用补丁。</li>
<li>监视和分析日志：监视和分析日志可以提供有关应用程序安全性的宝贵见解。通过持续监控日志，您可以及时发现并响应安全事件。实施一个集中式日志系统，收集和聚合来自所有应用程序组件的日志。使用日志分析工具搜索表明潜在安全漏洞的模式和异常情况。此外，请考虑实施实时警报机制，以通知您可疑活动或未经授权的访问尝试。</li>
<li>定期进行安全审核和渗透测试：定期安全审核和渗透测试可以帮助识别应用程序中的漏洞和弱点。聘请专业的安全公司或进行内部安全审计来评估安全措施的有效性。执行笔测试来模拟现实世界的攻击并识别攻击者的潜在入口点。及时解决这些审核和测试期间发现的任何漏洞或弱点，以维护应用程序的安全。</li>
<li>向您的用户提供有关安全最佳实践的教育：用户在确保应用程序的安全性方面发挥着至关重要的作用。教育您的用户有关安全最佳实践的知识，例如使用强而独特的密码、避免共享敏感信息以及警惕网络钓鱼尝试。提供有关保护其帐户和个人信息的明确说明和指南。</li>
<li>持续监控和更新您的安全措施：安全威胁和攻击技术不断发展。持续监控和更新安全措施以领先于潜在威胁非常重要。随时了解最新的安全趋势和漏洞，并定期更新您的安全协议和配置。实施自动安全更新和补丁，以确保及时防范新出现的威胁。</li>
<li>实施多重身份验证 (MFA)：[多重身份验证](<a href="https://aws.amazon.com/what-is/mfa/#:~:text=Multi-factor" target="_blank">https://aws.amazon.com/what-is/mfa/#:~:text=Multi-factor</a> authentication (MFA),question%2C or scan a fingerprint.)要求用户在访问其帐户之前提供多种形式的身份验证，从而为您的应用程序增加了额外的安全层。这可能包括他们知道的东西（例如密码）、他们拥有的东西（例如发送到手机的唯一代码）或他们本身的东西（例如指纹或面部识别）。通过实施 MFA，即使用户的密码被泄露，攻击者仍然需要访问其他形式的标识，从而使未经授权的访问变得更加困难。</li>
<li>加密敏感数据：加密对于保护敏感数据（例如用户凭据或个人信息）至关重要。实施强大的加密算法，确保数据安全传输和存储。使用行业标准的加密协议和算法并定期审查和更新，以保持最高级别的安全性。考虑使用端到端加密，这可确保数据在从发送者到接收者的整个过程中保持加密状态。</li>
<li>实施访问控制和权限：限制对应用程序敏感区域的访问对于维护安全至关重要。实施访问控制和权限，以确保只有授权的个人才能访问和修改应用程序的某些部分。使用<a href="https://en.wikipedia.org/wiki/Role-based_access_control" target="_blank">基于角色的访问控制</a>(RBAC) 为不同的用户角色定义不同的访问级别。定期审查和更新访问控制，以防止未经授权的访问和权限升级。</li>
<li>定期备份和测试数据：定期备份数据对于灾难恢复和确保应用程序的可用性至关重要。实施强大的备份系统，定期自动创建数据备份。将这些备份存储在与生产环境分开的安全位置。此外，定期测试您的备份，以确保它们可以在数据丢失事件期间恢复。</li>
<li>实施安全的网络基础设施：通过实施防火墙、入侵检测系统和虚拟专用网络 (VPN) 确保您的网络基础设施安全。这些技术可以帮助保护您的应用程序免受未经授权的访问和基于网络的攻击。定期监控和更新您的网络基础设施，以领先于潜在的漏洞。</li>
<li>使用安全编码实践：开发应用程序时，遵循安全编码实践以最大限度地降低安全漏洞的风险。这包括输入验证、输出编码和正确的错误处理等实践。避免使用已弃用或不安全的库和框架，并定期更新代码库以包含最新的安全补丁和修复程序。</li>
</ul>

		</div>


	</article>
</main>
<footer class="post__footer">
	

<div class="post-related">
	<h3>相关文章</h3>
	<ul class="post-related-list">
		
		<li class="post-related-item">
			<a href="/posts/2024/05/07/http/" target="_blank" title="[译]什么是 HTTP？">[译]什么是 HTTP？</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/05/07/thingsboard-domain/" target="_blank" title="ThingsBoard的领域模型">ThingsBoard的领域模型</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/05/07/websocket-alternatives/" target="_blank" title="[译]2024年最好的WebSocket替代品">[译]2024年最好的WebSocket替代品</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/05/07/http2/" target="_blank" title="[译]HTTP 的演变 – HTTP2 深入探讨">[译]HTTP 的演变 – HTTP2 深入探讨</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/05/07/websockets-java/" target="_blank" title="[译]Java和WebSockets：构建可靠的实时应用程序">[译]Java和WebSockets：构建可靠的实时应用程序</a>
		</li>
		
		<li class="post-related-item">
			<a href="/posts/2024/05/07/the-websocket-api-and-protocol-explained/" target="_blank" title="[译]WebSocket API和协议说明">[译]WebSocket API和协议说明</a>
		</li>
		
	</ul>
</div>

</footer>

<footer class="post__footer">
	<footer class="post__footer">
		
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/javascript/" rel="tag">javascript</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/backend/" rel="tag">backend</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/security/" rel="tag">security</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/tutorial/" rel="tag">tutorial</a>
		</li>
	</ul>
</div>
	</footer>
</footer>


<nav class="pagination flex">
	<div class="pagination__item pagination__item--prev">
		<a class="pagination__link" href="/posts/2024/05/07/http3/" rel="prev">
			<p class="pagination__title">«&thinsp;上一篇: [译]什么是HTTP/3？</p>
		</a>
	</div>
	<div class="pagination__item pagination__item--next">
		<a class="pagination__link" href="/posts/2024/05/07/http/" rel="next">
			<p class="pagination__title">&thinsp;» 下一篇: [译]什么是 HTTP？</p>
		</a>
	</div>
</nav>



<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="ChenSoul avatar" src="/avatar.jpg" class="avatar" height="60" width="60" loading="lazy">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">关于 ChenSoul</span>
	</div>
	<div class="authorbox__description">
		一个来自中国武汉的开发者，主要撰写软件开发和开源方面的文章。浏览我的<a href="%28/posts%29">博客文章</a>，订阅我的 <a href="/index.xml">RSS</a> 源，或了解更多<a href="/about/">关于我</a>的信息。
	</div>
</div>




	<p><h3>欢迎留言！</h3></p>
<div id="remark42"></div>
<script>
	var remark_config = {
		host: 'https:\/\/comment.chensoul.cc',
		site_id: 'remark',
		components: ['embed'],
		url: 'https:\/\/blog.chensoul.cc\/posts\/2024\/05\/07\/oauth\/',
		locale: 'zh'
	};

	!function(e, n) {
		for (var o = 0; o < e.length; o++) {
			var r = n.createElement('script'),
			c = '.js',
			d = n.head || n.body;
			'noModule' in r ? (r.type = 'module', c = '.mjs') : r.async = !0, r.defer = !0, r.src = remark_config.host + '/web/' + e[o] + c, d.appendChild(r)
		}
	}(remark_config.components || ['embed'], document);

</script>





			</div>
			

<aside class="sidebar sidebar--right">
	<div class="post__toc toc">
		<div class="toc__title">目录</div>
		<div class="toc__menu">
			<nav id="TableOfContents">
  <ul>
    <li><a href="#什么是-oauth">什么是 OAuth？</a></li>
    <li><a href="#oauth-是如何工作的">OAuth 是如何工作的？</a></li>
    <li><a href="#使用-oauth-有什么好处">使用 OAuth 有什么好处？</a></li>
    <li><a href="#使用-oauth-有哪些缺点">使用 OAuth 有哪些缺点？</a></li>
    <li><a href="#oauth-与-openid">OAuth 与 OpenID</a></li>
    <li><a href="#oauth-与-openid-connect">OAuth 与 OpenID Connect</a></li>
    <li><a href="#oauth-与-saml">OAuth 与 SAML</a></li>
    <li><a href="#oauth-有哪些不同版本">OAuth 有哪些不同版本？</a></li>
    <li><a href="#什么是-oauth-访问令牌">什么是 OAuth 访问令牌？</a></li>
    <li><a href="#有哪些不同类型的流量">有哪些不同类型的流量？</a></li>
    <li><a href="#验证-oauth-请求的步骤是什么">验证 OAuth 请求的步骤是什么？</a></li>
    <li><a href="#oauth-和实时应用程序">OAuth 和实时应用程序</a></li>
  </ul>
</nav>
		</div>
	</div>
</aside>

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
<div class="footer__links">
	<a class="footer__link" href="/">首页</a> | <a class="footer__link" href="/categories/">分类</a> | <a class="footer__link" href="/tags/">标签</a> | <a class="footer__link" href="/index.xml">订阅</a> | <a class="footer__link" href="/about/">关于</a>
</div>
		<div class="footer__copyright">
			&copy; 2025 ChenSoul.
			<span class="footer__copyright-credits">基于 <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> 引擎和 <a href="https://github.com/chensoul/rose-hugo/" rel="nofollow noopener" target="_blank">Rose Hugo</a> 主题</span>
		</div>
	</div>

	






<style>
	.scroll-up a {
		display: block;
		height: 3.125rem;
		width: 3.125rem;
		text-align: center;
		line-height: 2.7;
		border-radius: 50px;
		font-size: 1.125rem;
		color: #fff;
		opacity: 1;
		transition: all 0.3s ease 0s;
		box-shadow: 0 0 10px rgb(0 0 0 / 20%);
	}
	.scroll-up a {
		background: #ee591f;
	}
	.scroll-up {
		position: fixed;
		display: none;
		bottom: 50px;
		z-index: 999;
	}
	.scroll-up.right {
		right: 60px;
	}
</style>

<div class="scroll-up custom right" style="display: block;"><a href="#top" id="top-link" accesskey="g"><i
	class="fa fa-arrow-up"></i></a></div>

<script>
	var mybutton = document.getElementById("top-link");
	window.onscroll = function () {
		if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
			mybutton.style.visibility = "visible";
			mybutton.style.opacity = "1";
		} else {
			mybutton.style.visibility = "hidden";
			mybutton.style.opacity = "0";
		}
	};
</script>


    <script defer src="https://umami.chensoul.cc/random-string.js" data-website-id="1e07d36d-bec3-4ba6-9459-876b1ac3bbe7"></script>
</footer>


	</div>

	<script>
		'use strict';
		(function iifeMenu(document, window, undefined) {
			var menuBtn = document.querySelector('.menu__btn');
			var	menu = document.querySelector('.menu__list');
			function toggleMenu() {
				menu.classList.toggle('menu__list--active');
				menu.classList.toggle('menu__list--transition');
				this.classList.toggle('menu__btn--active');
				this.setAttribute(
					'aria-expanded',
					this.getAttribute('aria-expanded') === 'true' ? 'false' : 'true'
				);
			}
			function removeMenuTransition() {
				this.classList.remove('menu__list--transition');
			}
			if (menuBtn && menu) {
				menuBtn.addEventListener('click', toggleMenu, false);
				menu.addEventListener('transitionend', removeMenuTransition, false);
			}
		}(document, window));
	</script>
</body>
</html>