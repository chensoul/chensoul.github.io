<!doctype html><html class=no-js lang=zh-cn><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Java -</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><link rel=preconnect href=//fonts.loli.net crossorigin><link rel=dns-prefetch href=//fonts.loli.net><link rel=stylesheet href="https://fonts.loli.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.min.css><link rel=alternate type=application/rss+xml href=/tags/java/index.xml title="ChenSoul Blog"><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="ChenSoul Blog" rel=home><div class="logo__item logo__text"><div class=logo__title>ChenSoul Blog</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>菜单</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>首页</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>分类</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>关于</span></a></li><li class=menu__item><a class=menu__link href=/index.xml><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class="main list" role=main><header class=main__header><h1 class=main__title>Java</h1></header><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/2025/03/28/id-generator/ rel=bookmark>常见分布式 ID 解决方案</a></h2></header><div class="content list__excerpt post__content clearfix"><p>分布式 ID 的生成是分布式系统中的一个核心问题，需要确保生成的 ID 全局唯一、性能高效，并且能够适应高并发和大规模的场景。以下是一些常见的分布式 ID 生成方案：</p></div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/2025/02/17/top-n-using-redis/ rel=bookmark>如何实现榜单 top N 统计</a></h2></header><div class="content list__excerpt post__content clearfix"><p>以下是一个基于本地缓存 + Redis ZSet + 定时任务的榜单方案，适用于高并发场景：</p></div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/2025/02/14/retry-for-timeout/ rel=bookmark>区分偶发性超时和频繁超时的重试策略</a></h2></header><div class="content list__excerpt post__content clearfix"><p>在实际项目中，区分偶发性超时和频繁超时的重试策略非常重要。偶发性超时可能是由于网络抖动或临时负载过高引起的，适合立即重试；而频繁超时则可能是系统过载或下游服务不可用，此时应避免重试，以免加剧问题。</p><p>在实际面试的过程中，经常会遇到类似的面试题目，这时候可以这样回答：</p><blockquote><p>在处理大量请求时，我们经常会遇到超时的情况。为了合理控制重试行为，避免所谓的“重试风暴”，我设计了一个基于时间窗口的算法。在这个算法中，我们维护了一个滑动窗口，窗口内记录了每个请求的时间戳以及该请求是否超时。每当一个请求超时后，我们会统计窗口内超时的请求数量。如果超时请求的数量超过了设定的阈值，我们就认为当前系统压力较大，不适合进行重试；否则，我们认为可以安全地进行重试。</p></div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/2025/02/14/rate-limit/ rel=bookmark>什么是限流</a></h2></header><div class="content list__excerpt post__content clearfix"><p>在互联网领域，限流是指对进入系统的请求数量或频率进行控制的一种机制，以防止系统因流量暴增而过载，从而保障系统的稳定性和可用性。</p></div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/2024/08/05/a-crash-course-on-domain-driven-design/ rel=bookmark>[译]领域驱动设计速成课程</a></h2></header><div class="content list__excerpt post__content clearfix"><p>原文链接：<a href=https://blog.bytebytego.com/p/a-crash-course-on-domain-driven-design target=_blank>https://blog.bytebytego.com/p/a-crash-course-on-domain-driven-design</a></p><p>为复杂领域开发软件是一项具有挑战性的任务。</p><p>随着问题领域的复杂性不断增长，创建准确表示业务概念、规则和流程的软件变得越来越困难。设计不良的软件很快就会变成难以理解、难以维护和扩展的混乱代码。</p></div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/2024/06/05/oauth2-with-spring-part-1-knowing-the-basic-concepts/ rel=bookmark>[译]OAuth2 with Spring 第1部分：了解基本概念</a></h2></header><div class="content list__excerpt post__content clearfix"><p>原文地址：<a href=https://mainul35.medium.com/oauth2-with-spring-part-1-knowing-the-basic-concepts-5c4aa17884a target=_blank>https://mainul35.medium.com/oauth2-with-spring-part-1-knowing-the-basic-concepts-5c4aa17884a</a></p><p>在本系列<strong>关于 Spring 的 OAuth2</strong>的文章中，我将尝试介绍和解释与 OAuth2 相关的每一个问题以及如何在 Spring 框架中实现这些问题。请记住，OAuth2 完全是一个概念性的东西，在不同的框架中，它有自己的实现。此外，许多应用程序开发人员开发自己的 OAuth2 实现，而不使用 Spring 框架提供的 OAuth2 框架支持。因此，我将就这个主题撰写一系列文章。</p></div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/2024/06/05/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring/ rel=bookmark>[译]OAuth2 with Spring 第3部分：使用Spring授权服务器授予authorization_code OIDC客户端</a></h2></header><div class="content list__excerpt post__content clearfix"><p>原文地址：<a href=https://mainul35.medium.com/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring-67769f9dd68a target=_blank>https://mainul35.medium.com/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring-67769f9dd68a</a></p><p>在<a href=/posts/2024/06/05/oauth2-with-spring-part-2-getting-started-with-authorization-server/>上一篇文章</a>中，我们讨论了使用 client_credential 的 OAuth2 授权服务器配置。在本文中，我们将讨论使用 authorization_code 授予类型的授权服务器配置。此授权流程将有一个 OIDC 客户端，它将通过使用授权码进行请求来获取 JWT 令牌。</p></div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/2024/06/05/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google/ rel=bookmark>[译]OAuth2 with Spring 第4部分：Spring授权客户端与Google授权服务器的社交登录演示</a></h2></header><div class="content list__excerpt post__content clearfix"><p>原文地址：<a href=https://mainul35.medium.com/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google-be6097ec18a5 target=_blank>https://mainul35.medium.com/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google-be6097ec18a5</a></p><p>在<a href=/posts/2024/06/05/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring/>之前的文章</a>中，我们学习了如何使用 OIDC 连接到我们自己的授权服务器。我们在自托管授权服务器中定义了我们自己的客户端应用程序。在今天的文章中，我们将使用 Google 和 GitHub 作为我们的授权服务器，并将我们的授权客户端应用程序连接到这些授权服务器并从它们接收令牌。应用程序登录屏幕将如下所示。</p></div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/2024/06/05/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security/ rel=bookmark>[译]OAuth2 with Spring 第5部分：使用PKCE保护您的Spring Boot应用程序以增强安全性</a></h2></header><div class="content list__excerpt post__content clearfix"><p>原文地址：<a href=https://mainul35.medium.com/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security-d8025cd08769 target=_blank>https://mainul35.medium.com/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security-d8025cd08769</a></p><blockquote><p>免责声明：本文技术性很强，需要清楚了解本系列前几篇文章，特别是第 1 部分和第 3 部分。</p></div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/2024/05/07/websockets-kafka/ rel=bookmark>[译]如何通过 WebSocket 将 Kafka 消息流式传输到面向互联网的客户端</a></h2></header><div class="content list__excerpt post__content clearfix"><p>原文链接：<a href=https://ably.com/topic/websockets-kafka target=_blank>https://ably.com/topic/websockets-kafka</a></p><p>Apache Kafka 是目前最强大的异步消息传递技术之一。 Kafka 由 Jay Kreps、Jun Rao 和 Neha Narkhede 等团队于 2010 年在 LinkedIn 设计，并于 2011 年初开源。如今，该工具被众多公司（包括科技巨头，例如 Slack、Airbnb 或 Netflix 使用）为其实时数据流管道提供支持。</p></div></article></main><div class=pagination><span class="pagination__item pagination__item--current">1/2</span>
<a class="pagination__item pagination__item--next btn" href=/tags/java/page/2/>»</a></div></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__links><a class=footer__link href=/>首页</a> | <a class=footer__link href=/categories/>分类</a> | <a class=footer__link href=/about/>关于</a> | <a class=footer__link href=/index.xml>RSS</a></div><div class=footer__copyright>&copy; 2025 ChenSoul.
<span class=footer__copyright-credits>基于 <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> 引擎和 <a href=https://github.com/chensoul/rose-hugo/ rel="nofollow noopener" target=_blank>Rose Hugo</a> 主题</span></div></div><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></footer></div><script>"use strict";(function(t){var i=t.querySelector(".menu__btn"),o=t.querySelector(".menu__list");function a(){o.classList.toggle("menu__list--active"),o.classList.toggle("menu__list--transition"),this.classList.toggle("menu__btn--active"),this.setAttribute("aria-expanded",this.getAttribute("aria-expanded")==="true"?"false":"true")}function r(){this.classList.remove("menu__list--transition")}i&&o&&(i.addEventListener("click",a,!1),o.addEventListener("transitionend",r,!1))})(document,window)</script></body></html>