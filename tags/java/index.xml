<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on ChenSoul Blog</title><link>https://blog.chensoul.cc/tags/java/</link><description>Recent content in Java on ChenSoul Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 28 Mar 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.chensoul.cc/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>常见分布式 ID 解决方案</title><link>https://blog.chensoul.cc/posts/2025/03/28/id-generator/</link><pubDate>Fri, 28 Mar 2025 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2025/03/28/id-generator/</guid><description>&lt;p&gt;分布式 ID 的生成是分布式系统中的一个核心问题，需要确保生成的 ID 全局唯一、性能高效，并且能够适应高并发和大规模的场景。以下是一些常见的分布式 ID 生成方案：&lt;/p&gt;</description></item><item><title>如何实现榜单 top N 统计</title><link>https://blog.chensoul.cc/posts/2025/02/17/top-n-using-redis/</link><pubDate>Mon, 17 Feb 2025 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2025/02/17/top-n-using-redis/</guid><description>&lt;p&gt;以下是一个基于本地缓存 + Redis ZSet + 定时任务的榜单方案，适用于高并发场景：&lt;/p&gt;</description></item><item><title>区分偶发性超时和频繁超时的重试策略</title><link>https://blog.chensoul.cc/posts/2025/02/14/retry-for-timeout/</link><pubDate>Fri, 14 Feb 2025 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2025/02/14/retry-for-timeout/</guid><description>&lt;p&gt;在实际项目中，区分偶发性超时和频繁超时的重试策略非常重要。偶发性超时可能是由于网络抖动或临时负载过高引起的，适合立即重试；而频繁超时则可能是系统过载或下游服务不可用，此时应避免重试，以免加剧问题。&lt;/p&gt;
&lt;p&gt;在实际面试的过程中，经常会遇到类似的面试题目，这时候可以这样回答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在处理大量请求时，我们经常会遇到超时的情况。为了合理控制重试行为，避免所谓的“重试风暴”，我设计了一个基于时间窗口的算法。在这个算法中，我们维护了一个滑动窗口，窗口内记录了每个请求的时间戳以及该请求是否超时。每当一个请求超时后，我们会统计窗口内超时的请求数量。如果超时请求的数量超过了设定的阈值，我们就认为当前系统压力较大，不适合进行重试；否则，我们认为可以安全地进行重试。&lt;/p&gt;</description></item><item><title>什么是限流</title><link>https://blog.chensoul.cc/posts/2025/02/14/rate-limit/</link><pubDate>Fri, 14 Feb 2025 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2025/02/14/rate-limit/</guid><description>&lt;p&gt;在互联网领域，限流是指对进入系统的请求数量或频率进行控制的一种机制，以防止系统因流量暴增而过载，从而保障系统的稳定性和可用性。&lt;/p&gt;</description></item><item><title>[译]领域驱动设计速成课程</title><link>https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-on-domain-driven-design/</link><pubDate>Mon, 05 Aug 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/08/05/a-crash-course-on-domain-driven-design/</guid><description>&lt;p&gt;原文链接：&lt;a href="https://blog.bytebytego.com/p/a-crash-course-on-domain-driven-design" target="_blank"&gt;https://blog.bytebytego.com/p/a-crash-course-on-domain-driven-design&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为复杂领域开发软件是一项具有挑战性的任务。&lt;/p&gt;
&lt;p&gt;随着问题领域的复杂性不断增长，创建准确表示业务概念、规则和流程的软件变得越来越困难。设计不良的软件很快就会变成难以理解、难以维护和扩展的混乱代码。&lt;/p&gt;</description></item><item><title>[译]OAuth2 with Spring 第1部分：了解基本概念</title><link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-1-knowing-the-basic-concepts/</link><pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-1-knowing-the-basic-concepts/</guid><description>&lt;p&gt;原文地址：&lt;a href="https://mainul35.medium.com/oauth2-with-spring-part-1-knowing-the-basic-concepts-5c4aa17884a" target="_blank"&gt;https://mainul35.medium.com/oauth2-with-spring-part-1-knowing-the-basic-concepts-5c4aa17884a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在本系列&lt;strong&gt;关于 Spring 的 OAuth2&lt;/strong&gt;的文章中，我将尝试介绍和解释与 OAuth2 相关的每一个问题以及如何在 Spring 框架中实现这些问题。请记住，OAuth2 完全是一个概念性的东西，在不同的框架中，它有自己的实现。此外，许多应用程序开发人员开发自己的 OAuth2 实现，而不使用 Spring 框架提供的 OAuth2 框架支持。因此，我将就这个主题撰写一系列文章。&lt;/p&gt;</description></item><item><title>[译]OAuth2 with Spring 第3部分：使用Spring授权服务器授予authorization_code OIDC客户端</title><link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring/</link><pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring/</guid><description>&lt;p&gt;原文地址：&lt;a href="https://mainul35.medium.com/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring-67769f9dd68a" target="_blank"&gt;https://mainul35.medium.com/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring-67769f9dd68a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href="https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-2-getting-started-with-authorization-server/"&gt;上一篇文章&lt;/a&gt;中，我们讨论了使用 client_credential 的 OAuth2 授权服务器配置。在本文中，我们将讨论使用 authorization_code 授予类型的授权服务器配置。此授权流程将有一个 OIDC 客户端，它将通过使用授权码进行请求来获取 JWT 令牌。&lt;/p&gt;</description></item><item><title>[译]OAuth2 with Spring 第4部分：Spring授权客户端与Google授权服务器的社交登录演示</title><link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google/</link><pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google/</guid><description>&lt;p&gt;原文地址：&lt;a href="https://mainul35.medium.com/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google-be6097ec18a5" target="_blank"&gt;https://mainul35.medium.com/oauth2-with-spring-part-4-spring-authorization-client-social-login-demo-with-google-be6097ec18a5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href="https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-3-authorizing-oidc-client-with-via-authorization-code-grant-from-spring/"&gt;之前的文章&lt;/a&gt;中，我们学习了如何使用 OIDC 连接到我们自己的授权服务器。我们在自托管授权服务器中定义了我们自己的客户端应用程序。在今天的文章中，我们将使用 Google 和 GitHub 作为我们的授权服务器，并将我们的授权客户端应用程序连接到这些授权服务器并从它们接收令牌。应用程序登录屏幕将如下所示。&lt;/p&gt;</description></item><item><title>[译]OAuth2 with Spring 第5部分：使用PKCE保护您的Spring Boot应用程序以增强安全性</title><link>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security/</link><pubDate>Wed, 05 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/06/05/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security/</guid><description>&lt;p&gt;原文地址：&lt;a href="https://mainul35.medium.com/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security-d8025cd08769" target="_blank"&gt;https://mainul35.medium.com/oauth2-with-spring-part-5-securing-your-spring-boot-application-with-pkce-for-enhanced-security-d8025cd08769&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;免责声明：本文技术性很强，需要清楚了解本系列前几篇文章，特别是第 1 部分和第 3 部分。&lt;/p&gt;</description></item><item><title>[译]如何通过 WebSocket 将 Kafka 消息流式传输到面向互联网的客户端</title><link>https://blog.chensoul.cc/posts/2024/05/07/websockets-kafka/</link><pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2024/05/07/websockets-kafka/</guid><description>&lt;p&gt;原文链接：&lt;a href="https://ably.com/topic/websockets-kafka" target="_blank"&gt;https://ably.com/topic/websockets-kafka&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Apache Kafka 是目前最强大的异步消息传递技术之一。 Kafka 由 Jay Kreps、Jun Rao 和 Neha Narkhede 等团队于 2010 年在 LinkedIn 设计，并于 2011 年初开源。如今，该工具被众多公司（包括科技巨头，例如 Slack、Airbnb 或 Netflix 使用）为其实时数据流管道提供支持。&lt;/p&gt;</description></item><item><title>[译]微服务设计模式</title><link>https://blog.chensoul.cc/posts/2023/06/26/microservice-design-patterns/</link><pubDate>Mon, 26 Jun 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/06/26/microservice-design-patterns/</guid><description>&lt;p&gt;基于微服务的应用程序的主要特征在 &lt;a href="http://web.archive.org/web/20190705163602/http://blog.arungupta.me/microservices-monoliths-noops/" target="_blank"&gt;微服务、单体和 NoOps&lt;/a&gt; 中定义。它们是功能分解或领域驱动设计、定义良好的接口、明确发布的接口、单一责任原则和潜在的多语言。每项服务都是完全自主和全栈的。&lt;/p&gt;</description></item><item><title>JSR 166规范</title><link>https://blog.chensoul.cc/posts/2023/05/18/jsr-166/</link><pubDate>Thu, 18 May 2023 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2023/05/18/jsr-166/</guid><description>&lt;h2 id="jsr-介绍"&gt;JSR 介绍&lt;/h2&gt;
&lt;p&gt;JSR，全称 Java Specification Requests， 即 Java 规范提案， 主要是用于向 JCP(Java Community Process) 提出新增标准化技术规范的正式请求。每次 JAVA 版本更新都会有对应的 JSR 更新，比如在 Java 8 版本中，其新特性 Lambda 表达式对应的是 &lt;a href="http://jcp.org/en/jsr/detail?id=335" target="_blank"&gt;JSR 335&lt;/a&gt;，新的日期和时间 API 对应的是 &lt;a href="http://jcp.org/en/jsr/detail?id=310" target="_blank"&gt;JSR 310&lt;/a&gt;。&lt;/p&gt;</description></item></channel></rss>