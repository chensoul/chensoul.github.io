<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Retry on ChenSoul Blog</title><link>https://blog.chensoul.cc/tags/retry/</link><description>Recent content in Retry on ChenSoul Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 14 Feb 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.chensoul.cc/tags/retry/index.xml" rel="self" type="application/rss+xml"/><item><title>区分偶发性超时和频繁超时的重试策略</title><link>https://blog.chensoul.cc/posts/2025/02/14/retry-for-timeout/</link><pubDate>Fri, 14 Feb 2025 00:00:00 +0000</pubDate><guid>https://blog.chensoul.cc/posts/2025/02/14/retry-for-timeout/</guid><description>&lt;p&gt;在实际项目中，区分偶发性超时和频繁超时的重试策略非常重要。偶发性超时可能是由于网络抖动或临时负载过高引起的，适合立即重试；而频繁超时则可能是系统过载或下游服务不可用，此时应避免重试，以免加剧问题。&lt;/p&gt;
&lt;p&gt;在实际面试的过程中，经常会遇到类似的面试题目，这时候可以这样回答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在处理大量请求时，我们经常会遇到超时的情况。为了合理控制重试行为，避免所谓的“重试风暴”，我设计了一个基于时间窗口的算法。在这个算法中，我们维护了一个滑动窗口，窗口内记录了每个请求的时间戳以及该请求是否超时。每当一个请求超时后，我们会统计窗口内超时的请求数量。如果超时请求的数量超过了设定的阈值，我们就认为当前系统压力较大，不适合进行重试；否则，我们认为可以安全地进行重试。&lt;/p&gt;</description></item></channel></rss>